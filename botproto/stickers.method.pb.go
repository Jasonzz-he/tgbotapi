// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stickers.method.proto

package botproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// return Message
// Use this method to send static .WEBP or animated .TGS stickers. On success, the sent Message is returned.
type SendSticker struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Sticker             string       `protobuf:"bytes,2,opt,name=sticker,proto3" json:"sticker,omitempty"`
	DisableNotification bool         `protobuf:"varint,3,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,4,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,5,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendSticker) Reset()                    { *m = SendSticker{} }
func (m *SendSticker) String() string            { return proto.CompactTextString(m) }
func (*SendSticker) ProtoMessage()               {}
func (*SendSticker) Descriptor() ([]byte, []int) { return fileDescriptorStickersMethod, []int{0} }

func (m *SendSticker) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendSticker) GetSticker() string {
	if m != nil {
		return m.Sticker
	}
	return ""
}

func (m *SendSticker) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendSticker) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendSticker) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return
// Use this method to get a sticker set. On success, a StickerSet object is returned.
type GetStickerSet struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetStickerSet) Reset()                    { *m = GetStickerSet{} }
func (m *GetStickerSet) String() string            { return proto.CompactTextString(m) }
func (*GetStickerSet) ProtoMessage()               {}
func (*GetStickerSet) Descriptor() ([]byte, []int) { return fileDescriptorStickersMethod, []int{1} }

func (m *GetStickerSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// return File
// Use this method to upload a .png file with a sticker for later use in createNewStickerSet and addStickerToSet methods (can be used multiple times). Returns the uploaded File on success.
type UploadStickerFile struct {
	UserId     int32      `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PngSticker *InputFile `protobuf:"bytes,2,opt,name=png_sticker,json=pngSticker" json:"png_sticker,omitempty"`
}

func (m *UploadStickerFile) Reset()                    { *m = UploadStickerFile{} }
func (m *UploadStickerFile) String() string            { return proto.CompactTextString(m) }
func (*UploadStickerFile) ProtoMessage()               {}
func (*UploadStickerFile) Descriptor() ([]byte, []int) { return fileDescriptorStickersMethod, []int{2} }

func (m *UploadStickerFile) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UploadStickerFile) GetPngSticker() *InputFile {
	if m != nil {
		return m.PngSticker
	}
	return nil
}

// return True
// Use this method to create new sticker set owned by a user. The bot will be able to edit the created sticker set. Returns True on success.
type CreateNewStickerSet struct {
	UserId        int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Name          string        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Title         string        `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	PngSticker    string        `protobuf:"bytes,4,opt,name=png_sticker,json=pngSticker,proto3" json:"png_sticker,omitempty"`
	Emojis        string        `protobuf:"bytes,5,opt,name=emojis,proto3" json:"emojis,omitempty"`
	ContainsMasks bool          `protobuf:"varint,6,opt,name=contains_masks,json=containsMasks,proto3" json:"contains_masks,omitempty"`
	MaskPosition  *MaskPosition `protobuf:"bytes,7,opt,name=mask_position,json=maskPosition" json:"mask_position,omitempty"`
}

func (m *CreateNewStickerSet) Reset()         { *m = CreateNewStickerSet{} }
func (m *CreateNewStickerSet) String() string { return proto.CompactTextString(m) }
func (*CreateNewStickerSet) ProtoMessage()    {}
func (*CreateNewStickerSet) Descriptor() ([]byte, []int) {
	return fileDescriptorStickersMethod, []int{3}
}

func (m *CreateNewStickerSet) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CreateNewStickerSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateNewStickerSet) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CreateNewStickerSet) GetPngSticker() string {
	if m != nil {
		return m.PngSticker
	}
	return ""
}

func (m *CreateNewStickerSet) GetEmojis() string {
	if m != nil {
		return m.Emojis
	}
	return ""
}

func (m *CreateNewStickerSet) GetContainsMasks() bool {
	if m != nil {
		return m.ContainsMasks
	}
	return false
}

func (m *CreateNewStickerSet) GetMaskPosition() *MaskPosition {
	if m != nil {
		return m.MaskPosition
	}
	return nil
}

// return True
// Use this method to move a sticker in a set created by the bot to a specific position . Returns True on success.
type SetStickerPositionInSet struct {
	Sticker  string `protobuf:"bytes,1,opt,name=sticker,proto3" json:"sticker,omitempty"`
	Position int32  `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
}

func (m *SetStickerPositionInSet) Reset()         { *m = SetStickerPositionInSet{} }
func (m *SetStickerPositionInSet) String() string { return proto.CompactTextString(m) }
func (*SetStickerPositionInSet) ProtoMessage()    {}
func (*SetStickerPositionInSet) Descriptor() ([]byte, []int) {
	return fileDescriptorStickersMethod, []int{4}
}

func (m *SetStickerPositionInSet) GetSticker() string {
	if m != nil {
		return m.Sticker
	}
	return ""
}

func (m *SetStickerPositionInSet) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

// return True
// Use this method to delete a sticker from a set created by the bot. Returns True on success.
type DeleteStickerFromSet struct {
	Sticker string `protobuf:"bytes,1,opt,name=sticker,proto3" json:"sticker,omitempty"`
}

func (m *DeleteStickerFromSet) Reset()         { *m = DeleteStickerFromSet{} }
func (m *DeleteStickerFromSet) String() string { return proto.CompactTextString(m) }
func (*DeleteStickerFromSet) ProtoMessage()    {}
func (*DeleteStickerFromSet) Descriptor() ([]byte, []int) {
	return fileDescriptorStickersMethod, []int{5}
}

func (m *DeleteStickerFromSet) GetSticker() string {
	if m != nil {
		return m.Sticker
	}
	return ""
}

func init() {
	proto.RegisterType((*SendSticker)(nil), "botproto.sendSticker")
	proto.RegisterType((*GetStickerSet)(nil), "botproto.getStickerSet")
	proto.RegisterType((*UploadStickerFile)(nil), "botproto.uploadStickerFile")
	proto.RegisterType((*CreateNewStickerSet)(nil), "botproto.createNewStickerSet")
	proto.RegisterType((*SetStickerPositionInSet)(nil), "botproto.setStickerPositionInSet")
	proto.RegisterType((*DeleteStickerFromSet)(nil), "botproto.deleteStickerFromSet")
}
func (m *SendSticker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendSticker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Sticker) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(len(m.Sticker)))
		i += copy(dAtA[i:], m.Sticker)
	}
	if m.DisableNotification {
		dAtA[i] = 0x18
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n1, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *GetStickerSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStickerSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *UploadStickerFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadStickerFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(m.UserId))
	}
	if m.PngSticker != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(m.PngSticker.Size()))
		n2, err := m.PngSticker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *CreateNewStickerSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateNewStickerSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(m.UserId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.PngSticker) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(len(m.PngSticker)))
		i += copy(dAtA[i:], m.PngSticker)
	}
	if len(m.Emojis) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(len(m.Emojis)))
		i += copy(dAtA[i:], m.Emojis)
	}
	if m.ContainsMasks {
		dAtA[i] = 0x30
		i++
		if m.ContainsMasks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaskPosition != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(m.MaskPosition.Size()))
		n3, err := m.MaskPosition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *SetStickerPositionInSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetStickerPositionInSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sticker) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(len(m.Sticker)))
		i += copy(dAtA[i:], m.Sticker)
	}
	if m.Position != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(m.Position))
	}
	return i, nil
}

func (m *DeleteStickerFromSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteStickerFromSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sticker) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStickersMethod(dAtA, i, uint64(len(m.Sticker)))
		i += copy(dAtA[i:], m.Sticker)
	}
	return i, nil
}

func encodeFixed64StickersMethod(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32StickersMethod(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintStickersMethod(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SendSticker) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	l = len(m.Sticker)
	if l > 0 {
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovStickersMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	return n
}

func (m *GetStickerSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	return n
}

func (m *UploadStickerFile) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovStickersMethod(uint64(m.UserId))
	}
	if m.PngSticker != nil {
		l = m.PngSticker.Size()
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	return n
}

func (m *CreateNewStickerSet) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovStickersMethod(uint64(m.UserId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	l = len(m.PngSticker)
	if l > 0 {
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	l = len(m.Emojis)
	if l > 0 {
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	if m.ContainsMasks {
		n += 2
	}
	if m.MaskPosition != nil {
		l = m.MaskPosition.Size()
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	return n
}

func (m *SetStickerPositionInSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sticker)
	if l > 0 {
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovStickersMethod(uint64(m.Position))
	}
	return n
}

func (m *DeleteStickerFromSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sticker)
	if l > 0 {
		n += 1 + l + sovStickersMethod(uint64(l))
	}
	return n
}

func sovStickersMethod(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStickersMethod(x uint64) (n int) {
	return sovStickersMethod(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SendSticker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickersMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendSticker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendSticker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickersMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickersMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStickerSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickersMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getStickerSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getStickerSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickersMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickersMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadStickerFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickersMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: uploadStickerFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: uploadStickerFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PngSticker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PngSticker == nil {
				m.PngSticker = &InputFile{}
			}
			if err := m.PngSticker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickersMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickersMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateNewStickerSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickersMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: createNewStickerSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: createNewStickerSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PngSticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PngSticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emojis", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emojis = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsMasks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainsMasks = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaskPosition == nil {
				m.MaskPosition = &MaskPosition{}
			}
			if err := m.MaskPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickersMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickersMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetStickerPositionInSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickersMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: setStickerPositionInSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: setStickerPositionInSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStickersMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickersMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteStickerFromSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStickersMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: deleteStickerFromSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: deleteStickerFromSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStickersMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStickersMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStickersMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStickersMethod(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStickersMethod
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStickersMethod
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStickersMethod
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStickersMethod
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStickersMethod(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStickersMethod = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStickersMethod   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("stickers.method.proto", fileDescriptorStickersMethod) }

var fileDescriptorStickersMethod = []byte{
	// 457 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x52, 0xc1, 0x8e, 0xd3, 0x30,
	0x10, 0x95, 0x97, 0x36, 0x6d, 0x27, 0xed, 0x0a, 0xdc, 0xee, 0x6e, 0xb4, 0x87, 0x52, 0x05, 0x21,
	0xf5, 0x42, 0x05, 0x0b, 0x07, 0x24, 0x6e, 0x1c, 0x90, 0x72, 0xe8, 0x82, 0xbc, 0xdc, 0x23, 0x27,
	0x19, 0xb2, 0xa6, 0x89, 0x1d, 0xc5, 0xae, 0x10, 0x7f, 0xc8, 0x91, 0x0f, 0xe0, 0x80, 0xfa, 0x0f,
	0xdc, 0x91, 0x9d, 0xa4, 0xcd, 0x1e, 0xe0, 0xe6, 0x37, 0xcf, 0x9e, 0x79, 0xef, 0x8d, 0xe1, 0x42,
	0x1b, 0x91, 0xee, 0xb0, 0xd6, 0x9b, 0x12, 0xcd, 0xbd, 0xca, 0x36, 0x55, 0xad, 0x8c, 0xa2, 0xe3,
	0x44, 0x19, 0x77, 0xba, 0x3e, 0x37, 0x79, 0xa2, 0x0c, 0xaf, 0x44, 0xc3, 0x84, 0xbf, 0x08, 0xf8,
	0x1a, 0x65, 0x76, 0xd7, 0xbc, 0xa3, 0x57, 0x30, 0x4a, 0xef, 0xb9, 0x89, 0x45, 0x16, 0x90, 0x15,
	0x59, 0x4f, 0x98, 0x67, 0x61, 0x94, 0xd1, 0x00, 0x46, 0x6d, 0xef, 0xe0, 0xcc, 0x11, 0x1d, 0xa4,
	0xaf, 0x60, 0x91, 0x09, 0xcd, 0x93, 0x02, 0x63, 0xa9, 0x8c, 0xf8, 0x22, 0x52, 0x6e, 0x84, 0x92,
	0xc1, 0xa3, 0x15, 0x59, 0x8f, 0xd9, 0xbc, 0xe5, 0x6e, 0x7b, 0x14, 0x7d, 0x01, 0xf3, 0x1a, 0xab,
	0xe2, 0x7b, 0x6c, 0x54, 0x5c, 0xa2, 0xd6, 0x3c, 0x47, 0x3b, 0x71, 0xb0, 0x22, 0xeb, 0x21, 0x7b,
	0xec, 0xa8, 0xcf, 0x6a, 0xdb, 0x10, 0x51, 0x46, 0xdf, 0xc2, 0xb4, 0xb9, 0x5e, 0xf2, 0x7a, 0xb7,
	0xaf, 0x82, 0xe1, 0x8a, 0xac, 0xfd, 0x9b, 0x8b, 0x4d, 0xe7, 0x6a, 0xc3, 0x2c, 0xbb, 0x75, 0x24,
	0xf3, 0xeb, 0x13, 0x08, 0x9f, 0xc1, 0x2c, 0x47, 0xd3, 0x9a, 0xbb, 0x43, 0x43, 0x29, 0x0c, 0x24,
	0x2f, 0xb1, 0x35, 0xe7, 0xce, 0x61, 0x02, 0x4f, 0xf6, 0x55, 0xa1, 0x78, 0x17, 0xc2, 0x07, 0x51,
	0xa0, 0x0d, 0x62, 0xaf, 0xb1, 0xee, 0x82, 0x18, 0x32, 0xcf, 0xc2, 0x28, 0xa3, 0x6f, 0xc0, 0xaf,
	0x64, 0x1e, 0xf7, 0xc3, 0xf0, 0x6f, 0xe6, 0x27, 0x2d, 0x91, 0xac, 0xf6, 0xc6, 0xb6, 0x60, 0x50,
	0xc9, 0xbc, 0x6d, 0x19, 0xfe, 0x21, 0x30, 0x4f, 0x6b, 0xe4, 0x06, 0x6f, 0xf1, 0x5b, 0x4f, 0xcf,
	0x3f, 0xc7, 0x74, 0x42, 0xcf, 0x4e, 0x42, 0xe9, 0x02, 0x86, 0x46, 0x98, 0x02, 0x5d, 0xb4, 0x13,
	0xd6, 0x00, 0xfa, 0xf4, 0xa1, 0xa0, 0x81, 0xe3, 0x7a, 0xb3, 0xe9, 0x25, 0x78, 0x58, 0xaa, 0xaf,
	0x42, 0xbb, 0xe0, 0x26, 0xac, 0x45, 0xf4, 0x39, 0x9c, 0xa7, 0x4a, 0x1a, 0x2e, 0xa4, 0x8e, 0x4b,
	0xae, 0x77, 0x3a, 0xf0, 0xdc, 0xca, 0x66, 0x5d, 0x75, 0x6b, 0x8b, 0xf4, 0x1d, 0xcc, 0x2c, 0x1b,
	0x57, 0x4a, 0x0b, 0xb7, 0xd8, 0x91, 0xb3, 0x7c, 0x79, 0xb2, 0x6c, 0xef, 0x7d, 0x6a, 0x59, 0x36,
	0x2d, 0x7b, 0x28, 0xfc, 0x08, 0x57, 0xfa, 0xb8, 0x80, 0xae, 0x1a, 0x49, 0x6b, 0xbd, 0xf7, 0xa3,
	0xc8, 0xc3, 0x1f, 0x75, 0x0d, 0xe3, 0xe3, 0xb0, 0x33, 0x97, 0xca, 0x11, 0x87, 0x2f, 0x61, 0x91,
	0x61, 0x81, 0x06, 0xbb, 0x65, 0xd5, 0xaa, 0xfc, 0x6f, 0xb7, 0xf7, 0xd3, 0x1f, 0x87, 0x25, 0xf9,
	0x79, 0x58, 0x92, 0xdf, 0x87, 0x25, 0x49, 0x3c, 0x27, 0xf9, 0xf5, 0xdf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x28, 0xa7, 0xed, 0xf0, 0x2a, 0x03, 0x00, 0x00,
}
