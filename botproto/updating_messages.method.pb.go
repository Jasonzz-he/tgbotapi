// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: updating_messages.method.proto

package botproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// return
// Use this method to edit text and game messages. On success, if edited message is sent by the bot, the edited Message is returned, otherwise True is returned.
type EditMessageText struct {
	ChatId                string                `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId             int32                 `protobuf:"varint,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	InlineMessageId       string                `protobuf:"bytes,3,opt,name=inline_message_id,json=inlineMessageId,proto3" json:"inline_message_id,omitempty"`
	Text                  string                `protobuf:"bytes,4,opt,name=text,proto3" json:"text,omitempty"`
	ParseMode             string                `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	DisableWebPagePreview bool                  `protobuf:"varint,6,opt,name=disable_web_page_preview,json=disableWebPagePreview,proto3" json:"disable_web_page_preview,omitempty"`
	ReplyMarkup           *InlineKeyboardMarkup `protobuf:"bytes,7,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *EditMessageText) Reset()         { *m = EditMessageText{} }
func (m *EditMessageText) String() string { return proto.CompactTextString(m) }
func (*EditMessageText) ProtoMessage()    {}
func (*EditMessageText) Descriptor() ([]byte, []int) {
	return fileDescriptorUpdatingMessagesMethod, []int{0}
}

func (m *EditMessageText) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *EditMessageText) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *EditMessageText) GetInlineMessageId() string {
	if m != nil {
		return m.InlineMessageId
	}
	return ""
}

func (m *EditMessageText) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *EditMessageText) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *EditMessageText) GetDisableWebPagePreview() bool {
	if m != nil {
		return m.DisableWebPagePreview
	}
	return false
}

func (m *EditMessageText) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return
// Use this method to edit captions of messages. On success, if edited message is sent by the bot, the edited Message is returned, otherwise True is returned.
type EditMessageCaption struct {
	ChatId          string                `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId       int32                 `protobuf:"varint,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	InlineMessageId string                `protobuf:"bytes,3,opt,name=inline_message_id,json=inlineMessageId,proto3" json:"inline_message_id,omitempty"`
	Caption         string                `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode       string                `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup     *InlineKeyboardMarkup `protobuf:"bytes,6,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *EditMessageCaption) Reset()         { *m = EditMessageCaption{} }
func (m *EditMessageCaption) String() string { return proto.CompactTextString(m) }
func (*EditMessageCaption) ProtoMessage()    {}
func (*EditMessageCaption) Descriptor() ([]byte, []int) {
	return fileDescriptorUpdatingMessagesMethod, []int{1}
}

func (m *EditMessageCaption) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *EditMessageCaption) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *EditMessageCaption) GetInlineMessageId() string {
	if m != nil {
		return m.InlineMessageId
	}
	return ""
}

func (m *EditMessageCaption) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *EditMessageCaption) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *EditMessageCaption) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return
// Use this method to edit animation, audio, document, photo, or video messages. If a message is a part of a message album, then it can be edited only to a photo or a video. Otherwise, message type can be changed arbitrarily. When inline message is edited, new file can't be uploaded. Use previously uploaded file via its file_id or specify a URL. On success, if the edited message was sent by the bot, the edited Message is returned, otherwise True is returned.
type EditMessageMedia struct {
	ChatId          string                `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId       int32                 `protobuf:"varint,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	InlineMessageId string                `protobuf:"bytes,3,opt,name=inline_message_id,json=inlineMessageId,proto3" json:"inline_message_id,omitempty"`
	Media           *InputMedia           `protobuf:"bytes,4,opt,name=media" json:"media,omitempty"`
	ReplyMarkup     *InlineKeyboardMarkup `protobuf:"bytes,5,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *EditMessageMedia) Reset()         { *m = EditMessageMedia{} }
func (m *EditMessageMedia) String() string { return proto.CompactTextString(m) }
func (*EditMessageMedia) ProtoMessage()    {}
func (*EditMessageMedia) Descriptor() ([]byte, []int) {
	return fileDescriptorUpdatingMessagesMethod, []int{2}
}

func (m *EditMessageMedia) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *EditMessageMedia) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *EditMessageMedia) GetInlineMessageId() string {
	if m != nil {
		return m.InlineMessageId
	}
	return ""
}

func (m *EditMessageMedia) GetMedia() *InputMedia {
	if m != nil {
		return m.Media
	}
	return nil
}

func (m *EditMessageMedia) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return
// Use this method to edit only the reply markup of messages. On success, if edited message is sent by the bot, the edited Message is returned, otherwise True is returned.
type EditMessageReplyMarkup struct {
	ChatId          string                `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId       int32                 `protobuf:"varint,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	InlineMessageId string                `protobuf:"bytes,3,opt,name=inline_message_id,json=inlineMessageId,proto3" json:"inline_message_id,omitempty"`
	ReplyMarkup     *InlineKeyboardMarkup `protobuf:"bytes,4,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *EditMessageReplyMarkup) Reset()         { *m = EditMessageReplyMarkup{} }
func (m *EditMessageReplyMarkup) String() string { return proto.CompactTextString(m) }
func (*EditMessageReplyMarkup) ProtoMessage()    {}
func (*EditMessageReplyMarkup) Descriptor() ([]byte, []int) {
	return fileDescriptorUpdatingMessagesMethod, []int{3}
}

func (m *EditMessageReplyMarkup) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *EditMessageReplyMarkup) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *EditMessageReplyMarkup) GetInlineMessageId() string {
	if m != nil {
		return m.InlineMessageId
	}
	return ""
}

func (m *EditMessageReplyMarkup) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return
// Use this method to stop a poll which was sent by the bot. On success, the stopped Poll with the final results is returned.
type StopPoll struct {
	ChatId      string                `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId   int32                 `protobuf:"varint,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	ReplyMarkup *InlineKeyboardMarkup `protobuf:"bytes,3,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *StopPoll) Reset()                    { *m = StopPoll{} }
func (m *StopPoll) String() string            { return proto.CompactTextString(m) }
func (*StopPoll) ProtoMessage()               {}
func (*StopPoll) Descriptor() ([]byte, []int) { return fileDescriptorUpdatingMessagesMethod, []int{4} }

func (m *StopPoll) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *StopPoll) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *StopPoll) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return True
// Use this method to delete a message, including service messages, with the following limitations:- A message can only be deleted if it was sent less than 48 hours ago.- Bots can delete outgoing messages in private chats, groups, and supergroups.- Bots can delete incoming messages in private chats.- Bots granted can_post_messages permissions can delete outgoing messages in channels.- If the bot is an administrator of a group, it can delete any message there.- If the bot has can_delete_messages permission in a supergroup or a channel, it can delete any message there.Returns True on success.
type DeleteMessage struct {
	ChatId    string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId int32  `protobuf:"varint,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *DeleteMessage) Reset()         { *m = DeleteMessage{} }
func (m *DeleteMessage) String() string { return proto.CompactTextString(m) }
func (*DeleteMessage) ProtoMessage()    {}
func (*DeleteMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorUpdatingMessagesMethod, []int{5}
}

func (m *DeleteMessage) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *DeleteMessage) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func init() {
	proto.RegisterType((*EditMessageText)(nil), "botproto.editMessageText")
	proto.RegisterType((*EditMessageCaption)(nil), "botproto.editMessageCaption")
	proto.RegisterType((*EditMessageMedia)(nil), "botproto.editMessageMedia")
	proto.RegisterType((*EditMessageReplyMarkup)(nil), "botproto.editMessageReplyMarkup")
	proto.RegisterType((*StopPoll)(nil), "botproto.stopPoll")
	proto.RegisterType((*DeleteMessage)(nil), "botproto.deleteMessage")
}
func (m *EditMessageText) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditMessageText) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.MessageId))
	}
	if len(m.InlineMessageId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.InlineMessageId)))
		i += copy(dAtA[i:], m.InlineMessageId)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.DisableWebPagePreview {
		dAtA[i] = 0x30
		i++
		if m.DisableWebPagePreview {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n1, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *EditMessageCaption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditMessageCaption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.MessageId))
	}
	if len(m.InlineMessageId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.InlineMessageId)))
		i += copy(dAtA[i:], m.InlineMessageId)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n2, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *EditMessageMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditMessageMedia) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.MessageId))
	}
	if len(m.InlineMessageId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.InlineMessageId)))
		i += copy(dAtA[i:], m.InlineMessageId)
	}
	if m.Media != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.Media.Size()))
		n3, err := m.Media.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n4, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *EditMessageReplyMarkup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditMessageReplyMarkup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.MessageId))
	}
	if len(m.InlineMessageId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.InlineMessageId)))
		i += copy(dAtA[i:], m.InlineMessageId)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n5, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *StopPoll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopPoll) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.MessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n6, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *DeleteMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUpdatingMessagesMethod(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func encodeFixed64UpdatingMessagesMethod(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32UpdatingMessagesMethod(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintUpdatingMessagesMethod(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EditMessageText) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovUpdatingMessagesMethod(uint64(m.MessageId))
	}
	l = len(m.InlineMessageId)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.DisableWebPagePreview {
		n += 2
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	return n
}

func (m *EditMessageCaption) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovUpdatingMessagesMethod(uint64(m.MessageId))
	}
	l = len(m.InlineMessageId)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	return n
}

func (m *EditMessageMedia) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovUpdatingMessagesMethod(uint64(m.MessageId))
	}
	l = len(m.InlineMessageId)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	return n
}

func (m *EditMessageReplyMarkup) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovUpdatingMessagesMethod(uint64(m.MessageId))
	}
	l = len(m.InlineMessageId)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	return n
}

func (m *StopPoll) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovUpdatingMessagesMethod(uint64(m.MessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	return n
}

func (m *DeleteMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovUpdatingMessagesMethod(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovUpdatingMessagesMethod(uint64(m.MessageId))
	}
	return n
}

func sovUpdatingMessagesMethod(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozUpdatingMessagesMethod(x uint64) (n int) {
	return sovUpdatingMessagesMethod(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EditMessageText) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdatingMessagesMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: editMessageText: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: editMessageText: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableWebPagePreview", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableWebPagePreview = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdatingMessagesMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditMessageCaption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdatingMessagesMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: editMessageCaption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: editMessageCaption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdatingMessagesMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditMessageMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdatingMessagesMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: editMessageMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: editMessageMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &InputMedia{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdatingMessagesMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditMessageReplyMarkup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdatingMessagesMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: editMessageReplyMarkup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: editMessageReplyMarkup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdatingMessagesMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopPoll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdatingMessagesMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: stopPoll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: stopPoll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUpdatingMessagesMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdatingMessagesMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: deleteMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: deleteMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdatingMessagesMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUpdatingMessagesMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUpdatingMessagesMethod(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUpdatingMessagesMethod
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpdatingMessagesMethod
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthUpdatingMessagesMethod
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowUpdatingMessagesMethod
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipUpdatingMessagesMethod(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthUpdatingMessagesMethod = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUpdatingMessagesMethod   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("updating_messages.method.proto", fileDescriptorUpdatingMessagesMethod)
}

var fileDescriptorUpdatingMessagesMethod = []byte{
	// 414 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x90, 0xcf, 0xaa, 0xd3, 0x40,
	0x14, 0xc6, 0x99, 0x7b, 0x9b, 0xb4, 0x3d, 0xbd, 0x5a, 0x1d, 0xfc, 0x13, 0x04, 0x43, 0xe8, 0x2a,
	0x74, 0x91, 0x45, 0x5d, 0xb8, 0x56, 0x17, 0x52, 0x24, 0x50, 0x82, 0xe0, 0x32, 0x4c, 0x3a, 0x87,
	0x74, 0x30, 0xc9, 0x0c, 0xc9, 0xd4, 0xb6, 0x0f, 0xe0, 0x9b, 0xf8, 0x1e, 0x6e, 0x5d, 0xfa, 0x08,
	0x52, 0xf0, 0x0d, 0x7c, 0x00, 0xc9, 0x24, 0xd5, 0x50, 0x17, 0x92, 0x2e, 0xba, 0x9b, 0x33, 0xdf,
	0xf9, 0xf3, 0xfd, 0x3e, 0x70, 0xb7, 0x8a, 0x33, 0x2d, 0x8a, 0x34, 0xce, 0xb1, 0xaa, 0x58, 0x8a,
	0x55, 0x90, 0xa3, 0xde, 0x48, 0x1e, 0xa8, 0x52, 0x6a, 0x49, 0x47, 0x89, 0xd4, 0xe6, 0xf5, 0xec,
	0xbe, 0x4e, 0x13, 0xa9, 0x99, 0x12, 0x8d, 0x32, 0xfb, 0x72, 0x03, 0x53, 0xe4, 0x42, 0x87, 0xcd,
	0xdc, 0x7b, 0xdc, 0x6b, 0xfa, 0x14, 0x86, 0xeb, 0x0d, 0xd3, 0xb1, 0xe0, 0x0e, 0xf1, 0x88, 0x3f,
	0x8e, 0xec, 0xba, 0x5c, 0x72, 0xfa, 0x1c, 0xa0, 0xdd, 0x5f, 0x6b, 0x37, 0x1e, 0xf1, 0xad, 0x68,
	0xdc, 0xfe, 0x2c, 0x39, 0x9d, 0xc3, 0x43, 0x51, 0x64, 0xa2, 0xc0, 0xb8, 0xd3, 0x75, 0x6b, 0x36,
	0x4c, 0x1b, 0x21, 0xfc, 0xd3, 0x4b, 0x61, 0xa0, 0x71, 0xaf, 0x9d, 0x81, 0x91, 0xcd, 0xbb, 0x5e,
	0xaf, 0x58, 0x59, 0x61, 0x9c, 0x4b, 0x8e, 0x8e, 0x65, 0x94, 0xb1, 0xf9, 0x09, 0x25, 0x47, 0xfa,
	0x12, 0x1c, 0x2e, 0x2a, 0x96, 0x64, 0x18, 0xef, 0x30, 0x89, 0x55, 0x7d, 0x40, 0x95, 0xf8, 0x49,
	0xe0, 0xce, 0xb1, 0x3d, 0xe2, 0x8f, 0xa2, 0xc7, 0xad, 0xfe, 0x01, 0x93, 0x15, 0x4b, 0x71, 0xd5,
	0x88, 0xf4, 0x15, 0xdc, 0x95, 0xa8, 0xb2, 0x43, 0x9c, 0xb3, 0xf2, 0xe3, 0x56, 0x39, 0x43, 0x8f,
	0xf8, 0x93, 0x85, 0x1b, 0x9c, 0x42, 0x09, 0x96, 0xc6, 0xdc, 0x3b, 0x3c, 0x24, 0x92, 0x95, 0x3c,
	0x34, 0x5d, 0xd1, 0xc4, 0xcc, 0x34, 0xc5, 0xec, 0x17, 0x01, 0xda, 0x89, 0xe9, 0x0d, 0x53, 0x5a,
	0xc8, 0xe2, 0x2a, 0x49, 0x39, 0x30, 0x5c, 0x37, 0xe7, 0xda, 0xb0, 0x4e, 0xe5, 0xff, 0xf2, 0x3a,
	0xc7, 0xb6, 0xfb, 0x63, 0xff, 0x24, 0xf0, 0xa0, 0x83, 0x1d, 0x22, 0x17, 0xec, 0x2a, 0xd0, 0x73,
	0xb0, 0xf2, 0xfa, 0x98, 0x41, 0x9e, 0x2c, 0x1e, 0x75, 0x4d, 0xab, 0xad, 0x36, 0x46, 0xa2, 0xa6,
	0xe5, 0x1f, 0x4e, 0xab, 0x3f, 0xe7, 0x57, 0x02, 0x4f, 0x3a, 0x9c, 0xd1, 0x5f, 0xe9, 0x2a, 0xb4,
	0xe7, 0x04, 0x83, 0xfe, 0x04, 0x9f, 0x09, 0x8c, 0x2a, 0x2d, 0xd5, 0x4a, 0x66, 0xd9, 0xc5, 0x9e,
	0xcf, 0x7d, 0xdc, 0xf6, 0xf7, 0xf1, 0x16, 0xee, 0x71, 0xcc, 0x50, 0x9f, 0xe8, 0x2e, 0xf5, 0xf2,
	0xfa, 0xee, 0xdb, 0xd1, 0x25, 0xdf, 0x8f, 0x2e, 0xf9, 0x71, 0x74, 0x49, 0x62, 0x9b, 0xfb, 0x2f,
	0x7e, 0x07, 0x00, 0x00, 0xff, 0xff, 0x51, 0x1e, 0xf3, 0x11, 0xe9, 0x04, 0x00, 0x00,
}
