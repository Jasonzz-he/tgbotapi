// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tgbotapi.proto

package botproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This object represents a Telegram user or bot.
type User struct {
	Id           int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	IsBot        bool   `protobuf:"varint,2,opt,name=is_bot,json=isBot,proto3" json:"is_bot,omitempty"`
	FirstName    string `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName     string `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	Username     string `protobuf:"bytes,5,opt,name=username,proto3" json:"username,omitempty"`
	LanguageCode string `protobuf:"bytes,6,opt,name=language_code,json=languageCode,proto3" json:"language_code,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{0} }

func (m *User) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *User) GetIsBot() bool {
	if m != nil {
		return m.IsBot
	}
	return false
}

func (m *User) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *User) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *User) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

// This object represents a chat.
type Chat struct {
	Id               int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type             string           `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Title            string           `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Username         string           `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	FirstName        string           `protobuf:"bytes,5,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName         string           `protobuf:"bytes,6,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	Photo            *ChatPhoto       `protobuf:"bytes,7,opt,name=photo" json:"photo,omitempty"`
	Description      string           `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	InviteLink       string           `protobuf:"bytes,9,opt,name=invite_link,json=inviteLink,proto3" json:"invite_link,omitempty"`
	PinnedMessage    *Message         `protobuf:"bytes,10,opt,name=pinned_message,json=pinnedMessage" json:"pinned_message,omitempty"`
	Permissions      *ChatPermissions `protobuf:"bytes,11,opt,name=permissions" json:"permissions,omitempty"`
	StickerSetName   string           `protobuf:"bytes,12,opt,name=sticker_set_name,json=stickerSetName,proto3" json:"sticker_set_name,omitempty"`
	CanSetStickerSet bool             `protobuf:"varint,13,opt,name=can_set_sticker_set,json=canSetStickerSet,proto3" json:"can_set_sticker_set,omitempty"`
}

func (m *Chat) Reset()                    { *m = Chat{} }
func (m *Chat) String() string            { return proto.CompactTextString(m) }
func (*Chat) ProtoMessage()               {}
func (*Chat) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{1} }

func (m *Chat) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Chat) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Chat) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Chat) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Chat) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *Chat) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *Chat) GetPhoto() *ChatPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *Chat) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Chat) GetInviteLink() string {
	if m != nil {
		return m.InviteLink
	}
	return ""
}

func (m *Chat) GetPinnedMessage() *Message {
	if m != nil {
		return m.PinnedMessage
	}
	return nil
}

func (m *Chat) GetPermissions() *ChatPermissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Chat) GetStickerSetName() string {
	if m != nil {
		return m.StickerSetName
	}
	return ""
}

func (m *Chat) GetCanSetStickerSet() bool {
	if m != nil {
		return m.CanSetStickerSet
	}
	return false
}

// This object represents a message.
type Message struct {
	MessageId             int32                 `protobuf:"varint,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	From                  *User                 `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	Date                  int32                 `protobuf:"varint,3,opt,name=date,proto3" json:"date,omitempty"`
	Chat                  *Chat                 `protobuf:"bytes,4,opt,name=chat" json:"chat,omitempty"`
	ForwardFrom           *User                 `protobuf:"bytes,5,opt,name=forward_from,json=forwardFrom" json:"forward_from,omitempty"`
	ForwardFromChat       *Chat                 `protobuf:"bytes,6,opt,name=forward_from_chat,json=forwardFromChat" json:"forward_from_chat,omitempty"`
	ForwardFromMessageId  int32                 `protobuf:"varint,7,opt,name=forward_from_message_id,json=forwardFromMessageId,proto3" json:"forward_from_message_id,omitempty"`
	ForwardSignature      string                `protobuf:"bytes,8,opt,name=forward_signature,json=forwardSignature,proto3" json:"forward_signature,omitempty"`
	ForwardSenderName     string                `protobuf:"bytes,9,opt,name=forward_sender_name,json=forwardSenderName,proto3" json:"forward_sender_name,omitempty"`
	ForwardDate           int32                 `protobuf:"varint,10,opt,name=forward_date,json=forwardDate,proto3" json:"forward_date,omitempty"`
	ReplyToMessage        *Message              `protobuf:"bytes,11,opt,name=reply_to_message,json=replyToMessage" json:"reply_to_message,omitempty"`
	EditDate              int32                 `protobuf:"varint,12,opt,name=edit_date,json=editDate,proto3" json:"edit_date,omitempty"`
	MediaGroupId          string                `protobuf:"bytes,13,opt,name=media_group_id,json=mediaGroupId,proto3" json:"media_group_id,omitempty"`
	AuthorSignature       string                `protobuf:"bytes,14,opt,name=author_signature,json=authorSignature,proto3" json:"author_signature,omitempty"`
	Text                  string                `protobuf:"bytes,15,opt,name=text,proto3" json:"text,omitempty"`
	Entities              []*MessageEntity      `protobuf:"bytes,16,rep,name=entities" json:"entities,omitempty"`
	CaptionEntities       []*MessageEntity      `protobuf:"bytes,17,rep,name=caption_entities,json=captionEntities" json:"caption_entities,omitempty"`
	Audio                 *Audio                `protobuf:"bytes,18,opt,name=audio" json:"audio,omitempty"`
	Document              *Document             `protobuf:"bytes,19,opt,name=document" json:"document,omitempty"`
	Animation             *Animation            `protobuf:"bytes,20,opt,name=animation" json:"animation,omitempty"`
	Game                  *Game                 `protobuf:"bytes,21,opt,name=game" json:"game,omitempty"`
	Photo                 []*PhotoSize          `protobuf:"bytes,22,rep,name=photo" json:"photo,omitempty"`
	Sticker               *Sticker              `protobuf:"bytes,23,opt,name=sticker" json:"sticker,omitempty"`
	Video                 *Video                `protobuf:"bytes,24,opt,name=video" json:"video,omitempty"`
	Voice                 *Voice                `protobuf:"bytes,25,opt,name=voice" json:"voice,omitempty"`
	VideoNote             *VideoNote            `protobuf:"bytes,26,opt,name=video_note,json=videoNote" json:"video_note,omitempty"`
	Caption               string                `protobuf:"bytes,27,opt,name=caption,proto3" json:"caption,omitempty"`
	Contact               *Contact              `protobuf:"bytes,28,opt,name=contact" json:"contact,omitempty"`
	Location              *Location             `protobuf:"bytes,29,opt,name=location" json:"location,omitempty"`
	Venue                 *Venue                `protobuf:"bytes,30,opt,name=venue" json:"venue,omitempty"`
	Poll                  *Poll                 `protobuf:"bytes,31,opt,name=poll" json:"poll,omitempty"`
	NewChatMembers        []*User               `protobuf:"bytes,32,rep,name=new_chat_members,json=newChatMembers" json:"new_chat_members,omitempty"`
	LeftChatMember        *User                 `protobuf:"bytes,33,opt,name=left_chat_member,json=leftChatMember" json:"left_chat_member,omitempty"`
	NewChatTitle          string                `protobuf:"bytes,34,opt,name=new_chat_title,json=newChatTitle,proto3" json:"new_chat_title,omitempty"`
	NewChatPhoto          []*PhotoSize          `protobuf:"bytes,35,rep,name=new_chat_photo,json=newChatPhoto" json:"new_chat_photo,omitempty"`
	DeleteChatPhoto       bool                  `protobuf:"varint,36,opt,name=delete_chat_photo,json=deleteChatPhoto,proto3" json:"delete_chat_photo,omitempty"`
	GroupChatCreated      bool                  `protobuf:"varint,37,opt,name=group_chat_created,json=groupChatCreated,proto3" json:"group_chat_created,omitempty"`
	SupergroupChatCreated bool                  `protobuf:"varint,38,opt,name=supergroup_chat_created,json=supergroupChatCreated,proto3" json:"supergroup_chat_created,omitempty"`
	ChannelChatCreated    bool                  `protobuf:"varint,39,opt,name=channel_chat_created,json=channelChatCreated,proto3" json:"channel_chat_created,omitempty"`
	MigrateToChatId       int32                 `protobuf:"varint,40,opt,name=migrate_to_chat_id,json=migrateToChatId,proto3" json:"migrate_to_chat_id,omitempty"`
	MigrateFromChatId     int32                 `protobuf:"varint,41,opt,name=migrate_from_chat_id,json=migrateFromChatId,proto3" json:"migrate_from_chat_id,omitempty"`
	PinnedMessage         *Message              `protobuf:"bytes,42,opt,name=pinned_message,json=pinnedMessage" json:"pinned_message,omitempty"`
	Invoice               *Invoice              `protobuf:"bytes,43,opt,name=invoice" json:"invoice,omitempty"`
	SuccessfulPayment     *SuccessfulPayment    `protobuf:"bytes,44,opt,name=successful_payment,json=successfulPayment" json:"successful_payment,omitempty"`
	ConnectedWebsite      string                `protobuf:"bytes,45,opt,name=connected_website,json=connectedWebsite,proto3" json:"connected_website,omitempty"`
	PassportData          *PassportData         `protobuf:"bytes,46,opt,name=passport_data,json=passportData" json:"passport_data,omitempty"`
	ReplyMarkup           *InlineKeyboardMarkup `protobuf:"bytes,47,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{2} }

func (m *Message) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *Message) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Message) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *Message) GetChat() *Chat {
	if m != nil {
		return m.Chat
	}
	return nil
}

func (m *Message) GetForwardFrom() *User {
	if m != nil {
		return m.ForwardFrom
	}
	return nil
}

func (m *Message) GetForwardFromChat() *Chat {
	if m != nil {
		return m.ForwardFromChat
	}
	return nil
}

func (m *Message) GetForwardFromMessageId() int32 {
	if m != nil {
		return m.ForwardFromMessageId
	}
	return 0
}

func (m *Message) GetForwardSignature() string {
	if m != nil {
		return m.ForwardSignature
	}
	return ""
}

func (m *Message) GetForwardSenderName() string {
	if m != nil {
		return m.ForwardSenderName
	}
	return ""
}

func (m *Message) GetForwardDate() int32 {
	if m != nil {
		return m.ForwardDate
	}
	return 0
}

func (m *Message) GetReplyToMessage() *Message {
	if m != nil {
		return m.ReplyToMessage
	}
	return nil
}

func (m *Message) GetEditDate() int32 {
	if m != nil {
		return m.EditDate
	}
	return 0
}

func (m *Message) GetMediaGroupId() string {
	if m != nil {
		return m.MediaGroupId
	}
	return ""
}

func (m *Message) GetAuthorSignature() string {
	if m != nil {
		return m.AuthorSignature
	}
	return ""
}

func (m *Message) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Message) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *Message) GetCaptionEntities() []*MessageEntity {
	if m != nil {
		return m.CaptionEntities
	}
	return nil
}

func (m *Message) GetAudio() *Audio {
	if m != nil {
		return m.Audio
	}
	return nil
}

func (m *Message) GetDocument() *Document {
	if m != nil {
		return m.Document
	}
	return nil
}

func (m *Message) GetAnimation() *Animation {
	if m != nil {
		return m.Animation
	}
	return nil
}

func (m *Message) GetGame() *Game {
	if m != nil {
		return m.Game
	}
	return nil
}

func (m *Message) GetPhoto() []*PhotoSize {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *Message) GetSticker() *Sticker {
	if m != nil {
		return m.Sticker
	}
	return nil
}

func (m *Message) GetVideo() *Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *Message) GetVoice() *Voice {
	if m != nil {
		return m.Voice
	}
	return nil
}

func (m *Message) GetVideoNote() *VideoNote {
	if m != nil {
		return m.VideoNote
	}
	return nil
}

func (m *Message) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *Message) GetContact() *Contact {
	if m != nil {
		return m.Contact
	}
	return nil
}

func (m *Message) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Message) GetVenue() *Venue {
	if m != nil {
		return m.Venue
	}
	return nil
}

func (m *Message) GetPoll() *Poll {
	if m != nil {
		return m.Poll
	}
	return nil
}

func (m *Message) GetNewChatMembers() []*User {
	if m != nil {
		return m.NewChatMembers
	}
	return nil
}

func (m *Message) GetLeftChatMember() *User {
	if m != nil {
		return m.LeftChatMember
	}
	return nil
}

func (m *Message) GetNewChatTitle() string {
	if m != nil {
		return m.NewChatTitle
	}
	return ""
}

func (m *Message) GetNewChatPhoto() []*PhotoSize {
	if m != nil {
		return m.NewChatPhoto
	}
	return nil
}

func (m *Message) GetDeleteChatPhoto() bool {
	if m != nil {
		return m.DeleteChatPhoto
	}
	return false
}

func (m *Message) GetGroupChatCreated() bool {
	if m != nil {
		return m.GroupChatCreated
	}
	return false
}

func (m *Message) GetSupergroupChatCreated() bool {
	if m != nil {
		return m.SupergroupChatCreated
	}
	return false
}

func (m *Message) GetChannelChatCreated() bool {
	if m != nil {
		return m.ChannelChatCreated
	}
	return false
}

func (m *Message) GetMigrateToChatId() int32 {
	if m != nil {
		return m.MigrateToChatId
	}
	return 0
}

func (m *Message) GetMigrateFromChatId() int32 {
	if m != nil {
		return m.MigrateFromChatId
	}
	return 0
}

func (m *Message) GetPinnedMessage() *Message {
	if m != nil {
		return m.PinnedMessage
	}
	return nil
}

func (m *Message) GetInvoice() *Invoice {
	if m != nil {
		return m.Invoice
	}
	return nil
}

func (m *Message) GetSuccessfulPayment() *SuccessfulPayment {
	if m != nil {
		return m.SuccessfulPayment
	}
	return nil
}

func (m *Message) GetConnectedWebsite() string {
	if m != nil {
		return m.ConnectedWebsite
	}
	return ""
}

func (m *Message) GetPassportData() *PassportData {
	if m != nil {
		return m.PassportData
	}
	return nil
}

func (m *Message) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// This object represents one special entity in a text message. For example, hashtags, usernames, URLs, etc.
type MessageEntity struct {
	Type   string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Offset int32  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Length int32  `protobuf:"varint,3,opt,name=length,proto3" json:"length,omitempty"`
	Url    string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	User   *User  `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
}

func (m *MessageEntity) Reset()                    { *m = MessageEntity{} }
func (m *MessageEntity) String() string            { return proto.CompactTextString(m) }
func (*MessageEntity) ProtoMessage()               {}
func (*MessageEntity) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{3} }

func (m *MessageEntity) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MessageEntity) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *MessageEntity) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *MessageEntity) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *MessageEntity) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

// This object represents one size of a photo or a file / sticker thumbnail.
type PhotoSize struct {
	FileId   string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Width    int32  `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height   int32  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	FileSize int32  `protobuf:"varint,4,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *PhotoSize) Reset()                    { *m = PhotoSize{} }
func (m *PhotoSize) String() string            { return proto.CompactTextString(m) }
func (*PhotoSize) ProtoMessage()               {}
func (*PhotoSize) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{4} }

func (m *PhotoSize) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *PhotoSize) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *PhotoSize) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *PhotoSize) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents an audio file to be treated as music by the Telegram clients.
type Audio struct {
	FileId    string     `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Duration  int32      `protobuf:"varint,2,opt,name=duration,proto3" json:"duration,omitempty"`
	Performer string     `protobuf:"bytes,3,opt,name=performer,proto3" json:"performer,omitempty"`
	Title     string     `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	MimeType  string     `protobuf:"bytes,5,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize  int32      `protobuf:"varint,6,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	Thumb     *PhotoSize `protobuf:"bytes,7,opt,name=thumb" json:"thumb,omitempty"`
}

func (m *Audio) Reset()                    { *m = Audio{} }
func (m *Audio) String() string            { return proto.CompactTextString(m) }
func (*Audio) ProtoMessage()               {}
func (*Audio) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{5} }

func (m *Audio) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Audio) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Audio) GetPerformer() string {
	if m != nil {
		return m.Performer
	}
	return ""
}

func (m *Audio) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Audio) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Audio) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *Audio) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

// This object represents a general file (as opposed to photos, voice messages and audio files).
type Document struct {
	FileId   string     `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Thumb    *PhotoSize `protobuf:"bytes,2,opt,name=thumb" json:"thumb,omitempty"`
	FileName string     `protobuf:"bytes,3,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	MimeType string     `protobuf:"bytes,4,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize int32      `protobuf:"varint,5,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *Document) Reset()                    { *m = Document{} }
func (m *Document) String() string            { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()               {}
func (*Document) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{6} }

func (m *Document) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Document) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *Document) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Document) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Document) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents a video file.
type Video struct {
	FileId   string     `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Width    int32      `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height   int32      `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	Duration int32      `protobuf:"varint,4,opt,name=duration,proto3" json:"duration,omitempty"`
	Thumb    *PhotoSize `protobuf:"bytes,5,opt,name=thumb" json:"thumb,omitempty"`
	MimeType string     `protobuf:"bytes,6,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize int32      `protobuf:"varint,7,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *Video) Reset()                    { *m = Video{} }
func (m *Video) String() string            { return proto.CompactTextString(m) }
func (*Video) ProtoMessage()               {}
func (*Video) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{7} }

func (m *Video) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Video) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Video) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Video) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Video) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *Video) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Video) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).
type Animation struct {
	FileId   string     `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Width    int32      `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height   int32      `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	Duration int32      `protobuf:"varint,4,opt,name=duration,proto3" json:"duration,omitempty"`
	Thumb    *PhotoSize `protobuf:"bytes,5,opt,name=thumb" json:"thumb,omitempty"`
	FileName string     `protobuf:"bytes,6,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	MimeType string     `protobuf:"bytes,7,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize int32      `protobuf:"varint,8,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *Animation) Reset()                    { *m = Animation{} }
func (m *Animation) String() string            { return proto.CompactTextString(m) }
func (*Animation) ProtoMessage()               {}
func (*Animation) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{8} }

func (m *Animation) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Animation) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Animation) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Animation) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Animation) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *Animation) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Animation) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Animation) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents a voice note.
type Voice struct {
	FileId   string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Duration int32  `protobuf:"varint,2,opt,name=duration,proto3" json:"duration,omitempty"`
	MimeType string `protobuf:"bytes,3,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize int32  `protobuf:"varint,4,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *Voice) Reset()                    { *m = Voice{} }
func (m *Voice) String() string            { return proto.CompactTextString(m) }
func (*Voice) ProtoMessage()               {}
func (*Voice) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{9} }

func (m *Voice) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Voice) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Voice) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Voice) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents a video message (available in Telegram apps as of v.4.0).
type VideoNote struct {
	FileId   string     `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Length   int32      `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	Duration int32      `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
	Thumb    *PhotoSize `protobuf:"bytes,4,opt,name=thumb" json:"thumb,omitempty"`
	FileSize int32      `protobuf:"varint,5,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *VideoNote) Reset()                    { *m = VideoNote{} }
func (m *VideoNote) String() string            { return proto.CompactTextString(m) }
func (*VideoNote) ProtoMessage()               {}
func (*VideoNote) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{10} }

func (m *VideoNote) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *VideoNote) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *VideoNote) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *VideoNote) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *VideoNote) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents a phone contact.
type Contact struct {
	PhoneNumber string `protobuf:"bytes,1,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	FirstName   string `protobuf:"bytes,2,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName    string `protobuf:"bytes,3,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	UserId      int32  `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Vcard       string `protobuf:"bytes,5,opt,name=vcard,proto3" json:"vcard,omitempty"`
}

func (m *Contact) Reset()                    { *m = Contact{} }
func (m *Contact) String() string            { return proto.CompactTextString(m) }
func (*Contact) ProtoMessage()               {}
func (*Contact) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{11} }

func (m *Contact) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *Contact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *Contact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *Contact) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Contact) GetVcard() string {
	if m != nil {
		return m.Vcard
	}
	return ""
}

// This object represents a point on the map.
type Location struct {
	Longitude int64 `protobuf:"varint,1,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Latitude  int64 `protobuf:"varint,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{12} }

func (m *Location) GetLongitude() int64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *Location) GetLatitude() int64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

// This object represents a venue.
type Venue struct {
	Location       *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Title          string    `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Address        string    `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	FoursquareId   string    `protobuf:"bytes,4,opt,name=foursquare_id,json=foursquareId,proto3" json:"foursquare_id,omitempty"`
	FoursquareType string    `protobuf:"bytes,5,opt,name=foursquare_type,json=foursquareType,proto3" json:"foursquare_type,omitempty"`
}

func (m *Venue) Reset()                    { *m = Venue{} }
func (m *Venue) String() string            { return proto.CompactTextString(m) }
func (*Venue) ProtoMessage()               {}
func (*Venue) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{13} }

func (m *Venue) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Venue) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Venue) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Venue) GetFoursquareId() string {
	if m != nil {
		return m.FoursquareId
	}
	return ""
}

func (m *Venue) GetFoursquareType() string {
	if m != nil {
		return m.FoursquareType
	}
	return ""
}

// This object contains information about one answer option in a poll.
type PollOption struct {
	Text       string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	VoterCount int32  `protobuf:"varint,2,opt,name=voter_count,json=voterCount,proto3" json:"voter_count,omitempty"`
}

func (m *PollOption) Reset()                    { *m = PollOption{} }
func (m *PollOption) String() string            { return proto.CompactTextString(m) }
func (*PollOption) ProtoMessage()               {}
func (*PollOption) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{14} }

func (m *PollOption) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *PollOption) GetVoterCount() int32 {
	if m != nil {
		return m.VoterCount
	}
	return 0
}

// This object contains information about a poll.
type Poll struct {
	Id       string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Question string        `protobuf:"bytes,2,opt,name=question,proto3" json:"question,omitempty"`
	Options  []*PollOption `protobuf:"bytes,3,rep,name=options" json:"options,omitempty"`
	IsClosed bool          `protobuf:"varint,4,opt,name=is_closed,json=isClosed,proto3" json:"is_closed,omitempty"`
}

func (m *Poll) Reset()                    { *m = Poll{} }
func (m *Poll) String() string            { return proto.CompactTextString(m) }
func (*Poll) ProtoMessage()               {}
func (*Poll) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{15} }

func (m *Poll) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Poll) GetQuestion() string {
	if m != nil {
		return m.Question
	}
	return ""
}

func (m *Poll) GetOptions() []*PollOption {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Poll) GetIsClosed() bool {
	if m != nil {
		return m.IsClosed
	}
	return false
}

// This object represent a user's profile pictures.
type UserProfilePhotos struct {
	TotalCount int32        `protobuf:"varint,1,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	Photos     []*PhotoSize `protobuf:"bytes,2,rep,name=photos" json:"photos,omitempty"`
}

func (m *UserProfilePhotos) Reset()                    { *m = UserProfilePhotos{} }
func (m *UserProfilePhotos) String() string            { return proto.CompactTextString(m) }
func (*UserProfilePhotos) ProtoMessage()               {}
func (*UserProfilePhotos) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{16} }

func (m *UserProfilePhotos) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *UserProfilePhotos) GetPhotos() []*PhotoSize {
	if m != nil {
		return m.Photos
	}
	return nil
}

// This object represents a file ready to be downloaded. The file can be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile.
// Maximum file size to download is 20 MB
//
type File struct {
	FileId   string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	FileSize int32  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	FilePath string `protobuf:"bytes,3,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{17} }

func (m *File) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *File) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *File) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

// This object represents a custom keyboard with reply options (see Introduction to bots for details and examples).
type ReplyKeyboardMarkup struct {
	Keyboard        []*KeyboardButton `protobuf:"bytes,1,rep,name=keyboard" json:"keyboard,omitempty"`
	ResizeKeyboard  bool              `protobuf:"varint,2,opt,name=resize_keyboard,json=resizeKeyboard,proto3" json:"resize_keyboard,omitempty"`
	OneTimeKeyboard bool              `protobuf:"varint,3,opt,name=one_time_keyboard,json=oneTimeKeyboard,proto3" json:"one_time_keyboard,omitempty"`
	Selective       bool              `protobuf:"varint,4,opt,name=selective,proto3" json:"selective,omitempty"`
}

func (m *ReplyKeyboardMarkup) Reset()                    { *m = ReplyKeyboardMarkup{} }
func (m *ReplyKeyboardMarkup) String() string            { return proto.CompactTextString(m) }
func (*ReplyKeyboardMarkup) ProtoMessage()               {}
func (*ReplyKeyboardMarkup) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{18} }

func (m *ReplyKeyboardMarkup) GetKeyboard() []*KeyboardButton {
	if m != nil {
		return m.Keyboard
	}
	return nil
}

func (m *ReplyKeyboardMarkup) GetResizeKeyboard() bool {
	if m != nil {
		return m.ResizeKeyboard
	}
	return false
}

func (m *ReplyKeyboardMarkup) GetOneTimeKeyboard() bool {
	if m != nil {
		return m.OneTimeKeyboard
	}
	return false
}

func (m *ReplyKeyboardMarkup) GetSelective() bool {
	if m != nil {
		return m.Selective
	}
	return false
}

// This object represents one button of the reply keyboard. For simple text buttons String can be used instead of this object to specify text of the button. Optional fields are mutually exclusive.
// Note: request_contact and request_location options will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type KeyboardButton struct {
	Text            string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	RequestContact  bool   `protobuf:"varint,2,opt,name=request_contact,json=requestContact,proto3" json:"request_contact,omitempty"`
	RequestLocation bool   `protobuf:"varint,3,opt,name=request_location,json=requestLocation,proto3" json:"request_location,omitempty"`
}

func (m *KeyboardButton) Reset()                    { *m = KeyboardButton{} }
func (m *KeyboardButton) String() string            { return proto.CompactTextString(m) }
func (*KeyboardButton) ProtoMessage()               {}
func (*KeyboardButton) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{19} }

func (m *KeyboardButton) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *KeyboardButton) GetRequestContact() bool {
	if m != nil {
		return m.RequestContact
	}
	return false
}

func (m *KeyboardButton) GetRequestLocation() bool {
	if m != nil {
		return m.RequestLocation
	}
	return false
}

// Upon receiving a message with this object, Telegram clients will remove the current custom keyboard and display the default letter-keyboard. By default, custom keyboards are displayed until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are hidden immediately after the user presses a button (see ReplyKeyboardMarkup).
type ReplyKeyboardRemove struct {
	RemoveKeyboard bool `protobuf:"varint,1,opt,name=remove_keyboard,json=removeKeyboard,proto3" json:"remove_keyboard,omitempty"`
	Selective      bool `protobuf:"varint,2,opt,name=selective,proto3" json:"selective,omitempty"`
}

func (m *ReplyKeyboardRemove) Reset()                    { *m = ReplyKeyboardRemove{} }
func (m *ReplyKeyboardRemove) String() string            { return proto.CompactTextString(m) }
func (*ReplyKeyboardRemove) ProtoMessage()               {}
func (*ReplyKeyboardRemove) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{20} }

func (m *ReplyKeyboardRemove) GetRemoveKeyboard() bool {
	if m != nil {
		return m.RemoveKeyboard
	}
	return false
}

func (m *ReplyKeyboardRemove) GetSelective() bool {
	if m != nil {
		return m.Selective
	}
	return false
}

// This object represents an inline keyboard that appears right next to the message it belongs to.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will display unsupported message.
type InlineKeyboardMarkup struct {
	InlineKeyboard []*InlineKeyboardButton `protobuf:"bytes,1,rep,name=inline_keyboard,json=inlineKeyboard" json:"inline_keyboard,omitempty"`
}

func (m *InlineKeyboardMarkup) Reset()                    { *m = InlineKeyboardMarkup{} }
func (m *InlineKeyboardMarkup) String() string            { return proto.CompactTextString(m) }
func (*InlineKeyboardMarkup) ProtoMessage()               {}
func (*InlineKeyboardMarkup) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{21} }

func (m *InlineKeyboardMarkup) GetInlineKeyboard() []*InlineKeyboardButton {
	if m != nil {
		return m.InlineKeyboard
	}
	return nil
}

// This object represents one button of an inline keyboard. You must use exactly one of the optional fields.
type InlineKeyboardButton struct {
	Text                         string        `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Url                          string        `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	LoginUrl                     *LoginUrl     `protobuf:"bytes,3,opt,name=login_url,json=loginUrl" json:"login_url,omitempty"`
	CallbackData                 string        `protobuf:"bytes,4,opt,name=callback_data,json=callbackData,proto3" json:"callback_data,omitempty"`
	SwitchInlineQuery            string        `protobuf:"bytes,5,opt,name=switch_inline_query,json=switchInlineQuery,proto3" json:"switch_inline_query,omitempty"`
	SwitchInlineQueryCurrentChat string        `protobuf:"bytes,6,opt,name=switch_inline_query_current_chat,json=switchInlineQueryCurrentChat,proto3" json:"switch_inline_query_current_chat,omitempty"`
	CallbackGame                 *CallbackGame `protobuf:"bytes,7,opt,name=callback_game,json=callbackGame" json:"callback_game,omitempty"`
	Pay                          bool          `protobuf:"varint,8,opt,name=pay,proto3" json:"pay,omitempty"`
}

func (m *InlineKeyboardButton) Reset()                    { *m = InlineKeyboardButton{} }
func (m *InlineKeyboardButton) String() string            { return proto.CompactTextString(m) }
func (*InlineKeyboardButton) ProtoMessage()               {}
func (*InlineKeyboardButton) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{22} }

func (m *InlineKeyboardButton) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *InlineKeyboardButton) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *InlineKeyboardButton) GetLoginUrl() *LoginUrl {
	if m != nil {
		return m.LoginUrl
	}
	return nil
}

func (m *InlineKeyboardButton) GetCallbackData() string {
	if m != nil {
		return m.CallbackData
	}
	return ""
}

func (m *InlineKeyboardButton) GetSwitchInlineQuery() string {
	if m != nil {
		return m.SwitchInlineQuery
	}
	return ""
}

func (m *InlineKeyboardButton) GetSwitchInlineQueryCurrentChat() string {
	if m != nil {
		return m.SwitchInlineQueryCurrentChat
	}
	return ""
}

func (m *InlineKeyboardButton) GetCallbackGame() *CallbackGame {
	if m != nil {
		return m.CallbackGame
	}
	return nil
}

func (m *InlineKeyboardButton) GetPay() bool {
	if m != nil {
		return m.Pay
	}
	return false
}

// This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a great replacement for the Telegram Login Widget when the user is coming from Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:
// Telegram apps support these buttons as of version 5.7.
// Sample bot: @discussbot
//
type LoginUrl struct {
	Url                string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	ForwardText        string `protobuf:"bytes,2,opt,name=forward_text,json=forwardText,proto3" json:"forward_text,omitempty"`
	BotUsername        string `protobuf:"bytes,3,opt,name=bot_username,json=botUsername,proto3" json:"bot_username,omitempty"`
	RequestWriteAccess bool   `protobuf:"varint,4,opt,name=request_write_access,json=requestWriteAccess,proto3" json:"request_write_access,omitempty"`
}

func (m *LoginUrl) Reset()                    { *m = LoginUrl{} }
func (m *LoginUrl) String() string            { return proto.CompactTextString(m) }
func (*LoginUrl) ProtoMessage()               {}
func (*LoginUrl) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{23} }

func (m *LoginUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *LoginUrl) GetForwardText() string {
	if m != nil {
		return m.ForwardText
	}
	return ""
}

func (m *LoginUrl) GetBotUsername() string {
	if m != nil {
		return m.BotUsername
	}
	return ""
}

func (m *LoginUrl) GetRequestWriteAccess() bool {
	if m != nil {
		return m.RequestWriteAccess
	}
	return false
}

// This object represents an incoming callback query from a callback button in an inline keyboard. If the button that originated the query was attached to a message sent by the bot, the field message will be present. If the button was attached to a message sent via the bot (in inline mode), the field inline_message_id will be present. Exactly one of the fields data or game_short_name will be present.
// NOTE: After the user presses a callback button, Telegram clients will display a progress bar until you call answerCallbackQuery. It is, therefore, necessary to react by calling answerCallbackQuery even if no notification to the user is needed (e.g., without specifying any of the optional parameters).
//
type CallbackQuery struct {
	Id              string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	From            *User    `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	Message         *Message `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	InlineMessageId string   `protobuf:"bytes,4,opt,name=inline_message_id,json=inlineMessageId,proto3" json:"inline_message_id,omitempty"`
	ChatInstance    string   `protobuf:"bytes,5,opt,name=chat_instance,json=chatInstance,proto3" json:"chat_instance,omitempty"`
	Data            string   `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	GameShortName   string   `protobuf:"bytes,7,opt,name=game_short_name,json=gameShortName,proto3" json:"game_short_name,omitempty"`
}

func (m *CallbackQuery) Reset()                    { *m = CallbackQuery{} }
func (m *CallbackQuery) String() string            { return proto.CompactTextString(m) }
func (*CallbackQuery) ProtoMessage()               {}
func (*CallbackQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{24} }

func (m *CallbackQuery) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CallbackQuery) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *CallbackQuery) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *CallbackQuery) GetInlineMessageId() string {
	if m != nil {
		return m.InlineMessageId
	}
	return ""
}

func (m *CallbackQuery) GetChatInstance() string {
	if m != nil {
		return m.ChatInstance
	}
	return ""
}

func (m *CallbackQuery) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *CallbackQuery) GetGameShortName() string {
	if m != nil {
		return m.GameShortName
	}
	return ""
}

// Upon receiving a message with this object, Telegram clients will display a reply interface to the user (act as if the user has selected the bot‘s message and tapped ’Reply'). This can be extremely useful if you want to create user-friendly step-by-step interfaces without having to sacrifice privacy mode.
// Example: A poll bot for groups runs in privacy mode (only receives commands, replies to its messages and mentions). There could be two ways to create a new poll:
//
// Explain the user how to send a command with parameters (e.g. /newpoll question answer1 answer2). May be appealing for hardcore users but lacks modern day polish.
// Guide the user through a step-by-step process. ‘Please send me your question’, ‘Cool, now let’s add the first answer option‘, ’Great. Keep adding answer options, then send /done when you‘re ready’.
//
// The last option is definitely more attractive. And if you use ForceReply in your bot‘s questions, it will receive the user’s answers even if it only receives replies, commands and mentions — without any extra work for the user.
//
type ForceReply struct {
	ForceReply bool `protobuf:"varint,1,opt,name=force_reply,json=forceReply,proto3" json:"force_reply,omitempty"`
	Selective  bool `protobuf:"varint,2,opt,name=selective,proto3" json:"selective,omitempty"`
}

func (m *ForceReply) Reset()                    { *m = ForceReply{} }
func (m *ForceReply) String() string            { return proto.CompactTextString(m) }
func (*ForceReply) ProtoMessage()               {}
func (*ForceReply) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{25} }

func (m *ForceReply) GetForceReply() bool {
	if m != nil {
		return m.ForceReply
	}
	return false
}

func (m *ForceReply) GetSelective() bool {
	if m != nil {
		return m.Selective
	}
	return false
}

// This object represents a chat photo.
type ChatPhoto struct {
	SmallFileId string `protobuf:"bytes,1,opt,name=small_file_id,json=smallFileId,proto3" json:"small_file_id,omitempty"`
	BigFileId   string `protobuf:"bytes,2,opt,name=big_file_id,json=bigFileId,proto3" json:"big_file_id,omitempty"`
}

func (m *ChatPhoto) Reset()                    { *m = ChatPhoto{} }
func (m *ChatPhoto) String() string            { return proto.CompactTextString(m) }
func (*ChatPhoto) ProtoMessage()               {}
func (*ChatPhoto) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{26} }

func (m *ChatPhoto) GetSmallFileId() string {
	if m != nil {
		return m.SmallFileId
	}
	return ""
}

func (m *ChatPhoto) GetBigFileId() string {
	if m != nil {
		return m.BigFileId
	}
	return ""
}

// This object contains information about one member of a chat.
type ChatMember struct {
	User                  *User  `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	Status                string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	UntilDate             int32  `protobuf:"varint,3,opt,name=until_date,json=untilDate,proto3" json:"until_date,omitempty"`
	CanBeEdited           bool   `protobuf:"varint,4,opt,name=can_be_edited,json=canBeEdited,proto3" json:"can_be_edited,omitempty"`
	CanPostMessages       bool   `protobuf:"varint,5,opt,name=can_post_messages,json=canPostMessages,proto3" json:"can_post_messages,omitempty"`
	CanEditMessages       bool   `protobuf:"varint,6,opt,name=can_edit_messages,json=canEditMessages,proto3" json:"can_edit_messages,omitempty"`
	CanDeleteMessages     bool   `protobuf:"varint,7,opt,name=can_delete_messages,json=canDeleteMessages,proto3" json:"can_delete_messages,omitempty"`
	CanRestrictMembers    bool   `protobuf:"varint,8,opt,name=can_restrict_members,json=canRestrictMembers,proto3" json:"can_restrict_members,omitempty"`
	CanPromoteMembers     bool   `protobuf:"varint,9,opt,name=can_promote_members,json=canPromoteMembers,proto3" json:"can_promote_members,omitempty"`
	CanChangeInfo         bool   `protobuf:"varint,10,opt,name=can_change_info,json=canChangeInfo,proto3" json:"can_change_info,omitempty"`
	CanInviteUsers        bool   `protobuf:"varint,11,opt,name=can_invite_users,json=canInviteUsers,proto3" json:"can_invite_users,omitempty"`
	CanPinMessages        bool   `protobuf:"varint,12,opt,name=can_pin_messages,json=canPinMessages,proto3" json:"can_pin_messages,omitempty"`
	IsMember              bool   `protobuf:"varint,13,opt,name=is_member,json=isMember,proto3" json:"is_member,omitempty"`
	CanSendMessages       bool   `protobuf:"varint,14,opt,name=can_send_messages,json=canSendMessages,proto3" json:"can_send_messages,omitempty"`
	CanSendMediaMessages  bool   `protobuf:"varint,15,opt,name=can_send_media_messages,json=canSendMediaMessages,proto3" json:"can_send_media_messages,omitempty"`
	CanSendPolls          bool   `protobuf:"varint,16,opt,name=can_send_polls,json=canSendPolls,proto3" json:"can_send_polls,omitempty"`
	CanSendOtherMessages  bool   `protobuf:"varint,17,opt,name=can_send_other_messages,json=canSendOtherMessages,proto3" json:"can_send_other_messages,omitempty"`
	CanAddWebPagePreviews bool   `protobuf:"varint,18,opt,name=can_add_web_page_previews,json=canAddWebPagePreviews,proto3" json:"can_add_web_page_previews,omitempty"`
}

func (m *ChatMember) Reset()                    { *m = ChatMember{} }
func (m *ChatMember) String() string            { return proto.CompactTextString(m) }
func (*ChatMember) ProtoMessage()               {}
func (*ChatMember) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{27} }

func (m *ChatMember) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ChatMember) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ChatMember) GetUntilDate() int32 {
	if m != nil {
		return m.UntilDate
	}
	return 0
}

func (m *ChatMember) GetCanBeEdited() bool {
	if m != nil {
		return m.CanBeEdited
	}
	return false
}

func (m *ChatMember) GetCanPostMessages() bool {
	if m != nil {
		return m.CanPostMessages
	}
	return false
}

func (m *ChatMember) GetCanEditMessages() bool {
	if m != nil {
		return m.CanEditMessages
	}
	return false
}

func (m *ChatMember) GetCanDeleteMessages() bool {
	if m != nil {
		return m.CanDeleteMessages
	}
	return false
}

func (m *ChatMember) GetCanRestrictMembers() bool {
	if m != nil {
		return m.CanRestrictMembers
	}
	return false
}

func (m *ChatMember) GetCanPromoteMembers() bool {
	if m != nil {
		return m.CanPromoteMembers
	}
	return false
}

func (m *ChatMember) GetCanChangeInfo() bool {
	if m != nil {
		return m.CanChangeInfo
	}
	return false
}

func (m *ChatMember) GetCanInviteUsers() bool {
	if m != nil {
		return m.CanInviteUsers
	}
	return false
}

func (m *ChatMember) GetCanPinMessages() bool {
	if m != nil {
		return m.CanPinMessages
	}
	return false
}

func (m *ChatMember) GetIsMember() bool {
	if m != nil {
		return m.IsMember
	}
	return false
}

func (m *ChatMember) GetCanSendMessages() bool {
	if m != nil {
		return m.CanSendMessages
	}
	return false
}

func (m *ChatMember) GetCanSendMediaMessages() bool {
	if m != nil {
		return m.CanSendMediaMessages
	}
	return false
}

func (m *ChatMember) GetCanSendPolls() bool {
	if m != nil {
		return m.CanSendPolls
	}
	return false
}

func (m *ChatMember) GetCanSendOtherMessages() bool {
	if m != nil {
		return m.CanSendOtherMessages
	}
	return false
}

func (m *ChatMember) GetCanAddWebPagePreviews() bool {
	if m != nil {
		return m.CanAddWebPagePreviews
	}
	return false
}

// Describes actions that a non-administrator user is allowed to take in a chat.
type ChatPermissions struct {
	CanSendMessages       bool `protobuf:"varint,1,opt,name=can_send_messages,json=canSendMessages,proto3" json:"can_send_messages,omitempty"`
	CanSendMediaMessages  bool `protobuf:"varint,2,opt,name=can_send_media_messages,json=canSendMediaMessages,proto3" json:"can_send_media_messages,omitempty"`
	CanSendPolls          bool `protobuf:"varint,3,opt,name=can_send_polls,json=canSendPolls,proto3" json:"can_send_polls,omitempty"`
	CanSendOtherMessages  bool `protobuf:"varint,4,opt,name=can_send_other_messages,json=canSendOtherMessages,proto3" json:"can_send_other_messages,omitempty"`
	CanAddWebPagePreviews bool `protobuf:"varint,5,opt,name=can_add_web_page_previews,json=canAddWebPagePreviews,proto3" json:"can_add_web_page_previews,omitempty"`
	CanChangeInfo         bool `protobuf:"varint,6,opt,name=can_change_info,json=canChangeInfo,proto3" json:"can_change_info,omitempty"`
	CanInviteUsers        bool `protobuf:"varint,7,opt,name=can_invite_users,json=canInviteUsers,proto3" json:"can_invite_users,omitempty"`
	CanPinMessages        bool `protobuf:"varint,8,opt,name=can_pin_messages,json=canPinMessages,proto3" json:"can_pin_messages,omitempty"`
}

func (m *ChatPermissions) Reset()                    { *m = ChatPermissions{} }
func (m *ChatPermissions) String() string            { return proto.CompactTextString(m) }
func (*ChatPermissions) ProtoMessage()               {}
func (*ChatPermissions) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{28} }

func (m *ChatPermissions) GetCanSendMessages() bool {
	if m != nil {
		return m.CanSendMessages
	}
	return false
}

func (m *ChatPermissions) GetCanSendMediaMessages() bool {
	if m != nil {
		return m.CanSendMediaMessages
	}
	return false
}

func (m *ChatPermissions) GetCanSendPolls() bool {
	if m != nil {
		return m.CanSendPolls
	}
	return false
}

func (m *ChatPermissions) GetCanSendOtherMessages() bool {
	if m != nil {
		return m.CanSendOtherMessages
	}
	return false
}

func (m *ChatPermissions) GetCanAddWebPagePreviews() bool {
	if m != nil {
		return m.CanAddWebPagePreviews
	}
	return false
}

func (m *ChatPermissions) GetCanChangeInfo() bool {
	if m != nil {
		return m.CanChangeInfo
	}
	return false
}

func (m *ChatPermissions) GetCanInviteUsers() bool {
	if m != nil {
		return m.CanInviteUsers
	}
	return false
}

func (m *ChatPermissions) GetCanPinMessages() bool {
	if m != nil {
		return m.CanPinMessages
	}
	return false
}

// Contains information about why a request was unsuccessful.
type ResponseParameters struct {
	MigrateToChatId int32 `protobuf:"varint,1,opt,name=migrate_to_chat_id,json=migrateToChatId,proto3" json:"migrate_to_chat_id,omitempty"`
	RetryAfter      int32 `protobuf:"varint,2,opt,name=retry_after,json=retryAfter,proto3" json:"retry_after,omitempty"`
}

func (m *ResponseParameters) Reset()                    { *m = ResponseParameters{} }
func (m *ResponseParameters) String() string            { return proto.CompactTextString(m) }
func (*ResponseParameters) ProtoMessage()               {}
func (*ResponseParameters) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{29} }

func (m *ResponseParameters) GetMigrateToChatId() int32 {
	if m != nil {
		return m.MigrateToChatId
	}
	return 0
}

func (m *ResponseParameters) GetRetryAfter() int32 {
	if m != nil {
		return m.RetryAfter
	}
	return 0
}

// This object represents the content of a media message to be sent. It should be one of
type InputMedia struct {
}

func (m *InputMedia) Reset()                    { *m = InputMedia{} }
func (m *InputMedia) String() string            { return proto.CompactTextString(m) }
func (*InputMedia) ProtoMessage()               {}
func (*InputMedia) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{30} }

// Represents a photo to be sent.
type InputMediaPhoto struct {
	Type      string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Media     string `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Caption   string `protobuf:"bytes,3,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode string `protobuf:"bytes,4,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
}

func (m *InputMediaPhoto) Reset()                    { *m = InputMediaPhoto{} }
func (m *InputMediaPhoto) String() string            { return proto.CompactTextString(m) }
func (*InputMediaPhoto) ProtoMessage()               {}
func (*InputMediaPhoto) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{31} }

func (m *InputMediaPhoto) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InputMediaPhoto) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *InputMediaPhoto) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaPhoto) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

// Represents a video to be sent.
type InputMediaVideo struct {
	Type              string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Media             string `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Thumb             string `protobuf:"bytes,3,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption           string `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode         string `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	Width             int32  `protobuf:"varint,6,opt,name=width,proto3" json:"width,omitempty"`
	Height            int32  `protobuf:"varint,7,opt,name=height,proto3" json:"height,omitempty"`
	Duration          int32  `protobuf:"varint,8,opt,name=duration,proto3" json:"duration,omitempty"`
	SupportsStreaming bool   `protobuf:"varint,9,opt,name=supports_streaming,json=supportsStreaming,proto3" json:"supports_streaming,omitempty"`
}

func (m *InputMediaVideo) Reset()                    { *m = InputMediaVideo{} }
func (m *InputMediaVideo) String() string            { return proto.CompactTextString(m) }
func (*InputMediaVideo) ProtoMessage()               {}
func (*InputMediaVideo) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{32} }

func (m *InputMediaVideo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InputMediaVideo) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *InputMediaVideo) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *InputMediaVideo) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaVideo) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InputMediaVideo) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *InputMediaVideo) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *InputMediaVideo) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *InputMediaVideo) GetSupportsStreaming() bool {
	if m != nil {
		return m.SupportsStreaming
	}
	return false
}

// Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent.
type InputMediaAnimation struct {
	Type      string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Media     string `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Thumb     string `protobuf:"bytes,3,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption   string `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode string `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	Width     int32  `protobuf:"varint,6,opt,name=width,proto3" json:"width,omitempty"`
	Height    int32  `protobuf:"varint,7,opt,name=height,proto3" json:"height,omitempty"`
	Duration  int32  `protobuf:"varint,8,opt,name=duration,proto3" json:"duration,omitempty"`
}

func (m *InputMediaAnimation) Reset()                    { *m = InputMediaAnimation{} }
func (m *InputMediaAnimation) String() string            { return proto.CompactTextString(m) }
func (*InputMediaAnimation) ProtoMessage()               {}
func (*InputMediaAnimation) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{33} }

func (m *InputMediaAnimation) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InputMediaAnimation) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *InputMediaAnimation) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *InputMediaAnimation) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaAnimation) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InputMediaAnimation) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *InputMediaAnimation) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *InputMediaAnimation) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// Represents an audio file to be treated as music to be sent.
type InputMediaAudio struct {
	Type      string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Media     string `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Thumb     string `protobuf:"bytes,3,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption   string `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode string `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	Duration  int32  `protobuf:"varint,6,opt,name=duration,proto3" json:"duration,omitempty"`
	Performer string `protobuf:"bytes,7,opt,name=performer,proto3" json:"performer,omitempty"`
	Title     string `protobuf:"bytes,8,opt,name=title,proto3" json:"title,omitempty"`
}

func (m *InputMediaAudio) Reset()                    { *m = InputMediaAudio{} }
func (m *InputMediaAudio) String() string            { return proto.CompactTextString(m) }
func (*InputMediaAudio) ProtoMessage()               {}
func (*InputMediaAudio) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{34} }

func (m *InputMediaAudio) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InputMediaAudio) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *InputMediaAudio) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *InputMediaAudio) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaAudio) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InputMediaAudio) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *InputMediaAudio) GetPerformer() string {
	if m != nil {
		return m.Performer
	}
	return ""
}

func (m *InputMediaAudio) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

// Represents a general file to be sent.
type InputMediaDocument struct {
	Type      string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Media     string `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Thumb     string `protobuf:"bytes,3,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption   string `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode string `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
}

func (m *InputMediaDocument) Reset()                    { *m = InputMediaDocument{} }
func (m *InputMediaDocument) String() string            { return proto.CompactTextString(m) }
func (*InputMediaDocument) ProtoMessage()               {}
func (*InputMediaDocument) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{35} }

func (m *InputMediaDocument) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InputMediaDocument) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *InputMediaDocument) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *InputMediaDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaDocument) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

// This object represents the contents of a file to be uploaded. Must be posted using multipart/form-data in the usual way that files are uploaded via the browser.
//  There are three ways to send files (photos, stickers, audio, media, etc.):
// Sending by file_id
// Sending by URL
// Objects and methods used in the inline mode are described in the Inline mode section.
type InputFile struct {
}

func (m *InputFile) Reset()                    { *m = InputFile{} }
func (m *InputFile) String() string            { return proto.CompactTextString(m) }
func (*InputFile) ProtoMessage()               {}
func (*InputFile) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{36} }

// Use this method to send answers to callback queries sent from inline keyboards. The answer will be displayed to the user as a notification at the top of the chat screen or as an alert. On success, True is returned.
// Alternatively, the user can be redirected to the specified Game URL. For this option to work, you must first create a game for your bot via @Botfather and accept the terms. Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with a parameter.
//
// Methods and objects used in the inline mode are described in the Inline mode section.
type AnswerCallbackQuery struct {
	CallbackQueryId string `protobuf:"bytes,1,opt,name=callback_query_id,json=callbackQueryId,proto3" json:"callback_query_id,omitempty"`
	Text            string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	ShowAlert       bool   `protobuf:"varint,3,opt,name=show_alert,json=showAlert,proto3" json:"show_alert,omitempty"`
	Url             string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	CacheTime       int32  `protobuf:"varint,5,opt,name=cache_time,json=cacheTime,proto3" json:"cache_time,omitempty"`
}

func (m *AnswerCallbackQuery) Reset()                    { *m = AnswerCallbackQuery{} }
func (m *AnswerCallbackQuery) String() string            { return proto.CompactTextString(m) }
func (*AnswerCallbackQuery) ProtoMessage()               {}
func (*AnswerCallbackQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{37} }

func (m *AnswerCallbackQuery) GetCallbackQueryId() string {
	if m != nil {
		return m.CallbackQueryId
	}
	return ""
}

func (m *AnswerCallbackQuery) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *AnswerCallbackQuery) GetShowAlert() bool {
	if m != nil {
		return m.ShowAlert
	}
	return false
}

func (m *AnswerCallbackQuery) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *AnswerCallbackQuery) GetCacheTime() int32 {
	if m != nil {
		return m.CacheTime
	}
	return 0
}

// This object represents a sticker.
type Sticker struct {
	FileId       string        `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Width        int32         `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height       int32         `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	IsAnimated   bool          `protobuf:"varint,4,opt,name=is_animated,json=isAnimated,proto3" json:"is_animated,omitempty"`
	Thumb        *PhotoSize    `protobuf:"bytes,5,opt,name=thumb" json:"thumb,omitempty"`
	Emoji        string        `protobuf:"bytes,6,opt,name=emoji,proto3" json:"emoji,omitempty"`
	SetName      string        `protobuf:"bytes,7,opt,name=set_name,json=setName,proto3" json:"set_name,omitempty"`
	MaskPosition *MaskPosition `protobuf:"bytes,8,opt,name=mask_position,json=maskPosition" json:"mask_position,omitempty"`
	FileSize     int32         `protobuf:"varint,9,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *Sticker) Reset()                    { *m = Sticker{} }
func (m *Sticker) String() string            { return proto.CompactTextString(m) }
func (*Sticker) ProtoMessage()               {}
func (*Sticker) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{38} }

func (m *Sticker) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Sticker) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Sticker) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Sticker) GetIsAnimated() bool {
	if m != nil {
		return m.IsAnimated
	}
	return false
}

func (m *Sticker) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *Sticker) GetEmoji() string {
	if m != nil {
		return m.Emoji
	}
	return ""
}

func (m *Sticker) GetSetName() string {
	if m != nil {
		return m.SetName
	}
	return ""
}

func (m *Sticker) GetMaskPosition() *MaskPosition {
	if m != nil {
		return m.MaskPosition
	}
	return nil
}

func (m *Sticker) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents a sticker set.
type StickerSet struct {
	Name          string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Title         string     `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	IsAnimated    bool       `protobuf:"varint,3,opt,name=is_animated,json=isAnimated,proto3" json:"is_animated,omitempty"`
	ContainsMasks bool       `protobuf:"varint,4,opt,name=contains_masks,json=containsMasks,proto3" json:"contains_masks,omitempty"`
	Stickers      []*Sticker `protobuf:"bytes,5,rep,name=stickers" json:"stickers,omitempty"`
}

func (m *StickerSet) Reset()                    { *m = StickerSet{} }
func (m *StickerSet) String() string            { return proto.CompactTextString(m) }
func (*StickerSet) ProtoMessage()               {}
func (*StickerSet) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{39} }

func (m *StickerSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StickerSet) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *StickerSet) GetIsAnimated() bool {
	if m != nil {
		return m.IsAnimated
	}
	return false
}

func (m *StickerSet) GetContainsMasks() bool {
	if m != nil {
		return m.ContainsMasks
	}
	return false
}

func (m *StickerSet) GetStickers() []*Sticker {
	if m != nil {
		return m.Stickers
	}
	return nil
}

// This object describes the position on faces where a mask should be placed by default.
type MaskPosition struct {
	Point  string `protobuf:"bytes,1,opt,name=point,proto3" json:"point,omitempty"`
	XShift int64  `protobuf:"varint,2,opt,name=x_shift,json=xShift,proto3" json:"x_shift,omitempty"`
	YShift int64  `protobuf:"varint,3,opt,name=y_shift,json=yShift,proto3" json:"y_shift,omitempty"`
	Scale  int64  `protobuf:"varint,4,opt,name=scale,proto3" json:"scale,omitempty"`
}

func (m *MaskPosition) Reset()                    { *m = MaskPosition{} }
func (m *MaskPosition) String() string            { return proto.CompactTextString(m) }
func (*MaskPosition) ProtoMessage()               {}
func (*MaskPosition) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{40} }

func (m *MaskPosition) GetPoint() string {
	if m != nil {
		return m.Point
	}
	return ""
}

func (m *MaskPosition) GetXShift() int64 {
	if m != nil {
		return m.XShift
	}
	return 0
}

func (m *MaskPosition) GetYShift() int64 {
	if m != nil {
		return m.YShift
	}
	return 0
}

func (m *MaskPosition) GetScale() int64 {
	if m != nil {
		return m.Scale
	}
	return 0
}

// Use this method to add a new sticker to a set created by the bot. Returns True on success.
type AddStickerToSet struct {
	UserId       int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Name         string        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	PngSticker   string        `protobuf:"bytes,3,opt,name=png_sticker,json=pngSticker,proto3" json:"png_sticker,omitempty"`
	Emojis       string        `protobuf:"bytes,4,opt,name=emojis,proto3" json:"emojis,omitempty"`
	MaskPosition *MaskPosition `protobuf:"bytes,5,opt,name=mask_position,json=maskPosition" json:"mask_position,omitempty"`
}

func (m *AddStickerToSet) Reset()                    { *m = AddStickerToSet{} }
func (m *AddStickerToSet) String() string            { return proto.CompactTextString(m) }
func (*AddStickerToSet) ProtoMessage()               {}
func (*AddStickerToSet) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{41} }

func (m *AddStickerToSet) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AddStickerToSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AddStickerToSet) GetPngSticker() string {
	if m != nil {
		return m.PngSticker
	}
	return ""
}

func (m *AddStickerToSet) GetEmojis() string {
	if m != nil {
		return m.Emojis
	}
	return ""
}

func (m *AddStickerToSet) GetMaskPosition() *MaskPosition {
	if m != nil {
		return m.MaskPosition
	}
	return nil
}

// If you sent an invoice requesting a shipping address and the parameter is_flexible was specified, the Bot API will send an Update with a shipping_query field to the bot. Use this method to reply to shipping queries. On success, True is returned.
type AnswerShippingQuery struct {
	ShippingQueryId string            `protobuf:"bytes,1,opt,name=shipping_query_id,json=shippingQueryId,proto3" json:"shipping_query_id,omitempty"`
	Ok              bool              `protobuf:"varint,2,opt,name=ok,proto3" json:"ok,omitempty"`
	ShippingOptions []*ShippingOption `protobuf:"bytes,3,rep,name=shipping_options,json=shippingOptions" json:"shipping_options,omitempty"`
	ErrorMessage    string            `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *AnswerShippingQuery) Reset()                    { *m = AnswerShippingQuery{} }
func (m *AnswerShippingQuery) String() string            { return proto.CompactTextString(m) }
func (*AnswerShippingQuery) ProtoMessage()               {}
func (*AnswerShippingQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{42} }

func (m *AnswerShippingQuery) GetShippingQueryId() string {
	if m != nil {
		return m.ShippingQueryId
	}
	return ""
}

func (m *AnswerShippingQuery) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *AnswerShippingQuery) GetShippingOptions() []*ShippingOption {
	if m != nil {
		return m.ShippingOptions
	}
	return nil
}

func (m *AnswerShippingQuery) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of an Update with the field pre_checkout_query. Use this method to respond to such pre-checkout queries. On success, True is returned. Note: The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.
type AnswerPreCheckoutQuery struct {
	PreCheckoutQueryId string `protobuf:"bytes,1,opt,name=pre_checkout_query_id,json=preCheckoutQueryId,proto3" json:"pre_checkout_query_id,omitempty"`
	Ok                 bool   `protobuf:"varint,2,opt,name=ok,proto3" json:"ok,omitempty"`
	ErrorMessage       string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *AnswerPreCheckoutQuery) Reset()                    { *m = AnswerPreCheckoutQuery{} }
func (m *AnswerPreCheckoutQuery) String() string            { return proto.CompactTextString(m) }
func (*AnswerPreCheckoutQuery) ProtoMessage()               {}
func (*AnswerPreCheckoutQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{43} }

func (m *AnswerPreCheckoutQuery) GetPreCheckoutQueryId() string {
	if m != nil {
		return m.PreCheckoutQueryId
	}
	return ""
}

func (m *AnswerPreCheckoutQuery) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *AnswerPreCheckoutQuery) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// This object represents a portion of the price for goods or services.
type LabeledPrice struct {
	Label  string `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Amount int32  `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *LabeledPrice) Reset()                    { *m = LabeledPrice{} }
func (m *LabeledPrice) String() string            { return proto.CompactTextString(m) }
func (*LabeledPrice) ProtoMessage()               {}
func (*LabeledPrice) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{44} }

func (m *LabeledPrice) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *LabeledPrice) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// This object contains basic information about an invoice.
type Invoice struct {
	Title          string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description    string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	StartParameter string `protobuf:"bytes,3,opt,name=start_parameter,json=startParameter,proto3" json:"start_parameter,omitempty"`
	Currency       string `protobuf:"bytes,4,opt,name=currency,proto3" json:"currency,omitempty"`
	TotalAmount    int32  `protobuf:"varint,5,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
}

func (m *Invoice) Reset()                    { *m = Invoice{} }
func (m *Invoice) String() string            { return proto.CompactTextString(m) }
func (*Invoice) ProtoMessage()               {}
func (*Invoice) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{45} }

func (m *Invoice) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Invoice) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Invoice) GetStartParameter() string {
	if m != nil {
		return m.StartParameter
	}
	return ""
}

func (m *Invoice) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *Invoice) GetTotalAmount() int32 {
	if m != nil {
		return m.TotalAmount
	}
	return 0
}

// This object represents a shipping address.
type ShippingAddress struct {
	CountryCode string `protobuf:"bytes,1,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty"`
	State       string `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	City        string `protobuf:"bytes,3,opt,name=city,proto3" json:"city,omitempty"`
	StreetLine1 string `protobuf:"bytes,4,opt,name=street_line1,json=streetLine1,proto3" json:"street_line1,omitempty"`
	StreetLine2 string `protobuf:"bytes,5,opt,name=street_line2,json=streetLine2,proto3" json:"street_line2,omitempty"`
	PostCode    string `protobuf:"bytes,6,opt,name=post_code,json=postCode,proto3" json:"post_code,omitempty"`
}

func (m *ShippingAddress) Reset()                    { *m = ShippingAddress{} }
func (m *ShippingAddress) String() string            { return proto.CompactTextString(m) }
func (*ShippingAddress) ProtoMessage()               {}
func (*ShippingAddress) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{46} }

func (m *ShippingAddress) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *ShippingAddress) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *ShippingAddress) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *ShippingAddress) GetStreetLine1() string {
	if m != nil {
		return m.StreetLine1
	}
	return ""
}

func (m *ShippingAddress) GetStreetLine2() string {
	if m != nil {
		return m.StreetLine2
	}
	return ""
}

func (m *ShippingAddress) GetPostCode() string {
	if m != nil {
		return m.PostCode
	}
	return ""
}

// This object represents information about an order.
type OrderInfo struct {
	Name            string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	PhoneNumber     string           `protobuf:"bytes,2,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	Email           string           `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	ShippingAddress *ShippingAddress `protobuf:"bytes,4,opt,name=shipping_address,json=shippingAddress" json:"shipping_address,omitempty"`
}

func (m *OrderInfo) Reset()                    { *m = OrderInfo{} }
func (m *OrderInfo) String() string            { return proto.CompactTextString(m) }
func (*OrderInfo) ProtoMessage()               {}
func (*OrderInfo) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{47} }

func (m *OrderInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OrderInfo) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *OrderInfo) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *OrderInfo) GetShippingAddress() *ShippingAddress {
	if m != nil {
		return m.ShippingAddress
	}
	return nil
}

// This object represents one shipping option.
type ShippingOption struct {
	Id     string          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Title  string          `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Prices []*LabeledPrice `protobuf:"bytes,3,rep,name=prices" json:"prices,omitempty"`
}

func (m *ShippingOption) Reset()                    { *m = ShippingOption{} }
func (m *ShippingOption) String() string            { return proto.CompactTextString(m) }
func (*ShippingOption) ProtoMessage()               {}
func (*ShippingOption) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{48} }

func (m *ShippingOption) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ShippingOption) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ShippingOption) GetPrices() []*LabeledPrice {
	if m != nil {
		return m.Prices
	}
	return nil
}

// This object contains basic information about a successful payment.
type SuccessfulPayment struct {
	Currency                string     `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	TotalAmount             int32      `protobuf:"varint,2,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
	InvoicePayload          string     `protobuf:"bytes,3,opt,name=invoice_payload,json=invoicePayload,proto3" json:"invoice_payload,omitempty"`
	ShippingOptionId        string     `protobuf:"bytes,4,opt,name=shipping_option_id,json=shippingOptionId,proto3" json:"shipping_option_id,omitempty"`
	OrderInfo               *OrderInfo `protobuf:"bytes,5,opt,name=order_info,json=orderInfo" json:"order_info,omitempty"`
	TelegramPaymentChargeId string     `protobuf:"bytes,6,opt,name=telegram_payment_charge_id,json=telegramPaymentChargeId,proto3" json:"telegram_payment_charge_id,omitempty"`
	ProviderPaymentChargeId string     `protobuf:"bytes,7,opt,name=provider_payment_charge_id,json=providerPaymentChargeId,proto3" json:"provider_payment_charge_id,omitempty"`
}

func (m *SuccessfulPayment) Reset()                    { *m = SuccessfulPayment{} }
func (m *SuccessfulPayment) String() string            { return proto.CompactTextString(m) }
func (*SuccessfulPayment) ProtoMessage()               {}
func (*SuccessfulPayment) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{49} }

func (m *SuccessfulPayment) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *SuccessfulPayment) GetTotalAmount() int32 {
	if m != nil {
		return m.TotalAmount
	}
	return 0
}

func (m *SuccessfulPayment) GetInvoicePayload() string {
	if m != nil {
		return m.InvoicePayload
	}
	return ""
}

func (m *SuccessfulPayment) GetShippingOptionId() string {
	if m != nil {
		return m.ShippingOptionId
	}
	return ""
}

func (m *SuccessfulPayment) GetOrderInfo() *OrderInfo {
	if m != nil {
		return m.OrderInfo
	}
	return nil
}

func (m *SuccessfulPayment) GetTelegramPaymentChargeId() string {
	if m != nil {
		return m.TelegramPaymentChargeId
	}
	return ""
}

func (m *SuccessfulPayment) GetProviderPaymentChargeId() string {
	if m != nil {
		return m.ProviderPaymentChargeId
	}
	return ""
}

// This object contains information about an incoming shipping query.
type ShippingQuery struct {
	Id              string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	From            *User            `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	InvoicePayload  string           `protobuf:"bytes,3,opt,name=invoice_payload,json=invoicePayload,proto3" json:"invoice_payload,omitempty"`
	ShippingAddress *ShippingAddress `protobuf:"bytes,4,opt,name=shipping_address,json=shippingAddress" json:"shipping_address,omitempty"`
}

func (m *ShippingQuery) Reset()                    { *m = ShippingQuery{} }
func (m *ShippingQuery) String() string            { return proto.CompactTextString(m) }
func (*ShippingQuery) ProtoMessage()               {}
func (*ShippingQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{50} }

func (m *ShippingQuery) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ShippingQuery) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ShippingQuery) GetInvoicePayload() string {
	if m != nil {
		return m.InvoicePayload
	}
	return ""
}

func (m *ShippingQuery) GetShippingAddress() *ShippingAddress {
	if m != nil {
		return m.ShippingAddress
	}
	return nil
}

// This object contains information about an incoming pre-checkout query.
type PreCheckoutQuery struct {
	Id               string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	From             *User      `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	Currency         string     `protobuf:"bytes,3,opt,name=currency,proto3" json:"currency,omitempty"`
	TotalAmount      int32      `protobuf:"varint,4,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
	InvoicePayload   string     `protobuf:"bytes,5,opt,name=invoice_payload,json=invoicePayload,proto3" json:"invoice_payload,omitempty"`
	ShippingOptionId string     `protobuf:"bytes,6,opt,name=shipping_option_id,json=shippingOptionId,proto3" json:"shipping_option_id,omitempty"`
	OrderInfo        *OrderInfo `protobuf:"bytes,7,opt,name=order_info,json=orderInfo" json:"order_info,omitempty"`
}

func (m *PreCheckoutQuery) Reset()                    { *m = PreCheckoutQuery{} }
func (m *PreCheckoutQuery) String() string            { return proto.CompactTextString(m) }
func (*PreCheckoutQuery) ProtoMessage()               {}
func (*PreCheckoutQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{51} }

func (m *PreCheckoutQuery) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PreCheckoutQuery) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *PreCheckoutQuery) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *PreCheckoutQuery) GetTotalAmount() int32 {
	if m != nil {
		return m.TotalAmount
	}
	return 0
}

func (m *PreCheckoutQuery) GetInvoicePayload() string {
	if m != nil {
		return m.InvoicePayload
	}
	return ""
}

func (m *PreCheckoutQuery) GetShippingOptionId() string {
	if m != nil {
		return m.ShippingOptionId
	}
	return ""
}

func (m *PreCheckoutQuery) GetOrderInfo() *OrderInfo {
	if m != nil {
		return m.OrderInfo
	}
	return nil
}

// Contains information about Telegram Passport data shared with the bot by the user.
type PassportData struct {
	Data        []*EncryptedPassportElement `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
	Credentials *EncryptedCredentials       `protobuf:"bytes,2,opt,name=credentials" json:"credentials,omitempty"`
}

func (m *PassportData) Reset()                    { *m = PassportData{} }
func (m *PassportData) String() string            { return proto.CompactTextString(m) }
func (*PassportData) ProtoMessage()               {}
func (*PassportData) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{52} }

func (m *PassportData) GetData() []*EncryptedPassportElement {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *PassportData) GetCredentials() *EncryptedCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

// This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format when decrypted and don't exceed 10MB.
type PassportFile struct {
	FileId   string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	FileSize int32  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	FileDate int32  `protobuf:"varint,3,opt,name=file_date,json=fileDate,proto3" json:"file_date,omitempty"`
}

func (m *PassportFile) Reset()                    { *m = PassportFile{} }
func (m *PassportFile) String() string            { return proto.CompactTextString(m) }
func (*PassportFile) ProtoMessage()               {}
func (*PassportFile) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{53} }

func (m *PassportFile) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *PassportFile) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *PassportFile) GetFileDate() int32 {
	if m != nil {
		return m.FileDate
	}
	return 0
}

// Contains information about documents or other Telegram Passport elements shared with the bot by the user.
type EncryptedPassportElement struct {
	Type        string          `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Data        string          `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	PhoneNumber string          `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	Email       string          `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
	Files       []*PassportFile `protobuf:"bytes,5,rep,name=files" json:"files,omitempty"`
	FrontSide   *PassportFile   `protobuf:"bytes,6,opt,name=front_side,json=frontSide" json:"front_side,omitempty"`
	ReverseSide *PassportFile   `protobuf:"bytes,7,opt,name=reverse_side,json=reverseSide" json:"reverse_side,omitempty"`
	Selfie      *PassportFile   `protobuf:"bytes,8,opt,name=selfie" json:"selfie,omitempty"`
	Translation []*PassportFile `protobuf:"bytes,9,rep,name=translation" json:"translation,omitempty"`
	Hash        string          `protobuf:"bytes,10,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *EncryptedPassportElement) Reset()         { *m = EncryptedPassportElement{} }
func (m *EncryptedPassportElement) String() string { return proto.CompactTextString(m) }
func (*EncryptedPassportElement) ProtoMessage()    {}
func (*EncryptedPassportElement) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{54}
}

func (m *EncryptedPassportElement) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *EncryptedPassportElement) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *EncryptedPassportElement) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *EncryptedPassportElement) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *EncryptedPassportElement) GetFiles() []*PassportFile {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *EncryptedPassportElement) GetFrontSide() *PassportFile {
	if m != nil {
		return m.FrontSide
	}
	return nil
}

func (m *EncryptedPassportElement) GetReverseSide() *PassportFile {
	if m != nil {
		return m.ReverseSide
	}
	return nil
}

func (m *EncryptedPassportElement) GetSelfie() *PassportFile {
	if m != nil {
		return m.Selfie
	}
	return nil
}

func (m *EncryptedPassportElement) GetTranslation() []*PassportFile {
	if m != nil {
		return m.Translation
	}
	return nil
}

func (m *EncryptedPassportElement) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

// Contains data required for decrypting and authenticating EncryptedPassportElement. See the Telegram Passport Documentation for a complete description of the data decryption and authentication processes.
type EncryptedCredentials struct {
	Data   string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Hash   string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Secret string `protobuf:"bytes,3,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (m *EncryptedCredentials) Reset()                    { *m = EncryptedCredentials{} }
func (m *EncryptedCredentials) String() string            { return proto.CompactTextString(m) }
func (*EncryptedCredentials) ProtoMessage()               {}
func (*EncryptedCredentials) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{55} }

func (m *EncryptedCredentials) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *EncryptedCredentials) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *EncryptedCredentials) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

// This object represents an error in the Telegram Passport element which was submitted that should be resolved by the user. It should be one of:
type PassportElementError struct {
}

func (m *PassportElementError) Reset()                    { *m = PassportElementError{} }
func (m *PassportElementError) String() string            { return proto.CompactTextString(m) }
func (*PassportElementError) ProtoMessage()               {}
func (*PassportElementError) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{56} }

// Represents an issue in one of the data fields that was provided by the user. The error is considered resolved when the field's value changes.
type PassportElementErrorDataField struct {
	Source    string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type      string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FieldName string `protobuf:"bytes,3,opt,name=field_name,json=fieldName,proto3" json:"field_name,omitempty"`
	DataHash  string `protobuf:"bytes,4,opt,name=data_hash,json=dataHash,proto3" json:"data_hash,omitempty"`
	Message   string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorDataField) Reset()         { *m = PassportElementErrorDataField{} }
func (m *PassportElementErrorDataField) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorDataField) ProtoMessage()    {}
func (*PassportElementErrorDataField) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{57}
}

func (m *PassportElementErrorDataField) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorDataField) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorDataField) GetFieldName() string {
	if m != nil {
		return m.FieldName
	}
	return ""
}

func (m *PassportElementErrorDataField) GetDataHash() string {
	if m != nil {
		return m.DataHash
	}
	return ""
}

func (m *PassportElementErrorDataField) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with the front side of a document. The error is considered resolved when the file with the front side of the document changes.
type PassportElementErrorFrontSide struct {
	Source   string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorFrontSide) Reset()         { *m = PassportElementErrorFrontSide{} }
func (m *PassportElementErrorFrontSide) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorFrontSide) ProtoMessage()    {}
func (*PassportElementErrorFrontSide) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{58}
}

func (m *PassportElementErrorFrontSide) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorFrontSide) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorFrontSide) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *PassportElementErrorFrontSide) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with the reverse side of a document. The error is considered resolved when the file with reverse side of the document changes.
type PassportElementErrorReverseSide struct {
	Source   string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorReverseSide) Reset()         { *m = PassportElementErrorReverseSide{} }
func (m *PassportElementErrorReverseSide) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorReverseSide) ProtoMessage()    {}
func (*PassportElementErrorReverseSide) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{59}
}

func (m *PassportElementErrorReverseSide) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorReverseSide) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorReverseSide) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *PassportElementErrorReverseSide) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with the selfie with a document. The error is considered resolved when the file with the selfie changes.
type PassportElementErrorSelfie struct {
	Source   string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorSelfie) Reset()         { *m = PassportElementErrorSelfie{} }
func (m *PassportElementErrorSelfie) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorSelfie) ProtoMessage()    {}
func (*PassportElementErrorSelfie) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{60}
}

func (m *PassportElementErrorSelfie) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorSelfie) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorSelfie) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *PassportElementErrorSelfie) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with a document scan. The error is considered resolved when the file with the document scan changes.
type PassportElementErrorFile struct {
	Source   string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorFile) Reset()         { *m = PassportElementErrorFile{} }
func (m *PassportElementErrorFile) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorFile) ProtoMessage()    {}
func (*PassportElementErrorFile) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{61}
}

func (m *PassportElementErrorFile) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorFile) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorFile) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *PassportElementErrorFile) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with a list of scans. The error is considered resolved when the list of files containing the scans changes.
type PassportElementErrorFiles struct {
	Source     string   `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type       string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHashes []string `protobuf:"bytes,3,rep,name=file_hashes,json=fileHashes" json:"file_hashes,omitempty"`
	Message    string   `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorFiles) Reset()         { *m = PassportElementErrorFiles{} }
func (m *PassportElementErrorFiles) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorFiles) ProtoMessage()    {}
func (*PassportElementErrorFiles) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{62}
}

func (m *PassportElementErrorFiles) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorFiles) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorFiles) GetFileHashes() []string {
	if m != nil {
		return m.FileHashes
	}
	return nil
}

func (m *PassportElementErrorFiles) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with one of the files that constitute the translation of a document. The error is considered resolved when the file changes.
type PassportElementErrorTranslationFile struct {
	Source   string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorTranslationFile) Reset()         { *m = PassportElementErrorTranslationFile{} }
func (m *PassportElementErrorTranslationFile) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorTranslationFile) ProtoMessage()    {}
func (*PassportElementErrorTranslationFile) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{63}
}

func (m *PassportElementErrorTranslationFile) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorTranslationFile) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorTranslationFile) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *PassportElementErrorTranslationFile) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with the translated version of a document. The error is considered resolved when a file with the document translation change.
type PassportElementErrorTranslationFiles struct {
	Source     string   `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type       string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHashes []string `protobuf:"bytes,3,rep,name=file_hashes,json=fileHashes" json:"file_hashes,omitempty"`
	Message    string   `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorTranslationFiles) Reset()         { *m = PassportElementErrorTranslationFiles{} }
func (m *PassportElementErrorTranslationFiles) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorTranslationFiles) ProtoMessage()    {}
func (*PassportElementErrorTranslationFiles) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{64}
}

func (m *PassportElementErrorTranslationFiles) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorTranslationFiles) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorTranslationFiles) GetFileHashes() []string {
	if m != nil {
		return m.FileHashes
	}
	return nil
}

func (m *PassportElementErrorTranslationFiles) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue in an unspecified place. The error is considered resolved when new data is added.
type PassportElementErrorUnspecified struct {
	Source      string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type        string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	ElementHash string `protobuf:"bytes,3,opt,name=element_hash,json=elementHash,proto3" json:"element_hash,omitempty"`
	Message     string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorUnspecified) Reset()         { *m = PassportElementErrorUnspecified{} }
func (m *PassportElementErrorUnspecified) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorUnspecified) ProtoMessage()    {}
func (*PassportElementErrorUnspecified) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{65}
}

func (m *PassportElementErrorUnspecified) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorUnspecified) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorUnspecified) GetElementHash() string {
	if m != nil {
		return m.ElementHash
	}
	return ""
}

func (m *PassportElementErrorUnspecified) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// This object represents a game. Use BotFather to create and edit games, their short names will act as unique identifiers.
type Game struct {
	Title        string           `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description  string           `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Photo        []*PhotoSize     `protobuf:"bytes,3,rep,name=photo" json:"photo,omitempty"`
	Text         string           `protobuf:"bytes,4,opt,name=text,proto3" json:"text,omitempty"`
	TextEntities []*MessageEntity `protobuf:"bytes,5,rep,name=text_entities,json=textEntities" json:"text_entities,omitempty"`
	Animation    *Animation       `protobuf:"bytes,6,opt,name=animation" json:"animation,omitempty"`
}

func (m *Game) Reset()                    { *m = Game{} }
func (m *Game) String() string            { return proto.CompactTextString(m) }
func (*Game) ProtoMessage()               {}
func (*Game) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{66} }

func (m *Game) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Game) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Game) GetPhoto() []*PhotoSize {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *Game) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Game) GetTextEntities() []*MessageEntity {
	if m != nil {
		return m.TextEntities
	}
	return nil
}

func (m *Game) GetAnimation() *Animation {
	if m != nil {
		return m.Animation
	}
	return nil
}

// A placeholder, currently holds no information. Use BotFather to set up your game.
type CallbackGame struct {
}

func (m *CallbackGame) Reset()                    { *m = CallbackGame{} }
func (m *CallbackGame) String() string            { return proto.CompactTextString(m) }
func (*CallbackGame) ProtoMessage()               {}
func (*CallbackGame) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{67} }

// This object represents one row of the high scores table for a game.
// And that‘s about all we’ve got for now.If you've got any questions, please check out our Bot FAQ »
type GameHighScore struct {
	Position int32 `protobuf:"varint,1,opt,name=position,proto3" json:"position,omitempty"`
	User     *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Score    int32 `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *GameHighScore) Reset()                    { *m = GameHighScore{} }
func (m *GameHighScore) String() string            { return proto.CompactTextString(m) }
func (*GameHighScore) ProtoMessage()               {}
func (*GameHighScore) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{68} }

func (m *GameHighScore) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *GameHighScore) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *GameHighScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

type ReplyMarkup struct {
	// Types that are valid to be assigned to ReplyMarkup:
	//	*ReplyMarkup_InlineKeyboardMarkup
	//	*ReplyMarkup_ReplyKeyboardMarkup
	//	*ReplyMarkup_ReplyKeyboardRemove
	//	*ReplyMarkup_ForceReply
	ReplyMarkup isReplyMarkup_ReplyMarkup `protobuf_oneof:"ReplyMarkup"`
}

func (m *ReplyMarkup) Reset()                    { *m = ReplyMarkup{} }
func (m *ReplyMarkup) String() string            { return proto.CompactTextString(m) }
func (*ReplyMarkup) ProtoMessage()               {}
func (*ReplyMarkup) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{69} }

type isReplyMarkup_ReplyMarkup interface {
	isReplyMarkup_ReplyMarkup()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplyMarkup_InlineKeyboardMarkup struct {
	InlineKeyboardMarkup *InlineKeyboardMarkup `protobuf:"bytes,1,opt,name=InlineKeyboardMarkup,oneof"`
}
type ReplyMarkup_ReplyKeyboardMarkup struct {
	ReplyKeyboardMarkup *ReplyKeyboardMarkup `protobuf:"bytes,2,opt,name=ReplyKeyboardMarkup,oneof"`
}
type ReplyMarkup_ReplyKeyboardRemove struct {
	ReplyKeyboardRemove *ReplyKeyboardRemove `protobuf:"bytes,3,opt,name=ReplyKeyboardRemove,oneof"`
}
type ReplyMarkup_ForceReply struct {
	ForceReply *ForceReply `protobuf:"bytes,4,opt,name=ForceReply,oneof"`
}

func (*ReplyMarkup_InlineKeyboardMarkup) isReplyMarkup_ReplyMarkup() {}
func (*ReplyMarkup_ReplyKeyboardMarkup) isReplyMarkup_ReplyMarkup()  {}
func (*ReplyMarkup_ReplyKeyboardRemove) isReplyMarkup_ReplyMarkup()  {}
func (*ReplyMarkup_ForceReply) isReplyMarkup_ReplyMarkup()           {}

func (m *ReplyMarkup) GetReplyMarkup() isReplyMarkup_ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *ReplyMarkup) GetInlineKeyboardMarkup() *InlineKeyboardMarkup {
	if x, ok := m.GetReplyMarkup().(*ReplyMarkup_InlineKeyboardMarkup); ok {
		return x.InlineKeyboardMarkup
	}
	return nil
}

func (m *ReplyMarkup) GetReplyKeyboardMarkup() *ReplyKeyboardMarkup {
	if x, ok := m.GetReplyMarkup().(*ReplyMarkup_ReplyKeyboardMarkup); ok {
		return x.ReplyKeyboardMarkup
	}
	return nil
}

func (m *ReplyMarkup) GetReplyKeyboardRemove() *ReplyKeyboardRemove {
	if x, ok := m.GetReplyMarkup().(*ReplyMarkup_ReplyKeyboardRemove); ok {
		return x.ReplyKeyboardRemove
	}
	return nil
}

func (m *ReplyMarkup) GetForceReply() *ForceReply {
	if x, ok := m.GetReplyMarkup().(*ReplyMarkup_ForceReply); ok {
		return x.ForceReply
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplyMarkup) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplyMarkup_OneofMarshaler, _ReplyMarkup_OneofUnmarshaler, _ReplyMarkup_OneofSizer, []interface{}{
		(*ReplyMarkup_InlineKeyboardMarkup)(nil),
		(*ReplyMarkup_ReplyKeyboardMarkup)(nil),
		(*ReplyMarkup_ReplyKeyboardRemove)(nil),
		(*ReplyMarkup_ForceReply)(nil),
	}
}

func _ReplyMarkup_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplyMarkup)
	// ReplyMarkup
	switch x := m.ReplyMarkup.(type) {
	case *ReplyMarkup_InlineKeyboardMarkup:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InlineKeyboardMarkup); err != nil {
			return err
		}
	case *ReplyMarkup_ReplyKeyboardMarkup:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReplyKeyboardMarkup); err != nil {
			return err
		}
	case *ReplyMarkup_ReplyKeyboardRemove:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReplyKeyboardRemove); err != nil {
			return err
		}
	case *ReplyMarkup_ForceReply:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ForceReply); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplyMarkup.ReplyMarkup has unexpected type %T", x)
	}
	return nil
}

func _ReplyMarkup_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplyMarkup)
	switch tag {
	case 1: // ReplyMarkup.InlineKeyboardMarkup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InlineKeyboardMarkup)
		err := b.DecodeMessage(msg)
		m.ReplyMarkup = &ReplyMarkup_InlineKeyboardMarkup{msg}
		return true, err
	case 2: // ReplyMarkup.ReplyKeyboardMarkup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReplyKeyboardMarkup)
		err := b.DecodeMessage(msg)
		m.ReplyMarkup = &ReplyMarkup_ReplyKeyboardMarkup{msg}
		return true, err
	case 3: // ReplyMarkup.ReplyKeyboardRemove
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReplyKeyboardRemove)
		err := b.DecodeMessage(msg)
		m.ReplyMarkup = &ReplyMarkup_ReplyKeyboardRemove{msg}
		return true, err
	case 4: // ReplyMarkup.ForceReply
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ForceReply)
		err := b.DecodeMessage(msg)
		m.ReplyMarkup = &ReplyMarkup_ForceReply{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplyMarkup_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplyMarkup)
	// ReplyMarkup
	switch x := m.ReplyMarkup.(type) {
	case *ReplyMarkup_InlineKeyboardMarkup:
		s := proto.Size(x.InlineKeyboardMarkup)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplyMarkup_ReplyKeyboardMarkup:
		s := proto.Size(x.ReplyKeyboardMarkup)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplyMarkup_ReplyKeyboardRemove:
		s := proto.Size(x.ReplyKeyboardRemove)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplyMarkup_ForceReply:
		s := proto.Size(x.ForceReply)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*User)(nil), "botproto.User")
	proto.RegisterType((*Chat)(nil), "botproto.Chat")
	proto.RegisterType((*Message)(nil), "botproto.Message")
	proto.RegisterType((*MessageEntity)(nil), "botproto.MessageEntity")
	proto.RegisterType((*PhotoSize)(nil), "botproto.PhotoSize")
	proto.RegisterType((*Audio)(nil), "botproto.Audio")
	proto.RegisterType((*Document)(nil), "botproto.Document")
	proto.RegisterType((*Video)(nil), "botproto.Video")
	proto.RegisterType((*Animation)(nil), "botproto.Animation")
	proto.RegisterType((*Voice)(nil), "botproto.Voice")
	proto.RegisterType((*VideoNote)(nil), "botproto.VideoNote")
	proto.RegisterType((*Contact)(nil), "botproto.Contact")
	proto.RegisterType((*Location)(nil), "botproto.Location")
	proto.RegisterType((*Venue)(nil), "botproto.Venue")
	proto.RegisterType((*PollOption)(nil), "botproto.PollOption")
	proto.RegisterType((*Poll)(nil), "botproto.Poll")
	proto.RegisterType((*UserProfilePhotos)(nil), "botproto.UserProfilePhotos")
	proto.RegisterType((*File)(nil), "botproto.File")
	proto.RegisterType((*ReplyKeyboardMarkup)(nil), "botproto.ReplyKeyboardMarkup")
	proto.RegisterType((*KeyboardButton)(nil), "botproto.KeyboardButton")
	proto.RegisterType((*ReplyKeyboardRemove)(nil), "botproto.ReplyKeyboardRemove")
	proto.RegisterType((*InlineKeyboardMarkup)(nil), "botproto.InlineKeyboardMarkup")
	proto.RegisterType((*InlineKeyboardButton)(nil), "botproto.InlineKeyboardButton")
	proto.RegisterType((*LoginUrl)(nil), "botproto.LoginUrl")
	proto.RegisterType((*CallbackQuery)(nil), "botproto.CallbackQuery")
	proto.RegisterType((*ForceReply)(nil), "botproto.ForceReply")
	proto.RegisterType((*ChatPhoto)(nil), "botproto.ChatPhoto")
	proto.RegisterType((*ChatMember)(nil), "botproto.ChatMember")
	proto.RegisterType((*ChatPermissions)(nil), "botproto.ChatPermissions")
	proto.RegisterType((*ResponseParameters)(nil), "botproto.ResponseParameters")
	proto.RegisterType((*InputMedia)(nil), "botproto.InputMedia")
	proto.RegisterType((*InputMediaPhoto)(nil), "botproto.InputMediaPhoto")
	proto.RegisterType((*InputMediaVideo)(nil), "botproto.InputMediaVideo")
	proto.RegisterType((*InputMediaAnimation)(nil), "botproto.InputMediaAnimation")
	proto.RegisterType((*InputMediaAudio)(nil), "botproto.InputMediaAudio")
	proto.RegisterType((*InputMediaDocument)(nil), "botproto.InputMediaDocument")
	proto.RegisterType((*InputFile)(nil), "botproto.InputFile")
	proto.RegisterType((*AnswerCallbackQuery)(nil), "botproto.answerCallbackQuery")
	proto.RegisterType((*Sticker)(nil), "botproto.Sticker")
	proto.RegisterType((*StickerSet)(nil), "botproto.StickerSet")
	proto.RegisterType((*MaskPosition)(nil), "botproto.MaskPosition")
	proto.RegisterType((*AddStickerToSet)(nil), "botproto.addStickerToSet")
	proto.RegisterType((*AnswerShippingQuery)(nil), "botproto.answerShippingQuery")
	proto.RegisterType((*AnswerPreCheckoutQuery)(nil), "botproto.answerPreCheckoutQuery")
	proto.RegisterType((*LabeledPrice)(nil), "botproto.LabeledPrice")
	proto.RegisterType((*Invoice)(nil), "botproto.Invoice")
	proto.RegisterType((*ShippingAddress)(nil), "botproto.ShippingAddress")
	proto.RegisterType((*OrderInfo)(nil), "botproto.OrderInfo")
	proto.RegisterType((*ShippingOption)(nil), "botproto.ShippingOption")
	proto.RegisterType((*SuccessfulPayment)(nil), "botproto.SuccessfulPayment")
	proto.RegisterType((*ShippingQuery)(nil), "botproto.ShippingQuery")
	proto.RegisterType((*PreCheckoutQuery)(nil), "botproto.PreCheckoutQuery")
	proto.RegisterType((*PassportData)(nil), "botproto.PassportData")
	proto.RegisterType((*PassportFile)(nil), "botproto.PassportFile")
	proto.RegisterType((*EncryptedPassportElement)(nil), "botproto.EncryptedPassportElement")
	proto.RegisterType((*EncryptedCredentials)(nil), "botproto.EncryptedCredentials")
	proto.RegisterType((*PassportElementError)(nil), "botproto.PassportElementError")
	proto.RegisterType((*PassportElementErrorDataField)(nil), "botproto.PassportElementErrorDataField")
	proto.RegisterType((*PassportElementErrorFrontSide)(nil), "botproto.PassportElementErrorFrontSide")
	proto.RegisterType((*PassportElementErrorReverseSide)(nil), "botproto.PassportElementErrorReverseSide")
	proto.RegisterType((*PassportElementErrorSelfie)(nil), "botproto.PassportElementErrorSelfie")
	proto.RegisterType((*PassportElementErrorFile)(nil), "botproto.PassportElementErrorFile")
	proto.RegisterType((*PassportElementErrorFiles)(nil), "botproto.PassportElementErrorFiles")
	proto.RegisterType((*PassportElementErrorTranslationFile)(nil), "botproto.PassportElementErrorTranslationFile")
	proto.RegisterType((*PassportElementErrorTranslationFiles)(nil), "botproto.PassportElementErrorTranslationFiles")
	proto.RegisterType((*PassportElementErrorUnspecified)(nil), "botproto.PassportElementErrorUnspecified")
	proto.RegisterType((*Game)(nil), "botproto.Game")
	proto.RegisterType((*CallbackGame)(nil), "botproto.CallbackGame")
	proto.RegisterType((*GameHighScore)(nil), "botproto.GameHighScore")
	proto.RegisterType((*ReplyMarkup)(nil), "botproto.ReplyMarkup")
}
func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Id))
	}
	if m.IsBot {
		dAtA[i] = 0x10
		i++
		if m.IsBot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.LanguageCode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LanguageCode)))
		i += copy(dAtA[i:], m.LanguageCode)
	}
	return i, nil
}

func (m *Chat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Id))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.Photo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Photo.Size()))
		n1, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.InviteLink) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InviteLink)))
		i += copy(dAtA[i:], m.InviteLink)
	}
	if m.PinnedMessage != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.PinnedMessage.Size()))
		n2, err := m.PinnedMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Permissions != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Permissions.Size()))
		n3, err := m.Permissions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.StickerSetName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.StickerSetName)))
		i += copy(dAtA[i:], m.StickerSetName)
	}
	if m.CanSetStickerSet {
		dAtA[i] = 0x68
		i++
		if m.CanSetStickerSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MessageId))
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.From.Size()))
		n4, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Date != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Date))
	}
	if m.Chat != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Chat.Size()))
		n5, err := m.Chat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ForwardFrom != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ForwardFrom.Size()))
		n6, err := m.ForwardFrom.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ForwardFromChat != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ForwardFromChat.Size()))
		n7, err := m.ForwardFromChat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ForwardFromMessageId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ForwardFromMessageId))
	}
	if len(m.ForwardSignature) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ForwardSignature)))
		i += copy(dAtA[i:], m.ForwardSignature)
	}
	if len(m.ForwardSenderName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ForwardSenderName)))
		i += copy(dAtA[i:], m.ForwardSenderName)
	}
	if m.ForwardDate != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ForwardDate))
	}
	if m.ReplyToMessage != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyToMessage.Size()))
		n8, err := m.ReplyToMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.EditDate != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.EditDate))
	}
	if len(m.MediaGroupId) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MediaGroupId)))
		i += copy(dAtA[i:], m.MediaGroupId)
	}
	if len(m.AuthorSignature) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.AuthorSignature)))
		i += copy(dAtA[i:], m.AuthorSignature)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.Entities) > 0 {
		for _, msg := range m.Entities {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CaptionEntities) > 0 {
		for _, msg := range m.CaptionEntities {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Audio != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Audio.Size()))
		n9, err := m.Audio.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Document != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Document.Size()))
		n10, err := m.Document.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Animation != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Animation.Size()))
		n11, err := m.Animation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Game != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Game.Size()))
		n12, err := m.Game.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Photo) > 0 {
		for _, msg := range m.Photo {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Sticker != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Sticker.Size()))
		n13, err := m.Sticker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Video != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Video.Size()))
		n14, err := m.Video.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Voice != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Voice.Size()))
		n15, err := m.Voice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.VideoNote != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.VideoNote.Size()))
		n16, err := m.VideoNote.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if m.Contact != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Contact.Size()))
		n17, err := m.Contact.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Location != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Location.Size()))
		n18, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Venue != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Venue.Size()))
		n19, err := m.Venue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Poll != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Poll.Size()))
		n20, err := m.Poll.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.NewChatMembers) > 0 {
		for _, msg := range m.NewChatMembers {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LeftChatMember != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.LeftChatMember.Size()))
		n21, err := m.LeftChatMember.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.NewChatTitle) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.NewChatTitle)))
		i += copy(dAtA[i:], m.NewChatTitle)
	}
	if len(m.NewChatPhoto) > 0 {
		for _, msg := range m.NewChatPhoto {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DeleteChatPhoto {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		if m.DeleteChatPhoto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GroupChatCreated {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		if m.GroupChatCreated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SupergroupChatCreated {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if m.SupergroupChatCreated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ChannelChatCreated {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		if m.ChannelChatCreated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MigrateToChatId != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MigrateToChatId))
	}
	if m.MigrateFromChatId != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MigrateFromChatId))
	}
	if m.PinnedMessage != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.PinnedMessage.Size()))
		n22, err := m.PinnedMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Invoice != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Invoice.Size()))
		n23, err := m.Invoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.SuccessfulPayment != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.SuccessfulPayment.Size()))
		n24, err := m.SuccessfulPayment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.ConnectedWebsite) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ConnectedWebsite)))
		i += copy(dAtA[i:], m.ConnectedWebsite)
	}
	if m.PassportData != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.PassportData.Size()))
		n25, err := m.PassportData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n26, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *MessageEntity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageEntity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Offset))
	}
	if m.Length != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Length))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.User != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.User.Size()))
		n27, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *PhotoSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoSize) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *Audio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Audio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if len(m.Performer) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Performer)))
		i += copy(dAtA[i:], m.Performer)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	if m.Thumb != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n28, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Document) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Thumb != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n29, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.FileName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *Video) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Video) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if m.Thumb != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n30, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *Animation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Animation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if m.Thumb != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n31, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.FileName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *Voice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Voice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *VideoNote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoNote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Length))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if m.Thumb != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n32, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *Contact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.UserId))
	}
	if len(m.Vcard) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Vcard)))
		i += copy(dAtA[i:], m.Vcard)
	}
	return i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Longitude != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Longitude))
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Latitude))
	}
	return i, nil
}

func (m *Venue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Venue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Location.Size()))
		n33, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.FoursquareId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FoursquareId)))
		i += copy(dAtA[i:], m.FoursquareId)
	}
	if len(m.FoursquareType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FoursquareType)))
		i += copy(dAtA[i:], m.FoursquareType)
	}
	return i, nil
}

func (m *PollOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PollOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.VoterCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.VoterCount))
	}
	return i, nil
}

func (m *Poll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Poll) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Question) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Question)))
		i += copy(dAtA[i:], m.Question)
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsClosed {
		dAtA[i] = 0x20
		i++
		if m.IsClosed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UserProfilePhotos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserProfilePhotos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.TotalCount))
	}
	if len(m.Photos) > 0 {
		for _, msg := range m.Photos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	if len(m.FilePath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FilePath)))
		i += copy(dAtA[i:], m.FilePath)
	}
	return i, nil
}

func (m *ReplyKeyboardMarkup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyKeyboardMarkup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyboard) > 0 {
		for _, msg := range m.Keyboard {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ResizeKeyboard {
		dAtA[i] = 0x10
		i++
		if m.ResizeKeyboard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OneTimeKeyboard {
		dAtA[i] = 0x18
		i++
		if m.OneTimeKeyboard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Selective {
		dAtA[i] = 0x20
		i++
		if m.Selective {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *KeyboardButton) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyboardButton) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.RequestContact {
		dAtA[i] = 0x10
		i++
		if m.RequestContact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RequestLocation {
		dAtA[i] = 0x18
		i++
		if m.RequestLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReplyKeyboardRemove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyKeyboardRemove) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RemoveKeyboard {
		dAtA[i] = 0x8
		i++
		if m.RemoveKeyboard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Selective {
		dAtA[i] = 0x10
		i++
		if m.Selective {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InlineKeyboardMarkup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineKeyboardMarkup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InlineKeyboard) > 0 {
		for _, msg := range m.InlineKeyboard {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InlineKeyboardButton) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineKeyboardButton) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.LoginUrl != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.LoginUrl.Size()))
		n34, err := m.LoginUrl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.CallbackData) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.CallbackData)))
		i += copy(dAtA[i:], m.CallbackData)
	}
	if len(m.SwitchInlineQuery) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.SwitchInlineQuery)))
		i += copy(dAtA[i:], m.SwitchInlineQuery)
	}
	if len(m.SwitchInlineQueryCurrentChat) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.SwitchInlineQueryCurrentChat)))
		i += copy(dAtA[i:], m.SwitchInlineQueryCurrentChat)
	}
	if m.CallbackGame != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.CallbackGame.Size()))
		n35, err := m.CallbackGame.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Pay {
		dAtA[i] = 0x40
		i++
		if m.Pay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LoginUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginUrl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.ForwardText) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ForwardText)))
		i += copy(dAtA[i:], m.ForwardText)
	}
	if len(m.BotUsername) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.BotUsername)))
		i += copy(dAtA[i:], m.BotUsername)
	}
	if m.RequestWriteAccess {
		dAtA[i] = 0x20
		i++
		if m.RequestWriteAccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CallbackQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallbackQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.From.Size()))
		n36, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Message != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Message.Size()))
		n37, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.InlineMessageId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InlineMessageId)))
		i += copy(dAtA[i:], m.InlineMessageId)
	}
	if len(m.ChatInstance) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ChatInstance)))
		i += copy(dAtA[i:], m.ChatInstance)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.GameShortName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.GameShortName)))
		i += copy(dAtA[i:], m.GameShortName)
	}
	return i, nil
}

func (m *ForceReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForceReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ForceReply {
		dAtA[i] = 0x8
		i++
		if m.ForceReply {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Selective {
		dAtA[i] = 0x10
		i++
		if m.Selective {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChatPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SmallFileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.SmallFileId)))
		i += copy(dAtA[i:], m.SmallFileId)
	}
	if len(m.BigFileId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.BigFileId)))
		i += copy(dAtA[i:], m.BigFileId)
	}
	return i, nil
}

func (m *ChatMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.User.Size()))
		n38, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.UntilDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.UntilDate))
	}
	if m.CanBeEdited {
		dAtA[i] = 0x20
		i++
		if m.CanBeEdited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPostMessages {
		dAtA[i] = 0x28
		i++
		if m.CanPostMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanEditMessages {
		dAtA[i] = 0x30
		i++
		if m.CanEditMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanDeleteMessages {
		dAtA[i] = 0x38
		i++
		if m.CanDeleteMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanRestrictMembers {
		dAtA[i] = 0x40
		i++
		if m.CanRestrictMembers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPromoteMembers {
		dAtA[i] = 0x48
		i++
		if m.CanPromoteMembers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanChangeInfo {
		dAtA[i] = 0x50
		i++
		if m.CanChangeInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanInviteUsers {
		dAtA[i] = 0x58
		i++
		if m.CanInviteUsers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPinMessages {
		dAtA[i] = 0x60
		i++
		if m.CanPinMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsMember {
		dAtA[i] = 0x68
		i++
		if m.IsMember {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendMessages {
		dAtA[i] = 0x70
		i++
		if m.CanSendMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendMediaMessages {
		dAtA[i] = 0x78
		i++
		if m.CanSendMediaMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendPolls {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.CanSendPolls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendOtherMessages {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.CanSendOtherMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanAddWebPagePreviews {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.CanAddWebPagePreviews {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChatPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatPermissions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CanSendMessages {
		dAtA[i] = 0x8
		i++
		if m.CanSendMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendMediaMessages {
		dAtA[i] = 0x10
		i++
		if m.CanSendMediaMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendPolls {
		dAtA[i] = 0x18
		i++
		if m.CanSendPolls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendOtherMessages {
		dAtA[i] = 0x20
		i++
		if m.CanSendOtherMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanAddWebPagePreviews {
		dAtA[i] = 0x28
		i++
		if m.CanAddWebPagePreviews {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanChangeInfo {
		dAtA[i] = 0x30
		i++
		if m.CanChangeInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanInviteUsers {
		dAtA[i] = 0x38
		i++
		if m.CanInviteUsers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPinMessages {
		dAtA[i] = 0x40
		i++
		if m.CanPinMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ResponseParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseParameters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MigrateToChatId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MigrateToChatId))
	}
	if m.RetryAfter != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.RetryAfter))
	}
	return i, nil
}

func (m *InputMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMedia) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *InputMediaPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	return i, nil
}

func (m *InputMediaVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaVideo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.Width != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if m.SupportsStreaming {
		dAtA[i] = 0x48
		i++
		if m.SupportsStreaming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InputMediaAnimation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaAnimation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.Width != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *InputMediaAudio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaAudio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if len(m.Performer) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Performer)))
		i += copy(dAtA[i:], m.Performer)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	return i, nil
}

func (m *InputMediaDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	return i, nil
}

func (m *InputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AnswerCallbackQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnswerCallbackQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallbackQueryId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.CallbackQueryId)))
		i += copy(dAtA[i:], m.CallbackQueryId)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.ShowAlert {
		dAtA[i] = 0x18
		i++
		if m.ShowAlert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.CacheTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.CacheTime))
	}
	return i, nil
}

func (m *Sticker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sticker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.IsAnimated {
		dAtA[i] = 0x20
		i++
		if m.IsAnimated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Thumb != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n39, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.Emoji) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Emoji)))
		i += copy(dAtA[i:], m.Emoji)
	}
	if len(m.SetName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.SetName)))
		i += copy(dAtA[i:], m.SetName)
	}
	if m.MaskPosition != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MaskPosition.Size()))
		n40, err := m.MaskPosition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *StickerSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickerSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.IsAnimated {
		dAtA[i] = 0x18
		i++
		if m.IsAnimated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ContainsMasks {
		dAtA[i] = 0x20
		i++
		if m.ContainsMasks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Stickers) > 0 {
		for _, msg := range m.Stickers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MaskPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaskPosition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Point) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Point)))
		i += copy(dAtA[i:], m.Point)
	}
	if m.XShift != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.XShift))
	}
	if m.YShift != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.YShift))
	}
	if m.Scale != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Scale))
	}
	return i, nil
}

func (m *AddStickerToSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddStickerToSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.UserId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PngSticker) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PngSticker)))
		i += copy(dAtA[i:], m.PngSticker)
	}
	if len(m.Emojis) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Emojis)))
		i += copy(dAtA[i:], m.Emojis)
	}
	if m.MaskPosition != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MaskPosition.Size()))
		n41, err := m.MaskPosition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *AnswerShippingQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnswerShippingQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ShippingQueryId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ShippingQueryId)))
		i += copy(dAtA[i:], m.ShippingQueryId)
	}
	if m.Ok {
		dAtA[i] = 0x10
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ShippingOptions) > 0 {
		for _, msg := range m.ShippingOptions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	return i, nil
}

func (m *AnswerPreCheckoutQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnswerPreCheckoutQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PreCheckoutQueryId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PreCheckoutQueryId)))
		i += copy(dAtA[i:], m.PreCheckoutQueryId)
	}
	if m.Ok {
		dAtA[i] = 0x10
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	return i, nil
}

func (m *LabeledPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabeledPrice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Amount))
	}
	return i, nil
}

func (m *Invoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Invoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.StartParameter) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.StartParameter)))
		i += copy(dAtA[i:], m.StartParameter)
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if m.TotalAmount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.TotalAmount))
	}
	return i, nil
}

func (m *ShippingAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShippingAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CountryCode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.CountryCode)))
		i += copy(dAtA[i:], m.CountryCode)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.StreetLine1) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.StreetLine1)))
		i += copy(dAtA[i:], m.StreetLine1)
	}
	if len(m.StreetLine2) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.StreetLine2)))
		i += copy(dAtA[i:], m.StreetLine2)
	}
	if len(m.PostCode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PostCode)))
		i += copy(dAtA[i:], m.PostCode)
	}
	return i, nil
}

func (m *OrderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.ShippingAddress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ShippingAddress.Size()))
		n42, err := m.ShippingAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *ShippingOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShippingOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Prices) > 0 {
		for _, msg := range m.Prices {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SuccessfulPayment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessfulPayment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Currency) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if m.TotalAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.TotalAmount))
	}
	if len(m.InvoicePayload) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InvoicePayload)))
		i += copy(dAtA[i:], m.InvoicePayload)
	}
	if len(m.ShippingOptionId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ShippingOptionId)))
		i += copy(dAtA[i:], m.ShippingOptionId)
	}
	if m.OrderInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.OrderInfo.Size()))
		n43, err := m.OrderInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.TelegramPaymentChargeId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.TelegramPaymentChargeId)))
		i += copy(dAtA[i:], m.TelegramPaymentChargeId)
	}
	if len(m.ProviderPaymentChargeId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ProviderPaymentChargeId)))
		i += copy(dAtA[i:], m.ProviderPaymentChargeId)
	}
	return i, nil
}

func (m *ShippingQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShippingQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.From.Size()))
		n44, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.InvoicePayload) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InvoicePayload)))
		i += copy(dAtA[i:], m.InvoicePayload)
	}
	if m.ShippingAddress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ShippingAddress.Size()))
		n45, err := m.ShippingAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *PreCheckoutQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreCheckoutQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.From.Size()))
		n46, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if m.TotalAmount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.TotalAmount))
	}
	if len(m.InvoicePayload) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InvoicePayload)))
		i += copy(dAtA[i:], m.InvoicePayload)
	}
	if len(m.ShippingOptionId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ShippingOptionId)))
		i += copy(dAtA[i:], m.ShippingOptionId)
	}
	if m.OrderInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.OrderInfo.Size()))
		n47, err := m.OrderInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *PassportData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Credentials != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Credentials.Size()))
		n48, err := m.Credentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}

func (m *PassportFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	if m.FileDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileDate))
	}
	return i, nil
}

func (m *EncryptedPassportElement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedPassportElement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FrontSide != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FrontSide.Size()))
		n49, err := m.FrontSide.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.ReverseSide != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReverseSide.Size()))
		n50, err := m.ReverseSide.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.Selfie != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Selfie.Size()))
		n51, err := m.Selfie.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if len(m.Translation) > 0 {
		for _, msg := range m.Translation {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	return i, nil
}

func (m *EncryptedCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedCredentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if len(m.Secret) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	return i, nil
}

func (m *PassportElementError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PassportElementErrorDataField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorDataField) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FieldName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FieldName)))
		i += copy(dAtA[i:], m.FieldName)
	}
	if len(m.DataHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.DataHash)))
		i += copy(dAtA[i:], m.DataHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorFrontSide) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorFrontSide) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorReverseSide) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorReverseSide) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorSelfie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorSelfie) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorFiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorFiles) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHashes) > 0 {
		for _, s := range m.FileHashes {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorTranslationFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorTranslationFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorTranslationFiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorTranslationFiles) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHashes) > 0 {
		for _, s := range m.FileHashes {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorUnspecified) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorUnspecified) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.ElementHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ElementHash)))
		i += copy(dAtA[i:], m.ElementHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *Game) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Game) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Photo) > 0 {
		for _, msg := range m.Photo {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.TextEntities) > 0 {
		for _, msg := range m.TextEntities {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Animation != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Animation.Size()))
		n52, err := m.Animation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	return i, nil
}

func (m *CallbackGame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallbackGame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GameHighScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameHighScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Position))
	}
	if m.User != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.User.Size()))
		n53, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *ReplyMarkup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyMarkup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyMarkup != nil {
		nn54, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn54
	}
	return i, nil
}

func (m *ReplyMarkup_InlineKeyboardMarkup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InlineKeyboardMarkup != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InlineKeyboardMarkup.Size()))
		n55, err := m.InlineKeyboardMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}
func (m *ReplyMarkup_ReplyKeyboardMarkup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ReplyKeyboardMarkup != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyKeyboardMarkup.Size()))
		n56, err := m.ReplyKeyboardMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}
func (m *ReplyMarkup_ReplyKeyboardRemove) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ReplyKeyboardRemove != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyKeyboardRemove.Size()))
		n57, err := m.ReplyKeyboardRemove.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}
func (m *ReplyMarkup_ForceReply) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ForceReply != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ForceReply.Size()))
		n58, err := m.ForceReply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}
func encodeFixed64Tgbotapi(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Tgbotapi(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTgbotapi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *User) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTgbotapi(uint64(m.Id))
	}
	if m.IsBot {
		n += 2
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.LanguageCode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *Chat) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTgbotapi(uint64(m.Id))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.InviteLink)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.PinnedMessage != nil {
		l = m.PinnedMessage.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.StickerSetName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.CanSetStickerSet {
		n += 2
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.MessageId != 0 {
		n += 1 + sovTgbotapi(uint64(m.MessageId))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Date != 0 {
		n += 1 + sovTgbotapi(uint64(m.Date))
	}
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ForwardFrom != nil {
		l = m.ForwardFrom.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ForwardFromChat != nil {
		l = m.ForwardFromChat.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ForwardFromMessageId != 0 {
		n += 1 + sovTgbotapi(uint64(m.ForwardFromMessageId))
	}
	l = len(m.ForwardSignature)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ForwardSenderName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ForwardDate != 0 {
		n += 1 + sovTgbotapi(uint64(m.ForwardDate))
	}
	if m.ReplyToMessage != nil {
		l = m.ReplyToMessage.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.EditDate != 0 {
		n += 1 + sovTgbotapi(uint64(m.EditDate))
	}
	l = len(m.MediaGroupId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.AuthorSignature)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 2 + l + sovTgbotapi(uint64(l))
		}
	}
	if len(m.CaptionEntities) > 0 {
		for _, e := range m.CaptionEntities {
			l = e.Size()
			n += 2 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.Audio != nil {
		l = m.Audio.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Document != nil {
		l = m.Document.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Animation != nil {
		l = m.Animation.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Game != nil {
		l = m.Game.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Photo) > 0 {
		for _, e := range m.Photo {
			l = e.Size()
			n += 2 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.Sticker != nil {
		l = m.Sticker.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Voice != nil {
		l = m.Voice.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.VideoNote != nil {
		l = m.VideoNote.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Contact != nil {
		l = m.Contact.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Venue != nil {
		l = m.Venue.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Poll != nil {
		l = m.Poll.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if len(m.NewChatMembers) > 0 {
		for _, e := range m.NewChatMembers {
			l = e.Size()
			n += 2 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.LeftChatMember != nil {
		l = m.LeftChatMember.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.NewChatTitle)
	if l > 0 {
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if len(m.NewChatPhoto) > 0 {
		for _, e := range m.NewChatPhoto {
			l = e.Size()
			n += 2 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.DeleteChatPhoto {
		n += 3
	}
	if m.GroupChatCreated {
		n += 3
	}
	if m.SupergroupChatCreated {
		n += 3
	}
	if m.ChannelChatCreated {
		n += 3
	}
	if m.MigrateToChatId != 0 {
		n += 2 + sovTgbotapi(uint64(m.MigrateToChatId))
	}
	if m.MigrateFromChatId != 0 {
		n += 2 + sovTgbotapi(uint64(m.MigrateFromChatId))
	}
	if m.PinnedMessage != nil {
		l = m.PinnedMessage.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Invoice != nil {
		l = m.Invoice.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.SuccessfulPayment != nil {
		l = m.SuccessfulPayment.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ConnectedWebsite)
	if l > 0 {
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.PassportData != nil {
		l = m.PassportData.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *MessageEntity) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovTgbotapi(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovTgbotapi(uint64(m.Length))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PhotoSize) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *Audio) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	l = len(m.Performer)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *Document) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *Video) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *Animation) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *Voice) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *VideoNote) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Length != 0 {
		n += 1 + sovTgbotapi(uint64(m.Length))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *Contact) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovTgbotapi(uint64(m.UserId))
	}
	l = len(m.Vcard)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *Location) Size() (n int) {
	var l int
	_ = l
	if m.Longitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Longitude))
	}
	if m.Latitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Latitude))
	}
	return n
}

func (m *Venue) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FoursquareId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FoursquareType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PollOption) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.VoterCount != 0 {
		n += 1 + sovTgbotapi(uint64(m.VoterCount))
	}
	return n
}

func (m *Poll) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Question)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.IsClosed {
		n += 2
	}
	return n
}

func (m *UserProfilePhotos) Size() (n int) {
	var l int
	_ = l
	if m.TotalCount != 0 {
		n += 1 + sovTgbotapi(uint64(m.TotalCount))
	}
	if len(m.Photos) > 0 {
		for _, e := range m.Photos {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	return n
}

func (m *File) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ReplyKeyboardMarkup) Size() (n int) {
	var l int
	_ = l
	if len(m.Keyboard) > 0 {
		for _, e := range m.Keyboard {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.ResizeKeyboard {
		n += 2
	}
	if m.OneTimeKeyboard {
		n += 2
	}
	if m.Selective {
		n += 2
	}
	return n
}

func (m *KeyboardButton) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.RequestContact {
		n += 2
	}
	if m.RequestLocation {
		n += 2
	}
	return n
}

func (m *ReplyKeyboardRemove) Size() (n int) {
	var l int
	_ = l
	if m.RemoveKeyboard {
		n += 2
	}
	if m.Selective {
		n += 2
	}
	return n
}

func (m *InlineKeyboardMarkup) Size() (n int) {
	var l int
	_ = l
	if len(m.InlineKeyboard) > 0 {
		for _, e := range m.InlineKeyboard {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	return n
}

func (m *InlineKeyboardButton) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.LoginUrl != nil {
		l = m.LoginUrl.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.CallbackData)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.SwitchInlineQuery)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.SwitchInlineQueryCurrentChat)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.CallbackGame != nil {
		l = m.CallbackGame.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Pay {
		n += 2
	}
	return n
}

func (m *LoginUrl) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ForwardText)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.BotUsername)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.RequestWriteAccess {
		n += 2
	}
	return n
}

func (m *CallbackQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.InlineMessageId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ChatInstance)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.GameShortName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ForceReply) Size() (n int) {
	var l int
	_ = l
	if m.ForceReply {
		n += 2
	}
	if m.Selective {
		n += 2
	}
	return n
}

func (m *ChatPhoto) Size() (n int) {
	var l int
	_ = l
	l = len(m.SmallFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.BigFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ChatMember) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.UntilDate != 0 {
		n += 1 + sovTgbotapi(uint64(m.UntilDate))
	}
	if m.CanBeEdited {
		n += 2
	}
	if m.CanPostMessages {
		n += 2
	}
	if m.CanEditMessages {
		n += 2
	}
	if m.CanDeleteMessages {
		n += 2
	}
	if m.CanRestrictMembers {
		n += 2
	}
	if m.CanPromoteMembers {
		n += 2
	}
	if m.CanChangeInfo {
		n += 2
	}
	if m.CanInviteUsers {
		n += 2
	}
	if m.CanPinMessages {
		n += 2
	}
	if m.IsMember {
		n += 2
	}
	if m.CanSendMessages {
		n += 2
	}
	if m.CanSendMediaMessages {
		n += 2
	}
	if m.CanSendPolls {
		n += 3
	}
	if m.CanSendOtherMessages {
		n += 3
	}
	if m.CanAddWebPagePreviews {
		n += 3
	}
	return n
}

func (m *ChatPermissions) Size() (n int) {
	var l int
	_ = l
	if m.CanSendMessages {
		n += 2
	}
	if m.CanSendMediaMessages {
		n += 2
	}
	if m.CanSendPolls {
		n += 2
	}
	if m.CanSendOtherMessages {
		n += 2
	}
	if m.CanAddWebPagePreviews {
		n += 2
	}
	if m.CanChangeInfo {
		n += 2
	}
	if m.CanInviteUsers {
		n += 2
	}
	if m.CanPinMessages {
		n += 2
	}
	return n
}

func (m *ResponseParameters) Size() (n int) {
	var l int
	_ = l
	if m.MigrateToChatId != 0 {
		n += 1 + sovTgbotapi(uint64(m.MigrateToChatId))
	}
	if m.RetryAfter != 0 {
		n += 1 + sovTgbotapi(uint64(m.RetryAfter))
	}
	return n
}

func (m *InputMedia) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *InputMediaPhoto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InputMediaVideo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	if m.SupportsStreaming {
		n += 2
	}
	return n
}

func (m *InputMediaAnimation) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	return n
}

func (m *InputMediaAudio) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	l = len(m.Performer)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InputMediaDocument) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InputFile) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AnswerCallbackQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.CallbackQueryId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ShowAlert {
		n += 2
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.CacheTime != 0 {
		n += 1 + sovTgbotapi(uint64(m.CacheTime))
	}
	return n
}

func (m *Sticker) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.IsAnimated {
		n += 2
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Emoji)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.SetName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.MaskPosition != nil {
		l = m.MaskPosition.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *StickerSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.IsAnimated {
		n += 2
	}
	if m.ContainsMasks {
		n += 2
	}
	if len(m.Stickers) > 0 {
		for _, e := range m.Stickers {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	return n
}

func (m *MaskPosition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Point)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.XShift != 0 {
		n += 1 + sovTgbotapi(uint64(m.XShift))
	}
	if m.YShift != 0 {
		n += 1 + sovTgbotapi(uint64(m.YShift))
	}
	if m.Scale != 0 {
		n += 1 + sovTgbotapi(uint64(m.Scale))
	}
	return n
}

func (m *AddStickerToSet) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovTgbotapi(uint64(m.UserId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PngSticker)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Emojis)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.MaskPosition != nil {
		l = m.MaskPosition.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *AnswerShippingQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.ShippingQueryId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Ok {
		n += 2
	}
	if len(m.ShippingOptions) > 0 {
		for _, e := range m.ShippingOptions {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *AnswerPreCheckoutQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.PreCheckoutQueryId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Ok {
		n += 2
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *LabeledPrice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovTgbotapi(uint64(m.Amount))
	}
	return n
}

func (m *Invoice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.StartParameter)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.TotalAmount != 0 {
		n += 1 + sovTgbotapi(uint64(m.TotalAmount))
	}
	return n
}

func (m *ShippingAddress) Size() (n int) {
	var l int
	_ = l
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.StreetLine1)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.StreetLine2)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PostCode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *OrderInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ShippingAddress != nil {
		l = m.ShippingAddress.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ShippingOption) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Prices) > 0 {
		for _, e := range m.Prices {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	return n
}

func (m *SuccessfulPayment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.TotalAmount != 0 {
		n += 1 + sovTgbotapi(uint64(m.TotalAmount))
	}
	l = len(m.InvoicePayload)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ShippingOptionId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.OrderInfo != nil {
		l = m.OrderInfo.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.TelegramPaymentChargeId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ProviderPaymentChargeId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ShippingQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.InvoicePayload)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ShippingAddress != nil {
		l = m.ShippingAddress.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PreCheckoutQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.TotalAmount != 0 {
		n += 1 + sovTgbotapi(uint64(m.TotalAmount))
	}
	l = len(m.InvoicePayload)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ShippingOptionId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.OrderInfo != nil {
		l = m.OrderInfo.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportData) Size() (n int) {
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportFile) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	if m.FileDate != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileDate))
	}
	return n
}

func (m *EncryptedPassportElement) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.FrontSide != nil {
		l = m.FrontSide.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReverseSide != nil {
		l = m.ReverseSide.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Selfie != nil {
		l = m.Selfie.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Translation) > 0 {
		for _, e := range m.Translation {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *EncryptedCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementError) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PassportElementErrorDataField) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FieldName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.DataHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorFrontSide) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorReverseSide) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorSelfie) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorFile) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorFiles) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.FileHashes) > 0 {
		for _, s := range m.FileHashes {
			l = len(s)
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorTranslationFile) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorTranslationFiles) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.FileHashes) > 0 {
		for _, s := range m.FileHashes {
			l = len(s)
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorUnspecified) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ElementHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *Game) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Photo) > 0 {
		for _, e := range m.Photo {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.TextEntities) > 0 {
		for _, e := range m.TextEntities {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.Animation != nil {
		l = m.Animation.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *CallbackGame) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GameHighScore) Size() (n int) {
	var l int
	_ = l
	if m.Position != 0 {
		n += 1 + sovTgbotapi(uint64(m.Position))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovTgbotapi(uint64(m.Score))
	}
	return n
}

func (m *ReplyMarkup) Size() (n int) {
	var l int
	_ = l
	if m.ReplyMarkup != nil {
		n += m.ReplyMarkup.Size()
	}
	return n
}

func (m *ReplyMarkup_InlineKeyboardMarkup) Size() (n int) {
	var l int
	_ = l
	if m.InlineKeyboardMarkup != nil {
		l = m.InlineKeyboardMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *ReplyMarkup_ReplyKeyboardMarkup) Size() (n int) {
	var l int
	_ = l
	if m.ReplyKeyboardMarkup != nil {
		l = m.ReplyKeyboardMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *ReplyMarkup_ReplyKeyboardRemove) Size() (n int) {
	var l int
	_ = l
	if m.ReplyKeyboardRemove != nil {
		l = m.ReplyKeyboardRemove.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *ReplyMarkup_ForceReply) Size() (n int) {
	var l int
	_ = l
	if m.ForceReply != nil {
		l = m.ForceReply.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func sovTgbotapi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTgbotapi(x uint64) (n int) {
	return sovTgbotapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBot = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LanguageCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LanguageCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &ChatPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InviteLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PinnedMessage == nil {
				m.PinnedMessage = &Message{}
			}
			if err := m.PinnedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &ChatPermissions{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerSetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StickerSetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSetStickerSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSetStickerSet = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &User{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &Chat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForwardFrom == nil {
				m.ForwardFrom = &User{}
			}
			if err := m.ForwardFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardFromChat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForwardFromChat == nil {
				m.ForwardFromChat = &Chat{}
			}
			if err := m.ForwardFromChat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardFromMessageId", wireType)
			}
			m.ForwardFromMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardFromMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardSenderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardSenderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardDate", wireType)
			}
			m.ForwardDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyToMessage == nil {
				m.ReplyToMessage = &Message{}
			}
			if err := m.ReplyToMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDate", wireType)
			}
			m.EditDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaGroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaGroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptionEntities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptionEntities = append(m.CaptionEntities, &MessageEntity{})
			if err := m.CaptionEntities[len(m.CaptionEntities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Audio == nil {
				m.Audio = &Audio{}
			}
			if err := m.Audio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Document == nil {
				m.Document = &Document{}
			}
			if err := m.Document.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Animation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Animation == nil {
				m.Animation = &Animation{}
			}
			if err := m.Animation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Game", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Game == nil {
				m.Game = &Game{}
			}
			if err := m.Game.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = append(m.Photo, &PhotoSize{})
			if err := m.Photo[len(m.Photo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sticker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sticker == nil {
				m.Sticker = &Sticker{}
			}
			if err := m.Sticker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &Video{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Voice == nil {
				m.Voice = &Voice{}
			}
			if err := m.Voice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoNote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VideoNote == nil {
				m.VideoNote = &VideoNote{}
			}
			if err := m.VideoNote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contact == nil {
				m.Contact = &Contact{}
			}
			if err := m.Contact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Venue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Venue == nil {
				m.Venue = &Venue{}
			}
			if err := m.Venue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Poll == nil {
				m.Poll = &Poll{}
			}
			if err := m.Poll.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewChatMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewChatMembers = append(m.NewChatMembers, &User{})
			if err := m.NewChatMembers[len(m.NewChatMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftChatMember", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftChatMember == nil {
				m.LeftChatMember = &User{}
			}
			if err := m.LeftChatMember.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewChatTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewChatTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewChatPhoto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewChatPhoto = append(m.NewChatPhoto, &PhotoSize{})
			if err := m.NewChatPhoto[len(m.NewChatPhoto)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteChatPhoto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteChatPhoto = bool(v != 0)
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupChatCreated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GroupChatCreated = bool(v != 0)
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupergroupChatCreated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupergroupChatCreated = bool(v != 0)
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelChatCreated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChannelChatCreated = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrateToChatId", wireType)
			}
			m.MigrateToChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrateToChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrateFromChatId", wireType)
			}
			m.MigrateFromChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrateFromChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PinnedMessage == nil {
				m.PinnedMessage = &Message{}
			}
			if err := m.PinnedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invoice == nil {
				m.Invoice = &Invoice{}
			}
			if err := m.Invoice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessfulPayment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuccessfulPayment == nil {
				m.SuccessfulPayment = &SuccessfulPayment{}
			}
			if err := m.SuccessfulPayment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedWebsite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedWebsite = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassportData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PassportData == nil {
				m.PassportData = &PassportData{}
			}
			if err := m.PassportData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageEntity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageEntity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageEntity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhotoSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Audio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Audio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Audio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Performer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Performer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Document) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Video) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Animation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Animation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Animation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Voice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Voice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Voice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoNote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoNote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoNote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vcard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			m.Longitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Venue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Venue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Venue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoursquareId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoursquareId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoursquareType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoursquareType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PollOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PollOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PollOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoterCount", wireType)
			}
			m.VoterCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoterCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Poll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Poll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Poll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Question", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Question = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &PollOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClosed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClosed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserProfilePhotos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserProfilePhotos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserProfilePhotos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photos = append(m.Photos, &PhotoSize{})
			if err := m.Photos[len(m.Photos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyKeyboardMarkup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyKeyboardMarkup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyKeyboardMarkup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyboard = append(m.Keyboard, &KeyboardButton{})
			if err := m.Keyboard[len(m.Keyboard)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResizeKeyboard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResizeKeyboard = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimeKeyboard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneTimeKeyboard = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selective", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Selective = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyboardButton) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyboardButton: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyboardButton: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestContact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestContact = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestLocation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyKeyboardRemove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyKeyboardRemove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyKeyboardRemove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveKeyboard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveKeyboard = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selective", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Selective = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineKeyboardMarkup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineKeyboardMarkup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineKeyboardMarkup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineKeyboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineKeyboard = append(m.InlineKeyboard, &InlineKeyboardButton{})
			if err := m.InlineKeyboard[len(m.InlineKeyboard)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineKeyboardButton) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineKeyboardButton: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineKeyboardButton: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoginUrl == nil {
				m.LoginUrl = &LoginUrl{}
			}
			if err := m.LoginUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallbackData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInlineQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchInlineQuery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInlineQueryCurrentChat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchInlineQueryCurrentChat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackGame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallbackGame == nil {
				m.CallbackGame = &CallbackGame{}
			}
			if err := m.CallbackGame.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BotUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestWriteAccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestWriteAccess = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallbackQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallbackQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallbackQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &User{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatInstance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameShortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameShortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForceReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForceReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForceReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceReply", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceReply = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selective", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Selective = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmallFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UntilDate", wireType)
			}
			m.UntilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UntilDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanBeEdited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanBeEdited = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPostMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPostMessages = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanEditMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanEditMessages = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeleteMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanDeleteMessages = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanRestrictMembers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanRestrictMembers = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPromoteMembers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPromoteMembers = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanChangeInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanChangeInfo = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanInviteUsers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanInviteUsers = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPinMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPinMessages = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMember", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMember = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendMessages = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendMediaMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendMediaMessages = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendPolls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendPolls = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendOtherMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendOtherMessages = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAddWebPagePreviews", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanAddWebPagePreviews = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendMessages = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendMediaMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendMediaMessages = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendPolls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendPolls = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendOtherMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendOtherMessages = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAddWebPagePreviews", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanAddWebPagePreviews = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanChangeInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanChangeInfo = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanInviteUsers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanInviteUsers = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPinMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPinMessages = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrateToChatId", wireType)
			}
			m.MigrateToChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrateToChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryAfter", wireType)
			}
			m.RetryAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryAfter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsStreaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsStreaming = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaAnimation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaAnimation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaAnimation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaAudio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaAudio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaAudio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Performer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Performer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnswerCallbackQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: answerCallbackQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: answerCallbackQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackQueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallbackQueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowAlert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowAlert = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTime", wireType)
			}
			m.CacheTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sticker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sticker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sticker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAnimated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAnimated = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emoji", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emoji = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaskPosition == nil {
				m.MaskPosition = &MaskPosition{}
			}
			if err := m.MaskPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StickerSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickerSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickerSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAnimated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAnimated = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsMasks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainsMasks = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stickers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stickers = append(m.Stickers, &Sticker{})
			if err := m.Stickers[len(m.Stickers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaskPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaskPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaskPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Point = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XShift", wireType)
			}
			m.XShift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XShift |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YShift", wireType)
			}
			m.YShift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YShift |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddStickerToSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: addStickerToSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: addStickerToSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PngSticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PngSticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emojis", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emojis = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaskPosition == nil {
				m.MaskPosition = &MaskPosition{}
			}
			if err := m.MaskPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnswerShippingQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: answerShippingQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: answerShippingQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingQueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingQueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingOptions = append(m.ShippingOptions, &ShippingOption{})
			if err := m.ShippingOptions[len(m.ShippingOptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnswerPreCheckoutQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: answerPreCheckoutQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: answerPreCheckoutQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreCheckoutQueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreCheckoutQueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabeledPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabeledPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabeledPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Invoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Invoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Invoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartParameter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartParameter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			m.TotalAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShippingAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShippingAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShippingAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreetLine1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreetLine1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreetLine2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreetLine2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShippingAddress == nil {
				m.ShippingAddress = &ShippingAddress{}
			}
			if err := m.ShippingAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShippingOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShippingOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShippingOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prices = append(m.Prices, &LabeledPrice{})
			if err := m.Prices[len(m.Prices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessfulPayment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuccessfulPayment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuccessfulPayment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			m.TotalAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoicePayload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoicePayload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingOptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingOptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderInfo == nil {
				m.OrderInfo = &OrderInfo{}
			}
			if err := m.OrderInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelegramPaymentChargeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TelegramPaymentChargeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderPaymentChargeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderPaymentChargeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShippingQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShippingQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShippingQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &User{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoicePayload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoicePayload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShippingAddress == nil {
				m.ShippingAddress = &ShippingAddress{}
			}
			if err := m.ShippingAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreCheckoutQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreCheckoutQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreCheckoutQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &User{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			m.TotalAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoicePayload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoicePayload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingOptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingOptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderInfo == nil {
				m.OrderInfo = &OrderInfo{}
			}
			if err := m.OrderInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &EncryptedPassportElement{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &EncryptedCredentials{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDate", wireType)
			}
			m.FileDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptedPassportElement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedPassportElement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedPassportElement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &PassportFile{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontSide", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FrontSide == nil {
				m.FrontSide = &PassportFile{}
			}
			if err := m.FrontSide.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseSide", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReverseSide == nil {
				m.ReverseSide = &PassportFile{}
			}
			if err := m.ReverseSide.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selfie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selfie == nil {
				m.Selfie = &PassportFile{}
			}
			if err := m.Selfie.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Translation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Translation = append(m.Translation, &PassportFile{})
			if err := m.Translation[len(m.Translation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptedCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorDataField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorDataField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorDataField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorFrontSide) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorFrontSide: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorFrontSide: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorReverseSide) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorReverseSide: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorReverseSide: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorSelfie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorSelfie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorSelfie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorFiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorFiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorFiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHashes = append(m.FileHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorTranslationFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorTranslationFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorTranslationFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorTranslationFiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorTranslationFiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorTranslationFiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHashes = append(m.FileHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorUnspecified) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorUnspecified: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorUnspecified: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElementHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Game) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Game: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Game: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = append(m.Photo, &PhotoSize{})
			if err := m.Photo[len(m.Photo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextEntities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TextEntities = append(m.TextEntities, &MessageEntity{})
			if err := m.TextEntities[len(m.TextEntities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Animation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Animation == nil {
				m.Animation = &Animation{}
			}
			if err := m.Animation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallbackGame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallbackGame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallbackGame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameHighScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameHighScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameHighScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyMarkup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyMarkup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyMarkup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineKeyboardMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InlineKeyboardMarkup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ReplyMarkup = &ReplyMarkup_InlineKeyboardMarkup{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyKeyboardMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplyKeyboardMarkup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ReplyMarkup = &ReplyMarkup_ReplyKeyboardMarkup{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyKeyboardRemove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplyKeyboardRemove{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ReplyMarkup = &ReplyMarkup_ReplyKeyboardRemove{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceReply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ForceReply{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ReplyMarkup = &ReplyMarkup_ForceReply{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTgbotapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTgbotapi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTgbotapi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTgbotapi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTgbotapi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTgbotapi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("tgbotapi.proto", fileDescriptorTgbotapi) }

var fileDescriptorTgbotapi = []byte{
	// 4325 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x7a, 0xcd, 0x8f, 0x24, 0x47,
	0x56, 0xb8, 0xb3, 0xbe, 0xeb, 0x55, 0x75, 0x75, 0x77, 0x4e, 0x7b, 0x26, 0x3d, 0xf6, 0x7c, 0xa5,
	0xbf, 0xc6, 0x3b, 0x76, 0xdb, 0x9e, 0xfd, 0xd9, 0xf2, 0xfe, 0x66, 0x0f, 0xf4, 0xf4, 0xcc, 0xd8,
	0xcd, 0x7a, 0xec, 0x76, 0xf6, 0x78, 0x2d, 0x24, 0xa4, 0x54, 0x74, 0x66, 0x54, 0x55, 0xd0, 0x59,
	0x99, 0xe9, 0x8c, 0xa8, 0xee, 0xe9, 0x95, 0xd0, 0xa2, 0x5d, 0x24, 0x0c, 0xd2, 0x4a, 0x1c, 0x90,
	0x10, 0x17, 0x04, 0x87, 0x15, 0x02, 0x89, 0x0b, 0x82, 0x13, 0x12, 0x12, 0x37, 0x6e, 0xec, 0x85,
	0xcf, 0x13, 0xf2, 0x1f, 0x80, 0xf8, 0x07, 0x90, 0x50, 0xbc, 0x88, 0xc8, 0xcc, 0xca, 0xca, 0xae,
	0xe9, 0xb1, 0xac, 0x59, 0x38, 0x55, 0xc5, 0xfb, 0xc8, 0x78, 0x5f, 0xf1, 0xe2, 0xc5, 0x8b, 0x80,
	0x91, 0x98, 0x1c, 0x26, 0x82, 0xa4, 0x6c, 0x3b, 0xcd, 0x12, 0x91, 0xd8, 0xbd, 0xc3, 0x44, 0xe0,
	0x3f, 0xf7, 0x2f, 0x2c, 0x68, 0x7d, 0xce, 0x69, 0x66, 0x8f, 0xa0, 0xc1, 0x42, 0xc7, 0xba, 0x6e,
	0xdd, 0x6c, 0x7b, 0x0d, 0x16, 0xda, 0xcf, 0x43, 0x87, 0x71, 0xff, 0x30, 0x11, 0x4e, 0xe3, 0xba,
	0x75, 0xb3, 0xe7, 0xb5, 0x19, 0xbf, 0x9b, 0x08, 0xfb, 0x0a, 0xc0, 0x98, 0x65, 0x5c, 0xf8, 0x31,
	0x99, 0x51, 0xa7, 0x79, 0xdd, 0xba, 0xd9, 0xf7, 0xfa, 0x08, 0xf9, 0x84, 0xcc, 0xa8, 0xfd, 0x22,
	0xf4, 0x23, 0x62, 0xb0, 0x2d, 0xc4, 0xf6, 0x24, 0x00, 0x91, 0x97, 0xa1, 0x37, 0xe7, 0x34, 0x43,
	0x5c, 0x5b, 0xe1, 0xcc, 0xd8, 0x7e, 0x19, 0xd6, 0x22, 0x12, 0x4f, 0xe6, 0x64, 0x42, 0xfd, 0x20,
	0x09, 0xa9, 0xd3, 0x41, 0x82, 0xa1, 0x01, 0xee, 0x26, 0x21, 0x75, 0xff, 0xb9, 0x09, 0xad, 0xdd,
	0x29, 0x11, 0x4b, 0xc2, 0xda, 0xd0, 0x12, 0xa7, 0x29, 0x45, 0x51, 0xfb, 0x1e, 0xfe, 0xb7, 0xb7,
	0xa0, 0x2d, 0x98, 0x88, 0x8c, 0x90, 0x6a, 0xb0, 0x20, 0x43, 0xab, 0x22, 0xc3, 0xa2, 0x6e, 0xed,
	0x95, 0xba, 0x75, 0x2a, 0xba, 0xbd, 0x01, 0xed, 0x74, 0x9a, 0x88, 0xc4, 0xe9, 0x5e, 0xb7, 0x6e,
	0x0e, 0x6e, 0x5f, 0xd8, 0x36, 0x16, 0xde, 0x96, 0x02, 0xef, 0x4b, 0x94, 0xa7, 0x28, 0xec, 0xeb,
	0x30, 0x08, 0x29, 0x0f, 0x32, 0x96, 0x0a, 0x96, 0xc4, 0x4e, 0x0f, 0xbf, 0x54, 0x06, 0xd9, 0xd7,
	0x60, 0xc0, 0xe2, 0x63, 0x26, 0xa8, 0x1f, 0xb1, 0xf8, 0xc8, 0xe9, 0x23, 0x05, 0x28, 0xd0, 0xc7,
	0x2c, 0x3e, 0xb2, 0x3f, 0x80, 0x51, 0xca, 0xe2, 0x98, 0x86, 0xfe, 0x8c, 0x72, 0x4e, 0x26, 0xd4,
	0x01, 0x9c, 0x76, 0xb3, 0x98, 0xf6, 0xa1, 0x42, 0x78, 0x6b, 0x8a, 0x50, 0x0f, 0xed, 0x3b, 0x30,
	0x48, 0x69, 0x36, 0x63, 0x9c, 0xb3, 0x24, 0xe6, 0xce, 0x00, 0xd9, 0x5e, 0xa8, 0x48, 0x5b, 0x10,
	0x78, 0x65, 0x6a, 0xfb, 0x26, 0x6c, 0x70, 0xc1, 0x82, 0x23, 0x9a, 0xf9, 0x9c, 0x6a, 0x43, 0x0c,
	0x51, 0xb8, 0x91, 0x86, 0x1f, 0x50, 0x65, 0x8e, 0xb7, 0xe0, 0x42, 0x40, 0x62, 0xa4, 0x2a, 0x71,
	0x38, 0x6b, 0x18, 0x4a, 0x1b, 0x01, 0x89, 0x0f, 0xa8, 0x38, 0xc8, 0x59, 0xdc, 0x9f, 0x6e, 0x42,
	0xd7, 0x48, 0x78, 0x05, 0x40, 0x2b, 0xe5, 0xe7, 0x3e, 0xee, 0x6b, 0xc8, 0x5e, 0x68, 0xbb, 0xd0,
	0x1a, 0x67, 0xc9, 0x0c, 0x5d, 0x3d, 0xb8, 0x3d, 0x2a, 0x24, 0x97, 0x51, 0xec, 0x21, 0x4e, 0x86,
	0x43, 0x48, 0x84, 0xf2, 0x7c, 0xdb, 0xc3, 0xff, 0x92, 0x2f, 0x98, 0x12, 0x81, 0x4e, 0x5f, 0xe0,
	0x93, 0x1a, 0x7b, 0x88, 0xb3, 0xdf, 0x85, 0xe1, 0x38, 0xc9, 0x4e, 0x48, 0x16, 0xfa, 0x38, 0x47,
	0xbb, 0x76, 0x8e, 0x81, 0xa6, 0x79, 0x20, 0xa7, 0xfa, 0xff, 0xb0, 0x59, 0x66, 0xf1, 0x71, 0x8e,
	0x4e, 0xed, 0x1c, 0xeb, 0x25, 0x3e, 0x8c, 0xe2, 0xf7, 0xe0, 0xd2, 0x02, 0x6f, 0x49, 0xed, 0x2e,
	0x4a, 0xbe, 0x55, 0xe2, 0x78, 0x98, 0x5b, 0xe0, 0x56, 0x31, 0x25, 0x67, 0x93, 0x98, 0x88, 0x79,
	0x46, 0x75, 0x14, 0x6d, 0x68, 0xc4, 0x81, 0x81, 0xdb, 0xdb, 0x70, 0x21, 0x27, 0xa6, 0x71, 0x48,
	0x33, 0xe5, 0x35, 0x15, 0x52, 0xe6, 0x3b, 0x07, 0x88, 0x41, 0xc7, 0xdd, 0x28, 0x4c, 0x80, 0x26,
	0x04, 0x14, 0xc4, 0xa8, 0x7c, 0x4f, 0x5a, 0xf2, 0x0e, 0x6c, 0x64, 0x34, 0x8d, 0x4e, 0x7d, 0x91,
	0xe4, 0xe1, 0x37, 0x38, 0x2b, 0xfc, 0x46, 0x48, 0xfa, 0x28, 0x31, 0xde, 0x7d, 0x11, 0xfa, 0x34,
	0x64, 0x42, 0x7d, 0x7c, 0x88, 0x1f, 0xef, 0x49, 0x00, 0x7e, 0xf9, 0x15, 0x18, 0xcd, 0x68, 0xc8,
	0x88, 0x3f, 0xc9, 0x92, 0x79, 0x2a, 0xed, 0xb0, 0xa6, 0xb2, 0x00, 0x42, 0x3f, 0x94, 0xc0, 0xbd,
	0xd0, 0x7e, 0x03, 0x36, 0xc8, 0x5c, 0x4c, 0x93, 0xac, 0xa4, 0xfe, 0x08, 0xe9, 0xd6, 0x15, 0xbc,
	0xd0, 0x5e, 0xe6, 0x05, 0xfa, 0x58, 0x38, 0xeb, 0x3a, 0x2f, 0xd0, 0xc7, 0xc2, 0xfe, 0x2e, 0xf4,
	0x68, 0x2c, 0x98, 0x60, 0x94, 0x3b, 0x1b, 0xd7, 0x9b, 0x37, 0x07, 0xb7, 0x2f, 0x2d, 0x89, 0x7d,
	0x5f, 0x12, 0x9c, 0x7a, 0x39, 0xa1, 0x7d, 0x17, 0x36, 0x02, 0x82, 0x8b, 0xd3, 0xcf, 0x99, 0x37,
	0x57, 0x33, 0xaf, 0x6b, 0x86, 0xfb, 0xe6, 0x1b, 0xaf, 0x42, 0x9b, 0xcc, 0x43, 0x96, 0x38, 0x36,
	0x1a, 0x6b, 0xbd, 0x60, 0xdc, 0x91, 0x60, 0x4f, 0x61, 0xed, 0x6d, 0xe8, 0x85, 0x49, 0x30, 0x9f,
	0xd1, 0x58, 0x38, 0x17, 0x90, 0xd2, 0x2e, 0x28, 0xef, 0x69, 0x8c, 0x97, 0xd3, 0xd8, 0xef, 0x42,
	0x9f, 0xc4, 0x6c, 0x46, 0x30, 0x99, 0x6c, 0x55, 0xb3, 0xcf, 0x8e, 0x41, 0x79, 0x05, 0x95, 0x5c,
	0x0b, 0x13, 0x19, 0x05, 0xcf, 0x57, 0xe3, 0xf4, 0x43, 0x32, 0xa3, 0x1e, 0xe2, 0x8a, 0x84, 0x76,
	0x11, 0xd5, 0x2c, 0x7d, 0x12, 0x93, 0xd9, 0x01, 0xfb, 0x11, 0x35, 0x09, 0xed, 0x16, 0x74, 0xf5,
	0x22, 0x77, 0x2e, 0x55, 0xe3, 0x40, 0x2f, 0x72, 0xcf, 0x50, 0x48, 0x2b, 0x1c, 0xb3, 0x90, 0x26,
	0x8e, 0x53, 0xb5, 0xc2, 0x0f, 0x25, 0xd8, 0x53, 0x58, 0x24, 0x4b, 0x58, 0x40, 0x9d, 0x17, 0x96,
	0xc8, 0x24, 0xd8, 0x53, 0x58, 0xfb, 0x36, 0x00, 0xd2, 0xfb, 0x71, 0x22, 0xa8, 0x73, 0xb9, 0xaa,
	0x3d, 0x7e, 0xf2, 0x93, 0x44, 0x50, 0xaf, 0x7f, 0x6c, 0xfe, 0xda, 0x0e, 0x74, 0xb5, 0x6b, 0x9c,
	0x17, 0x31, 0x2e, 0xcc, 0x50, 0x2a, 0x12, 0x24, 0xb1, 0x20, 0x81, 0x70, 0x5e, 0xaa, 0x2a, 0xb2,
	0xab, 0x10, 0x9e, 0xa1, 0x90, 0x7e, 0x8a, 0x92, 0x40, 0x99, 0xfd, 0x4a, 0xd5, 0x4f, 0x1f, 0x6b,
	0x8c, 0x97, 0xd3, 0xa0, 0x46, 0x34, 0x9e, 0x53, 0xe7, 0xea, 0x92, 0x46, 0x12, 0xec, 0x29, 0xac,
	0xf4, 0x4d, 0x9a, 0x44, 0x91, 0x73, 0xad, 0xea, 0x9b, 0xfd, 0x24, 0x8a, 0x3c, 0xc4, 0xd9, 0x1f,
	0xc0, 0x46, 0x4c, 0x4f, 0x30, 0xd7, 0xf8, 0x33, 0x3a, 0x3b, 0xa4, 0x19, 0x77, 0xae, 0xa3, 0x9b,
	0xaa, 0xb9, 0x6a, 0x14, 0xd3, 0x13, 0x99, 0x6b, 0x1e, 0x2a, 0x2a, 0xc9, 0x19, 0xd1, 0xb1, 0x28,
	0xb3, 0x3a, 0x37, 0x6a, 0xb3, 0xdc, 0x48, 0xd2, 0x15, 0xac, 0x72, 0x6d, 0xe6, 0x73, 0xaa, 0x7d,
	0xd5, 0x55, 0x6b, 0x53, 0xcf, 0xf0, 0x08, 0xb7, 0xd7, 0xef, 0x95, 0xa8, 0x54, 0xf8, 0xbc, 0x7c,
	0x76, 0xf8, 0x18, 0x56, 0x84, 0xd8, 0xdf, 0x81, 0xcd, 0x90, 0x46, 0x54, 0xd0, 0x32, 0xf7, 0x2b,
	0xb8, 0x61, 0xac, 0x2b, 0x44, 0x41, 0xfb, 0x26, 0xd8, 0x2a, 0x45, 0x20, 0x69, 0x90, 0x51, 0x22,
	0x68, 0xe8, 0xbc, 0xaa, 0x76, 0x17, 0xc4, 0x48, 0xda, 0x5d, 0x05, 0xb7, 0xdf, 0x87, 0x4b, 0x7c,
	0x9e, 0xd2, 0xac, 0x86, 0xe5, 0x35, 0x64, 0x79, 0xbe, 0x40, 0x97, 0xf9, 0xde, 0x81, 0xad, 0x60,
	0x4a, 0xe2, 0x98, 0x46, 0x8b, 0x4c, 0xaf, 0x23, 0x93, 0xad, 0x71, 0x65, 0x8e, 0x5b, 0x60, 0xcf,
	0xd8, 0x24, 0x23, 0x82, 0xca, 0xe4, 0x88, 0x4c, 0x2c, 0x74, 0x6e, 0x62, 0x9a, 0x5b, 0xd7, 0x98,
	0x47, 0x89, 0xe4, 0xd8, 0x0b, 0xed, 0xb7, 0x61, 0xcb, 0x10, 0xe7, 0x5b, 0x87, 0x24, 0x7f, 0x03,
	0xc9, 0x37, 0x35, 0xce, 0xec, 0x16, 0x7b, 0x61, 0xcd, 0xae, 0xff, 0x9d, 0x73, 0xee, 0xfa, 0xb7,
	0xa0, 0xcb, 0x62, 0xb5, 0x9e, 0x6e, 0x55, 0x59, 0xf6, 0x14, 0xc2, 0x33, 0x14, 0xf6, 0xaf, 0x82,
	0xcd, 0xe7, 0x41, 0x40, 0x39, 0x1f, 0xcf, 0x23, 0x3f, 0x25, 0xa7, 0x98, 0x8a, 0xde, 0x44, 0xbe,
	0x17, 0x4b, 0x2b, 0x3b, 0xa7, 0xd9, 0x57, 0x24, 0xde, 0x26, 0xaf, 0x82, 0xe4, 0x5e, 0x15, 0x24,
	0x71, 0x4c, 0x03, 0x41, 0x43, 0xff, 0x84, 0x1e, 0x72, 0x26, 0xa8, 0xf3, 0x96, 0xda, 0xab, 0x72,
	0xc4, 0x17, 0x0a, 0x6e, 0xdf, 0x81, 0xb5, 0x94, 0x70, 0x9e, 0x26, 0x19, 0xee, 0x0f, 0xc4, 0xd9,
	0xc6, 0x39, 0x2f, 0x96, 0x62, 0x47, 0xa3, 0xef, 0x11, 0x41, 0xbc, 0x61, 0x5a, 0x1a, 0xd9, 0x3b,
	0x30, 0x54, 0xbb, 0xd2, 0x8c, 0x64, 0x47, 0xf3, 0xd4, 0x79, 0x1b, 0x79, 0xaf, 0x96, 0xf5, 0x8c,
	0x58, 0x4c, 0x7f, 0x40, 0x4f, 0x0f, 0x13, 0x92, 0x85, 0x0f, 0x91, 0xca, 0x1b, 0x20, 0x8f, 0x1a,
	0xb8, 0xbf, 0x6b, 0xc1, 0xda, 0x42, 0x0e, 0xcf, 0xeb, 0x4a, 0xab, 0x54, 0x57, 0x5e, 0x84, 0x4e,
	0x32, 0x1e, 0xcb, 0x6a, 0xa6, 0x81, 0x8e, 0xd2, 0x23, 0x09, 0x8f, 0x68, 0x3c, 0x11, 0x53, 0x5d,
	0x76, 0xe8, 0x91, 0xbd, 0x01, 0xcd, 0x79, 0x16, 0xe9, 0x62, 0x53, 0xfe, 0x95, 0x4b, 0x5c, 0xd6,
	0x9c, 0x67, 0x94, 0x17, 0x88, 0x73, 0x13, 0xe8, 0xe7, 0x0b, 0xc5, 0xbe, 0x04, 0xdd, 0x31, 0x8b,
	0xf2, 0x7a, 0xa8, 0xef, 0x75, 0xe4, 0x70, 0x2f, 0x94, 0x35, 0xee, 0x09, 0x0b, 0xc5, 0x54, 0x8b,
	0xa2, 0x06, 0x52, 0x92, 0x29, 0x65, 0x93, 0xa9, 0x30, 0x92, 0xa8, 0x91, 0xdc, 0x7b, 0xf1, 0x33,
	0x9c, 0xfd, 0x48, 0x15, 0xbf, 0x6d, 0xaf, 0x27, 0x01, 0x72, 0x0e, 0xf7, 0x9f, 0x2c, 0x68, 0xe3,
	0x3e, 0x74, 0xf6, 0x6c, 0x97, 0xa1, 0x17, 0xce, 0x33, 0x95, 0xf1, 0xd4, 0x84, 0xf9, 0xd8, 0x7e,
	0x09, 0xfa, 0x29, 0xcd, 0xc6, 0x49, 0x36, 0xa3, 0x99, 0x39, 0x16, 0xe4, 0x80, 0xa2, 0x16, 0x6f,
	0x95, 0x6b, 0xf1, 0x17, 0xa1, 0x3f, 0x63, 0x33, 0xea, 0xa3, 0x89, 0xf5, 0x81, 0x40, 0x02, 0x1e,
	0x49, 0x33, 0x2f, 0x08, 0xdb, 0x59, 0x14, 0x56, 0x6e, 0x4e, 0x62, 0x3a, 0x9f, 0x1d, 0x2e, 0x57,
	0xdb, 0xa5, 0xcd, 0x09, 0x29, 0xdc, 0x9f, 0x5b, 0xd0, 0x33, 0xbb, 0xe6, 0xd9, 0xaa, 0xe5, 0x1f,
	0x6c, 0x3c, 0xe9, 0x83, 0xb9, 0x60, 0xa5, 0x03, 0x10, 0x0a, 0x66, 0xce, 0x08, 0x85, 0x4a, 0xad,
	0x55, 0x2a, 0xb5, 0x2b, 0xf6, 0xff, 0x47, 0x0b, 0xda, 0xb8, 0x5d, 0x7d, 0x5b, 0xde, 0x2e, 0x7b,
	0xab, 0x55, 0xf1, 0x56, 0xae, 0x6e, 0xfb, 0x3c, 0xea, 0x16, 0x1a, 0x75, 0x56, 0x69, 0xd4, 0xad,
	0x68, 0xf4, 0x5f, 0x16, 0xf4, 0xf3, 0xf2, 0xe3, 0x7f, 0x9f, 0x56, 0x85, 0x13, 0x3b, 0xab, 0x9c,
	0xd8, 0x5d, 0xa5, 0x72, 0xaf, 0xa2, 0xf2, 0x31, 0xb4, 0xb1, 0x3c, 0xf9, 0x66, 0x6b, 0x68, 0x61,
	0xde, 0xe6, 0xaa, 0x79, 0xab, 0x8b, 0xf7, 0x4f, 0x2c, 0xe8, 0xe7, 0xb5, 0xce, 0xd9, 0x93, 0x17,
	0x29, 0xaa, 0xb1, 0x90, 0xa2, 0xca, 0x42, 0x35, 0xcf, 0x32, 0x6a, 0xeb, 0xdc, 0x46, 0xad, 0x8d,
	0xef, 0x3f, 0xb4, 0xa0, 0xab, 0x6b, 0x28, 0x79, 0xc8, 0x48, 0xa7, 0x49, 0x4c, 0xfd, 0x78, 0x8e,
	0x15, 0x88, 0x92, 0x72, 0x80, 0xb0, 0x4f, 0x10, 0x54, 0x39, 0x8b, 0x37, 0x56, 0x9e, 0xc5, 0x9b,
	0x95, 0xb3, 0xf8, 0x25, 0xe8, 0xca, 0x1c, 0x2a, 0xf5, 0x57, 0x86, 0xea, 0xc8, 0xa1, 0x0a, 0xb5,
	0xe3, 0x80, 0x64, 0xa1, 0x4e, 0x36, 0x6a, 0xe0, 0xde, 0x83, 0x9e, 0x29, 0xd7, 0x64, 0x1a, 0x8b,
	0x92, 0x78, 0xc2, 0xc4, 0x3c, 0x54, 0x59, 0xbf, 0xe9, 0x15, 0x00, 0x69, 0xa7, 0x88, 0x08, 0x85,
	0x6c, 0x20, 0x32, 0x1f, 0xbb, 0x7f, 0x23, 0xd7, 0x2f, 0x56, 0x70, 0xe5, 0xc2, 0xd0, 0x3a, 0x47,
	0x61, 0x98, 0x27, 0xc7, 0x46, 0x39, 0x39, 0x3a, 0xd0, 0x25, 0x61, 0x98, 0x51, 0xce, 0xb5, 0x7e,
	0x66, 0x68, 0xbf, 0x0c, 0x6b, 0xe3, 0x64, 0x9e, 0xf1, 0x2f, 0xe7, 0x24, 0xa3, 0x46, 0xc9, 0xbe,
	0x37, 0x2c, 0x80, 0x7b, 0xa1, 0xfd, 0x3a, 0xac, 0x97, 0x88, 0x4a, 0x19, 0x76, 0x54, 0x80, 0x65,
	0x5c, 0xb9, 0x3b, 0x00, 0xb2, 0xb2, 0xfc, 0x54, 0x55, 0xc0, 0xe6, 0xc0, 0x64, 0x95, 0x0e, 0x4c,
	0xd7, 0x60, 0x70, 0x9c, 0x08, 0x9a, 0xf9, 0x41, 0x32, 0x8f, 0xcd, 0xae, 0x07, 0x08, 0xda, 0x95,
	0x10, 0xf7, 0xc7, 0xd0, 0x92, 0x9f, 0x28, 0x75, 0x65, 0xfa, 0xd8, 0x95, 0xb9, 0x0c, 0xbd, 0x2f,
	0xe7, 0x94, 0xe7, 0xb1, 0xde, 0xf7, 0xf2, 0xb1, 0xbd, 0x0d, 0xdd, 0x04, 0xa7, 0x94, 0xea, 0xc9,
	0x0a, 0x71, 0x6b, 0xb1, 0xd2, 0x55, 0xf2, 0x78, 0x86, 0x48, 0x3a, 0x9c, 0x71, 0x3f, 0x88, 0x12,
	0x4e, 0x95, 0xc2, 0x3d, 0xaf, 0xc7, 0xf8, 0x2e, 0x8e, 0x5d, 0x02, 0x9b, 0x72, 0xeb, 0xdc, 0xcf,
	0x12, 0x19, 0x6e, 0x18, 0x97, 0x5c, 0x8a, 0x2d, 0x12, 0x41, 0x22, 0x2d, 0xb6, 0x6a, 0x24, 0x00,
	0x82, 0x50, 0x6c, 0xfb, 0x16, 0x74, 0xb0, 0xc8, 0xe4, 0x4e, 0xe3, 0xec, 0x1a, 0x55, 0x93, 0xb8,
	0xbf, 0x06, 0xad, 0x07, 0x2c, 0x5a, 0xb1, 0xb6, 0x16, 0x82, 0xbf, 0x51, 0xd9, 0xaf, 0x0c, 0x32,
	0x25, 0xba, 0x3c, 0xd0, 0xe9, 0x66, 0x9f, 0x88, 0xa9, 0xfb, 0x77, 0x16, 0x5c, 0xf0, 0x64, 0x19,
	0xb2, 0x58, 0x9b, 0xd8, 0xff, 0x0f, 0x7a, 0x47, 0x1a, 0xe2, 0x58, 0x28, 0xa1, 0x53, 0x48, 0x68,
	0x68, 0xef, 0xce, 0x85, 0x90, 0xd1, 0x64, 0x28, 0xa5, 0xe3, 0x33, 0x2a, 0x85, 0xf0, 0x73, 0x66,
	0xd5, 0xc0, 0x1b, 0x29, 0xb0, 0x61, 0x94, 0xf5, 0xb6, 0x5c, 0x82, 0x42, 0x66, 0x9c, 0x9c, 0xb4,
	0xa9, 0xea, 0xed, 0x24, 0xa6, 0x8f, 0xd8, 0xac, 0xa0, 0x7d, 0x09, 0xfa, 0x9c, 0x46, 0x34, 0x10,
	0xec, 0x98, 0x6a, 0xeb, 0x17, 0x00, 0xf7, 0x31, 0x8c, 0x16, 0xc5, 0xa9, 0x0d, 0x23, 0x14, 0x0c,
	0xfd, 0xef, 0x9b, 0x43, 0x56, 0x2e, 0x18, 0x82, 0x4d, 0x76, 0x78, 0x03, 0x36, 0x0c, 0x61, 0xbe,
	0x8e, 0xb4, 0x5c, 0x1a, 0x6e, 0x16, 0x91, 0xfb, 0xeb, 0x15, 0xcb, 0x79, 0x74, 0x96, 0x1c, 0x53,
	0x35, 0x95, 0xfc, 0xe7, 0x97, 0x0c, 0xa8, 0xa7, 0x92, 0xe0, 0x7a, 0xbd, 0x1a, 0x55, 0xbd, 0x7c,
	0xd8, 0xaa, 0x2b, 0x1a, 0xed, 0x0f, 0x61, 0x9d, 0x21, 0xdc, 0xaf, 0xf8, 0xe7, 0xcc, 0x6a, 0x53,
	0x7b, 0x69, 0xc4, 0x16, 0xa0, 0xee, 0xbf, 0x35, 0xaa, 0x33, 0xac, 0xb0, 0x9f, 0xae, 0x23, 0x1b,
	0x45, 0x1d, 0xf9, 0xb6, 0x4c, 0x56, 0x13, 0x16, 0xfb, 0x12, 0xde, 0x5c, 0xce, 0x34, 0x13, 0x16,
	0x7f, 0x9e, 0x45, 0x32, 0xd3, 0xa8, 0x7f, 0x32, 0x73, 0x04, 0x24, 0x8a, 0x0e, 0x49, 0x70, 0xa4,
	0x0a, 0x6c, 0x9d, 0x39, 0x0c, 0x10, 0x0b, 0xe9, 0x6d, 0xb8, 0xc0, 0x4f, 0x98, 0x08, 0xa6, 0xbe,
	0x56, 0xf2, 0xcb, 0x39, 0xcd, 0x4e, 0x75, 0xf6, 0xd8, 0x54, 0x28, 0x25, 0xf4, 0x67, 0x12, 0x61,
	0x3f, 0x80, 0xeb, 0x35, 0xf4, 0x7e, 0x30, 0xcf, 0x32, 0x1a, 0x8b, 0xa2, 0x21, 0xd6, 0xf7, 0x5e,
	0x5a, 0x62, 0xde, 0x55, 0x44, 0xd8, 0x0d, 0xbb, 0x53, 0x12, 0x0e, 0xbb, 0x13, 0xdd, 0x6a, 0xf5,
	0xbf, 0xab, 0xd1, 0xd8, 0xa5, 0xc8, 0x85, 0x96, 0x23, 0x69, 0x9c, 0x94, 0x9c, 0xe2, 0x7e, 0xdc,
	0xf3, 0xe4, 0x5f, 0xf7, 0x0f, 0x2c, 0x99, 0xd6, 0xb5, 0xe2, 0xda, 0x76, 0x56, 0x61, 0xbb, 0x52,
	0x9f, 0x0b, 0x2d, 0xad, 0xcc, 0x6a, 0xfa, 0x5c, 0x8f, 0xa4, 0xc1, 0x6f, 0xc0, 0xf0, 0x30, 0x11,
	0x7e, 0xde, 0x2e, 0x56, 0xeb, 0x76, 0x70, 0x98, 0x88, 0xcf, 0x4d, 0xc7, 0xf8, 0x1d, 0xd8, 0x32,
	0xa1, 0x7a, 0x92, 0x31, 0x41, 0x7d, 0x82, 0x07, 0x20, 0xbd, 0x44, 0x6c, 0x8d, 0xfb, 0x42, 0xa2,
	0x76, 0x10, 0xe3, 0xfe, 0xb7, 0x05, 0x6b, 0x46, 0x0f, 0x65, 0xbf, 0x6a, 0xd6, 0x3c, 0x4f, 0x83,
	0xf3, 0x16, 0x74, 0xcd, 0x11, 0xb0, 0x79, 0xd6, 0x11, 0xd0, 0x50, 0xc8, 0x85, 0xae, 0x3d, 0x53,
	0x6a, 0x30, 0x2a, 0xcf, 0xeb, 0x38, 0x2e, 0x7a, 0x8b, 0x32, 0x42, 0xf0, 0x18, 0x1a, 0x73, 0x41,
	0xe2, 0xc0, 0x6c, 0x1a, 0x43, 0x09, 0xdc, 0xd3, 0x30, 0xdd, 0x5e, 0x25, 0xda, 0xab, 0xf8, 0xdf,
	0x7e, 0x0d, 0xd6, 0xa5, 0xd3, 0x7c, 0x3e, 0x95, 0xa7, 0xb7, 0xd8, 0xf8, 0xaf, 0xef, 0xad, 0x49,
	0xf0, 0x81, 0x84, 0xca, 0xbd, 0xd9, 0xfd, 0x01, 0xc0, 0x83, 0x24, 0x0b, 0x28, 0x2e, 0x5b, 0x99,
	0xa3, 0xc7, 0x72, 0xe4, 0xe3, 0x31, 0x4c, 0x2f, 0x52, 0x18, 0x17, 0x04, 0xab, 0x17, 0xe8, 0xa7,
	0xd0, 0x2f, 0x7a, 0x02, 0x2e, 0xac, 0xf1, 0x19, 0x89, 0x22, 0x7f, 0x31, 0x3f, 0x0f, 0x10, 0xf8,
	0x40, 0x25, 0xe9, 0xab, 0x30, 0x38, 0x64, 0x93, 0x9c, 0x42, 0x97, 0x15, 0x87, 0x6c, 0xa2, 0xf0,
	0xee, 0x57, 0x1d, 0x80, 0x52, 0xcf, 0xc3, 0x1c, 0xd4, 0xac, 0xb3, 0x0f, 0x6a, 0xb2, 0xa6, 0xe2,
	0x82, 0x88, 0x39, 0xd7, 0x5f, 0xd3, 0x23, 0x59, 0xc0, 0xcc, 0x63, 0xc1, 0x22, 0xbf, 0xd4, 0x89,
	0xee, 0x23, 0xe4, 0x9e, 0x6a, 0x47, 0xaf, 0x05, 0x24, 0xf6, 0x0f, 0xa9, 0x4f, 0x43, 0x26, 0xf2,
	0x3d, 0x6d, 0x10, 0x90, 0xf8, 0x2e, 0xbd, 0x8f, 0x20, 0xe9, 0x38, 0x49, 0x93, 0x26, 0x5c, 0x18,
	0xd7, 0x71, 0x74, 0x48, 0xcf, 0x5b, 0x0f, 0x48, 0xbc, 0x9f, 0x70, 0xa1, 0x3d, 0xc7, 0x0d, 0x2d,
	0xf6, 0x56, 0x73, 0xda, 0x4e, 0x4e, 0x2b, 0xbf, 0x98, 0xd3, 0x6e, 0xab, 0xe6, 0xbc, 0xee, 0xb6,
	0xe4, 0xd4, 0x5d, 0xa4, 0x96, 0x9f, 0xb9, 0x87, 0x98, 0x9c, 0xfe, 0x1d, 0xd8, 0x92, 0xf4, 0x19,
	0xe5, 0x22, 0x63, 0x41, 0xd1, 0x72, 0xea, 0xe9, 0x3e, 0x08, 0x89, 0x3d, 0x8d, 0x32, 0x6d, 0x26,
	0x3d, 0x43, 0x9a, 0x25, 0xb3, 0x04, 0xa7, 0x50, 0x0c, 0xfd, 0x7c, 0x86, 0x7d, 0x85, 0x31, 0xf4,
	0xaf, 0x81, 0x14, 0x52, 0xe6, 0x8a, 0x58, 0x86, 0x67, 0x3c, 0x4e, 0xb0, 0xf1, 0xdc, 0xf3, 0xa4,
	0x91, 0x76, 0x11, 0xba, 0x17, 0x8f, 0x13, 0xfb, 0x26, 0x6c, 0x48, 0x3a, 0x7d, 0x39, 0x22, 0xed,
	0xaf, 0xae, 0x30, 0x7a, 0xde, 0x28, 0x20, 0xf1, 0x1e, 0x82, 0xa5, 0x6f, 0xb8, 0xa1, 0x4c, 0x59,
	0x5c, 0x28, 0x38, 0xcc, 0x29, 0xf7, 0x59, 0x9c, 0x6b, 0xa7, 0x2a, 0x0b, 0xdd, 0x0b, 0x5b, 0x33,
	0x95, 0x85, 0x8e, 0x00, 0x6d, 0x56, 0x4e, 0xe3, 0xb0, 0xf8, 0xce, 0x28, 0x37, 0xeb, 0x01, 0x8d,
	0xc3, 0xfc, 0x43, 0xef, 0xc1, 0xa5, 0x12, 0x6d, 0xc8, 0x48, 0xc1, 0xb1, 0x8e, 0x1c, 0x5b, 0x39,
	0x47, 0xc8, 0x48, 0xce, 0xf6, 0x0a, 0x8c, 0x72, 0xb6, 0x34, 0x89, 0x22, 0xee, 0x6c, 0x20, 0xf5,
	0x50, 0x53, 0xcb, 0x6a, 0x68, 0xf1, 0xe3, 0x89, 0x98, 0xd2, 0xac, 0xf8, 0xf8, 0xe6, 0xc2, 0xc7,
	0x3f, 0x95, 0xc8, 0xfc, 0xe3, 0x1f, 0xc0, 0x0b, 0x92, 0x8d, 0x84, 0xd8, 0x7d, 0xf1, 0x53, 0xb9,
	0xfa, 0xd3, 0x8c, 0x1e, 0x33, 0x7a, 0xc2, 0xb1, 0x0f, 0xdd, 0xf3, 0x9e, 0x0f, 0x48, 0xbc, 0x13,
	0x86, 0x5f, 0xd0, 0xc3, 0x7d, 0x32, 0xa1, 0xfb, 0x1a, 0xe9, 0xfe, 0x4e, 0x13, 0xd6, 0x2b, 0x97,
	0x41, 0xf5, 0xd6, 0xb0, 0x9e, 0xda, 0x1a, 0x8d, 0xa7, 0xb2, 0x46, 0xf3, 0xe9, 0xac, 0xd1, 0xfa,
	0xa6, 0xd6, 0x68, 0xaf, 0xb0, 0x46, 0x5d, 0x80, 0x76, 0xce, 0x1b, 0xa0, 0xdd, 0x73, 0x07, 0x68,
	0xaf, 0x2e, 0x40, 0xdd, 0x43, 0xb0, 0x3d, 0xca, 0xd3, 0x24, 0xe6, 0x74, 0x9f, 0x64, 0x64, 0x46,
	0x85, 0xe4, 0xaf, 0x6f, 0x35, 0x5a, 0xf5, 0xad, 0xc6, 0x6b, 0x30, 0xc8, 0xa8, 0xc8, 0x4e, 0x7d,
	0x32, 0x16, 0x34, 0x33, 0x25, 0x3c, 0x82, 0x76, 0x24, 0xc4, 0x1d, 0x02, 0xec, 0xc5, 0xe9, 0x5c,
	0xa0, 0x33, 0x5c, 0x01, 0xeb, 0xc5, 0x48, 0x65, 0xd7, 0xba, 0x4e, 0xd8, 0x16, 0xb4, 0xd1, 0xb3,
	0xe6, 0xe0, 0x82, 0x83, 0x72, 0x7b, 0xbd, 0xb9, 0xd8, 0x5e, 0xbf, 0x02, 0x90, 0x92, 0x8c, 0x53,
	0x7f, 0x96, 0x84, 0xa6, 0x3b, 0xd2, 0x47, 0xc8, 0xc3, 0x24, 0xa4, 0xee, 0x4f, 0x1b, 0xe5, 0x69,
	0x55, 0x2f, 0xe4, 0xfc, 0xd3, 0x6e, 0x99, 0x73, 0xaa, 0xb9, 0xee, 0xc5, 0x23, 0x69, 0x49, 0x98,
	0xd6, 0x2a, 0x61, 0xda, 0x15, 0x61, 0x8a, 0xae, 0x44, 0xa7, 0xbe, 0x2b, 0xd1, 0x3d, 0xb3, 0x2b,
	0xd1, 0xab, 0x1c, 0xa0, 0xdf, 0x02, 0x9b, 0xcf, 0xd3, 0x34, 0xc9, 0x04, 0xf7, 0xb9, 0xc8, 0x28,
	0x99, 0xb1, 0x78, 0x62, 0x52, 0xa1, 0xc1, 0x1c, 0x18, 0x84, 0xfb, 0xaf, 0x16, 0x5c, 0x28, 0xac,
	0x50, 0xf4, 0x4f, 0xfe, 0xef, 0x5b, 0xc2, 0xfd, 0x77, 0xab, 0xec, 0x60, 0xd5, 0x6c, 0xfc, 0xa5,
	0xa9, 0x55, 0x16, 0xb4, 0xb3, 0xaa, 0x99, 0xd9, 0x3d, 0xb3, 0x99, 0xd9, 0x2b, 0x9d, 0xd7, 0xdd,
	0x9f, 0x59, 0x60, 0x17, 0xca, 0xe5, 0x1d, 0xc7, 0x5f, 0x96, 0x7e, 0xee, 0x00, 0xfa, 0x28, 0x8e,
	0xac, 0x6c, 0xdc, 0x9f, 0x5b, 0x70, 0x81, 0xc4, 0xfc, 0x84, 0x66, 0x8b, 0xb5, 0x27, 0x26, 0x74,
	0x5d, 0x73, 0xab, 0xb2, 0x3d, 0xaf, 0x9b, 0xd6, 0x83, 0x32, 0xe5, 0x5e, 0x98, 0x9f, 0x49, 0x1a,
	0xa5, 0x33, 0xc9, 0x15, 0x00, 0x3e, 0x4d, 0x4e, 0x7c, 0x12, 0xd1, 0x4c, 0xe8, 0x4c, 0xdd, 0x97,
	0x90, 0x1d, 0x09, 0xa8, 0x69, 0x7d, 0x5f, 0x01, 0x08, 0x48, 0x30, 0x55, 0xc7, 0x4e, 0xdd, 0x23,
	0xea, 0x23, 0x44, 0x9e, 0x37, 0xdd, 0x3f, 0x6b, 0x40, 0x57, 0xdf, 0x18, 0x7e, 0x5b, 0x0d, 0xc3,
	0x6b, 0x30, 0x60, 0xdc, 0x57, 0x77, 0x9f, 0x79, 0x99, 0x05, 0x8c, 0xef, 0x68, 0xc8, 0xd3, 0x74,
	0x0d, 0xb7, 0xa0, 0x4d, 0x67, 0xc9, 0x6f, 0x30, 0x5d, 0xf9, 0xaa, 0x81, 0xfd, 0x02, 0xf4, 0xf2,
	0xd7, 0x10, 0x2a, 0x58, 0xba, 0x5c, 0x3f, 0x83, 0xb8, 0x03, 0x6b, 0x33, 0xc2, 0x8f, 0x64, 0x09,
	0xc7, 0xf2, 0x25, 0xb1, 0x70, 0xa6, 0x79, 0x48, 0xf8, 0xd1, 0xbe, 0xc6, 0x7a, 0xc3, 0x59, 0x69,
	0xb4, 0xd8, 0x51, 0xe8, 0x57, 0xda, 0x69, 0x7f, 0x69, 0x01, 0x14, 0x0f, 0x28, 0xa4, 0x73, 0x70,
	0x7e, 0x1d, 0x66, 0x78, 0x38, 0xa9, 0xef, 0x2b, 0x55, 0xec, 0xd1, 0x5c, 0xb2, 0xc7, 0xab, 0x30,
	0xc2, 0xf3, 0x39, 0x8b, 0xb9, 0x2f, 0xe5, 0x31, 0x5b, 0xea, 0x9a, 0x81, 0x4a, 0x91, 0xb9, 0xfd,
	0x16, 0xf4, 0xf4, 0x95, 0xae, 0xdc, 0x3a, 0x9b, 0xf5, 0xb7, 0xbe, 0x39, 0x89, 0x1b, 0xc1, 0xb0,
	0xac, 0xaa, 0x14, 0x2e, 0x4d, 0x58, 0x6c, 0x8e, 0xb8, 0x6a, 0x20, 0x7d, 0xfe, 0xd8, 0xe7, 0x53,
	0x36, 0x16, 0xba, 0xbf, 0xd6, 0x79, 0x7c, 0x20, 0x47, 0x12, 0x71, 0xaa, 0x11, 0x4d, 0x85, 0x38,
	0x55, 0x88, 0x2d, 0x68, 0xf3, 0x80, 0xe8, 0x9b, 0x85, 0xa6, 0xa7, 0x06, 0xee, 0x5f, 0x5b, 0xb0,
	0x4e, 0xc2, 0x50, 0x8b, 0xf1, 0x28, 0x91, 0x26, 0x2a, 0x75, 0x05, 0xad, 0x85, 0xae, 0xa0, 0xb1,
	0x5d, 0xa3, 0x64, 0xbb, 0x6b, 0x30, 0x48, 0xe3, 0x89, 0x79, 0xbb, 0xa2, 0x97, 0x24, 0xa4, 0xf1,
	0xc4, 0x44, 0xe7, 0x45, 0xe8, 0xa0, 0xf7, 0xb9, 0x8e, 0x6e, 0x3d, 0x5a, 0xf6, 0x78, 0xfb, 0xfc,
	0x1e, 0x77, 0xff, 0x36, 0x5f, 0xa6, 0x07, 0x53, 0x96, 0xa6, 0x2c, 0x9e, 0xe4, 0xcb, 0x94, 0x6b,
	0xc0, 0xd2, 0x32, 0xe5, 0x65, 0xca, 0xbd, 0x50, 0x1e, 0x27, 0x93, 0x23, 0x5d, 0x62, 0x35, 0x92,
	0x23, 0x7b, 0x17, 0x36, 0x72, 0xde, 0xc5, 0x8e, 0x5b, 0xa9, 0x9b, 0x64, 0xa6, 0xd3, 0x5d, 0xb7,
	0xfc, 0xa3, 0x9f, 0xea, 0xee, 0xdb, 0xcb, 0xb0, 0x46, 0xb3, 0x2c, 0xc9, 0xcb, 0x2c, 0xd3, 0x38,
	0x40, 0xa0, 0x2e, 0x54, 0xdc, 0xdf, 0xb2, 0xe0, 0xa2, 0x92, 0x7e, 0x3f, 0xa3, 0xbb, 0x53, 0x1a,
	0x1c, 0x25, 0x73, 0xa1, 0x14, 0x78, 0x17, 0x9e, 0x4f, 0x33, 0xea, 0x07, 0x1a, 0x58, 0x55, 0xc2,
	0x4e, 0x2b, 0x0c, 0x35, 0x7a, 0x2c, 0x89, 0xd0, 0xac, 0x11, 0xe1, 0xfb, 0x30, 0xfc, 0x98, 0x1c,
	0xd2, 0x88, 0x86, 0xfb, 0x19, 0x0b, 0x70, 0x09, 0x44, 0x72, 0x6c, 0xa2, 0x0c, 0x07, 0xd2, 0x77,
	0x64, 0x56, 0xea, 0x65, 0xea, 0x91, 0xfb, 0xe7, 0x16, 0x74, 0xf5, 0x6d, 0x68, 0xb1, 0x78, 0xac,
	0xf2, 0xe2, 0xa9, 0x3c, 0xdd, 0x6a, 0x2c, 0x3f, 0xdd, 0x7a, 0x1d, 0xd6, 0xb9, 0x20, 0x99, 0xf0,
	0x53, 0x53, 0xaa, 0x69, 0x41, 0x47, 0x08, 0xce, 0x0b, 0x38, 0xb9, 0xff, 0xa8, 0x16, 0x49, 0x70,
	0x6a, 0x2e, 0x8a, 0xcc, 0xd8, 0xbe, 0x01, 0x43, 0xd5, 0xba, 0xd4, 0x62, 0xaa, 0x3c, 0xa9, 0xda,
	0x99, 0x3b, 0x4a, 0xd6, 0xbf, 0xb7, 0x60, 0xdd, 0x78, 0x6d, 0x47, 0x37, 0x86, 0x6f, 0xc0, 0x10,
	0x7b, 0x9d, 0xd9, 0xa9, 0x7a, 0x42, 0xa7, 0x0f, 0xc0, 0x1a, 0xb6, 0xab, 0x37, 0x73, 0x79, 0x3e,
	0xcd, 0x73, 0x02, 0x0e, 0xe4, 0x0a, 0x08, 0x98, 0x38, 0xd5, 0x92, 0xe2, 0x7f, 0xf9, 0x31, 0x59,
	0xad, 0x50, 0xe1, 0x47, 0x2c, 0xa6, 0xef, 0x6a, 0x19, 0x07, 0x0a, 0xf6, 0xb1, 0x04, 0x55, 0x48,
	0x6e, 0xeb, 0x3d, 0xa8, 0x44, 0x72, 0x5b, 0xe6, 0x30, 0x3c, 0xbe, 0x96, 0x9e, 0xf4, 0xf5, 0x24,
	0x00, 0x9f, 0xf3, 0xfd, 0xb1, 0x05, 0xfd, 0x4f, 0xb3, 0x90, 0x66, 0x58, 0x3a, 0xd7, 0xa5, 0xb0,
	0xea, 0x45, 0x41, 0x63, 0xf9, 0xa2, 0x00, 0x73, 0x32, 0x61, 0x91, 0xd9, 0x36, 0x71, 0x60, 0xdf,
	0x2b, 0x45, 0xbd, 0x69, 0xa3, 0xb7, 0xaa, 0x6f, 0xdd, 0x2a, 0xf6, 0x2b, 0xc2, 0x5e, 0x03, 0xdc,
	0x31, 0x8c, 0x16, 0x57, 0xc6, 0x52, 0xb3, 0xa6, 0x3e, 0xc7, 0x6e, 0x43, 0x27, 0x95, 0xf1, 0x67,
	0x56, 0x5a, 0x69, 0xf5, 0x97, 0xc3, 0xd3, 0xd3, 0x54, 0xee, 0xbf, 0x34, 0x60, 0x73, 0xe9, 0x3a,
	0x7d, 0x21, 0x42, 0xac, 0x27, 0x44, 0x48, 0x63, 0x29, 0x42, 0x64, 0x24, 0xea, 0x1b, 0x7d, 0x3f,
	0x25, 0xa7, 0x51, 0x42, 0x42, 0x13, 0x89, 0x1a, 0xbc, 0xaf, 0xa0, 0xf6, 0x9b, 0x60, 0x57, 0x32,
	0x44, 0xd1, 0x20, 0xda, 0x58, 0xcc, 0x04, 0x7b, 0xa1, 0x7d, 0x1b, 0x20, 0x91, 0x3e, 0x53, 0x87,
	0xa0, 0xa5, 0x3d, 0x33, 0xf7, 0xa7, 0xd7, 0x4f, 0x72, 0xd7, 0xde, 0x81, 0xcb, 0x82, 0x46, 0x74,
	0x92, 0x91, 0x99, 0x79, 0x4f, 0x20, 0x4f, 0x2c, 0x99, 0x6a, 0x45, 0xa9, 0xb0, 0xb8, 0x64, 0x28,
	0xb4, 0xfa, 0xbb, 0x88, 0xdf, 0x0b, 0x25, 0x73, 0x9a, 0x25, 0xc7, 0x4c, 0xce, 0xb9, 0xcc, 0xac,
	0x36, 0xdc, 0x4b, 0x86, 0xa2, 0xc2, 0xec, 0xfe, 0x95, 0x05, 0x6b, 0x8b, 0xb9, 0xf4, 0x9b, 0xb4,
	0xdb, 0xce, 0x6d, 0xca, 0x6f, 0x27, 0xec, 0x7e, 0xbf, 0x01, 0x1b, 0x4b, 0x29, 0xf4, 0x9b, 0xc8,
	0x5d, 0x8e, 0xa0, 0xe6, 0x13, 0x22, 0xa8, 0x75, 0xae, 0x08, 0x6a, 0x3f, 0x45, 0x04, 0x75, 0xce,
	0x15, 0x41, 0xdd, 0xf3, 0x44, 0x90, 0xfb, 0x95, 0x05, 0xc3, 0xf2, 0xe3, 0x0f, 0xfb, 0x7d, 0xdd,
	0x83, 0x54, 0x8d, 0x77, 0xb7, 0x60, 0xbf, 0x1f, 0x07, 0xd9, 0x69, 0x2a, 0x68, 0x68, 0xc8, 0xef,
	0x47, 0x14, 0x5f, 0xa7, 0xa8, 0x3e, 0xe5, 0xaf, 0xc0, 0x20, 0xc8, 0x68, 0x48, 0x63, 0xc1, 0x48,
	0xc4, 0xb5, 0xf5, 0xae, 0xd6, 0xb0, 0xef, 0x16, 0x54, 0x5e, 0x99, 0xc5, 0x25, 0x85, 0x24, 0xdf,
	0xc2, 0x8d, 0x50, 0xa9, 0x3b, 0x88, 0xc8, 0x7b, 0x44, 0x50, 0xf7, 0x8f, 0x9a, 0xe0, 0x9c, 0xa5,
	0x47, 0xed, 0x89, 0xc2, 0x74, 0x64, 0x1b, 0xa5, 0x8e, 0x6c, 0x35, 0x77, 0x36, 0x57, 0xe4, 0xce,
	0x56, 0x39, 0x77, 0xbe, 0x09, 0x6d, 0x29, 0x89, 0x29, 0xeb, 0x6a, 0x9e, 0xdf, 0x48, 0xbd, 0x3d,
	0x45, 0x64, 0xbf, 0x07, 0x30, 0xce, 0x92, 0x58, 0xf8, 0x9c, 0xe9, 0x14, 0x7f, 0x36, 0x4b, 0x1f,
	0x29, 0x0f, 0x58, 0x48, 0xed, 0xef, 0xc1, 0x30, 0xa3, 0xc7, 0x54, 0x9e, 0x5f, 0x90, 0xb1, 0xbb,
	0x92, 0x71, 0xa0, 0x69, 0x91, 0x75, 0x1b, 0x3a, 0x9c, 0x46, 0x63, 0x46, 0x97, 0xab, 0xe9, 0x05,
	0x26, 0x4d, 0x65, 0x7f, 0x00, 0x03, 0x91, 0x91, 0x98, 0x47, 0xea, 0xb0, 0xd7, 0x5f, 0xa9, 0x55,
	0x99, 0x54, 0x9a, 0x75, 0x4a, 0xf8, 0x14, 0x7b, 0x91, 0x7d, 0x0f, 0xff, 0xbb, 0x3f, 0x84, 0xad,
	0xba, 0x18, 0xc9, 0x5d, 0x60, 0x95, 0x5c, 0x60, 0xf8, 0x1b, 0x05, 0x3f, 0xf6, 0x8b, 0x69, 0x90,
	0x51, 0xa1, 0x1d, 0xa2, 0x47, 0xee, 0x45, 0xd8, 0xaa, 0x78, 0xfa, 0xbe, 0xac, 0x6c, 0xdc, 0x3f,
	0xb5, 0xe0, 0x4a, 0x1d, 0x42, 0xae, 0x82, 0x07, 0x8c, 0x46, 0x78, 0xab, 0xcf, 0x93, 0x79, 0x16,
	0x98, 0x90, 0xd0, 0xa3, 0xda, 0x47, 0xf1, 0x78, 0xad, 0x4e, 0xa3, 0xb0, 0xf2, 0x7c, 0x9f, 0x46,
	0xa1, 0xb9, 0x56, 0x97, 0x82, 0xfb, 0x28, 0xb5, 0xae, 0x4a, 0x24, 0xe0, 0x23, 0x29, 0xb9, 0x53,
	0x5c, 0x3a, 0xa8, 0x34, 0x60, 0x86, 0xee, 0x4f, 0xce, 0x90, 0xf1, 0x41, 0xee, 0xee, 0xa7, 0x91,
	0xd1, 0x2c, 0x0d, 0x14, 0xa2, 0x74, 0x59, 0x5a, 0x15, 0xa2, 0xb5, 0x28, 0xc4, 0x6f, 0x5b, 0x70,
	0xad, 0x4e, 0x08, 0xaf, 0x14, 0x3a, 0xcf, 0x40, 0x8c, 0x1f, 0xc3, 0xe5, 0x3a, 0x29, 0x0e, 0x54,
	0x2c, 0x3e, 0x03, 0x01, 0x7e, 0x13, 0x9c, 0x5a, 0x5f, 0xc8, 0x5c, 0xf5, 0x0c, 0xa6, 0xff, 0x89,
	0x05, 0x2f, 0x9c, 0x35, 0x3f, 0x7f, 0x2a, 0x01, 0xae, 0xc1, 0x20, 0x17, 0x40, 0x97, 0x52, 0x7d,
	0x0f, 0x8c, 0x08, 0x94, 0xaf, 0x10, 0xe2, 0x2b, 0x0b, 0x5e, 0xae, 0x13, 0xe2, 0x51, 0xb1, 0xb8,
	0x9f, 0x95, 0x3d, 0x7e, 0x66, 0xc1, 0x2b, 0xe7, 0x10, 0xe5, 0x99, 0x99, 0xe6, 0xf7, 0xce, 0x58,
	0x26, 0x9f, 0xc7, 0x3c, 0xa5, 0x01, 0x1b, 0x33, 0xfa, 0x74, 0x19, 0xe5, 0x06, 0x0c, 0xa9, 0xfa,
	0x4c, 0xd9, 0x32, 0x03, 0x0d, 0x7b, 0x82, 0x71, 0xfe, 0xd3, 0x82, 0xd6, 0x87, 0x0b, 0xbd, 0x8a,
	0xa7, 0x3c, 0x6e, 0xe5, 0xaf, 0xd4, 0x9b, 0x4f, 0x7c, 0xa5, 0x6e, 0xfa, 0x57, 0xad, 0x52, 0xff,
	0xea, 0xfb, 0xb0, 0x26, 0x7f, 0x8b, 0x37, 0xfd, 0xed, 0xd5, 0x6f, 0xfa, 0x87, 0x92, 0x3a, 0x7f,
	0xd0, 0xbf, 0xf0, 0xf2, 0xbe, 0x73, 0x9e, 0x97, 0xf7, 0xee, 0x08, 0x86, 0xe5, 0x5b, 0x6c, 0x97,
	0xc2, 0x9a, 0xfc, 0xfd, 0x88, 0x4d, 0xa6, 0x07, 0x41, 0x92, 0x61, 0x5b, 0x32, 0x6f, 0x1d, 0xa8,
	0x36, 0x45, 0x3e, 0xce, 0xaf, 0x23, 0x1b, 0x2b, 0xae, 0x23, 0xb1, 0x1f, 0x92, 0x64, 0xa6, 0xa6,
	0x50, 0x03, 0xf7, 0x17, 0x0d, 0x18, 0x78, 0xc5, 0x4b, 0x57, 0xfb, 0x51, 0xfd, 0xcb, 0x06, 0x7d,
	0xd1, 0xf9, 0x84, 0x47, 0xb3, 0x1f, 0x3d, 0xe7, 0xd5, 0xbf, 0x8b, 0xf8, 0xac, 0xf6, 0x1d, 0x8b,
	0x16, 0xf7, 0x4a, 0xf1, 0xd1, 0x1a, 0xa2, 0x8f, 0x9e, 0xf3, 0x6a, 0xdf, 0xc0, 0x7c, 0x56, 0xfb,
	0xc0, 0x43, 0x5f, 0x7a, 0x9f, 0xf5, 0x49, 0x45, 0xb4, 0xf4, 0x49, 0xfd, 0x38, 0xe4, 0xfd, 0xf2,
	0x0d, 0xb4, 0xae, 0xce, 0x4b, 0x8f, 0x8f, 0x0a, 0xdc, 0x47, 0xcf, 0x79, 0x25, 0xca, 0xbb, 0x6b,
	0x0b, 0x26, 0xbc, 0x3b, 0xfc, 0x87, 0xaf, 0xaf, 0x5a, 0xbf, 0xf8, 0xfa, 0xaa, 0xf5, 0x1f, 0x5f,
	0x5f, 0xb5, 0x0e, 0x3b, 0xc8, 0xfc, 0xdd, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0xc5, 0x04, 0x8f,
	0x62, 0x69, 0x37, 0x00, 0x00,
}
