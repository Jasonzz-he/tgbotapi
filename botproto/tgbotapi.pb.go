// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tgbotapi.proto

package botproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// There are two mutually exclusive ways of receiving updates for your bot â€” the getUpdates method on one hand and Webhooks on the other. Incoming updates are stored on the server until the bot receives them either way, but they will not be kept longer than 24 hours.
// Regardless of which option you choose, you will receive JSON-serialized Update objects as a result.
// This object represents an incoming update.At most one of the optional parameters can be present in any given update.
type Update struct {
	UpdateId           int32               `protobuf:"varint,1,opt,name=update_id,json=updateId,proto3" json:"update_id,omitempty"`
	Message            *Message            `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	EditedMessage      *Message            `protobuf:"bytes,3,opt,name=edited_message,json=editedMessage" json:"edited_message,omitempty"`
	ChannelPost        *Message            `protobuf:"bytes,4,opt,name=channel_post,json=channelPost" json:"channel_post,omitempty"`
	EditedChannelPost  *Message            `protobuf:"bytes,5,opt,name=edited_channel_post,json=editedChannelPost" json:"edited_channel_post,omitempty"`
	InlineQuery        *InlineQuery        `protobuf:"bytes,6,opt,name=inline_query,json=inlineQuery" json:"inline_query,omitempty"`
	ChosenInlineResult *ChosenInlineResult `protobuf:"bytes,7,opt,name=chosen_inline_result,json=chosenInlineResult" json:"chosen_inline_result,omitempty"`
	CallbackQuery      *CallbackQuery      `protobuf:"bytes,8,opt,name=callback_query,json=callbackQuery" json:"callback_query,omitempty"`
	ShippingQuery      *ShippingQuery      `protobuf:"bytes,9,opt,name=shipping_query,json=shippingQuery" json:"shipping_query,omitempty"`
	PreCheckoutQuery   *PreCheckoutQuery   `protobuf:"bytes,10,opt,name=pre_checkout_query,json=preCheckoutQuery" json:"pre_checkout_query,omitempty"`
	Poll               *Poll               `protobuf:"bytes,11,opt,name=poll" json:"poll,omitempty"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{0} }

func (m *Update) GetUpdateId() int32 {
	if m != nil {
		return m.UpdateId
	}
	return 0
}

func (m *Update) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Update) GetEditedMessage() *Message {
	if m != nil {
		return m.EditedMessage
	}
	return nil
}

func (m *Update) GetChannelPost() *Message {
	if m != nil {
		return m.ChannelPost
	}
	return nil
}

func (m *Update) GetEditedChannelPost() *Message {
	if m != nil {
		return m.EditedChannelPost
	}
	return nil
}

func (m *Update) GetInlineQuery() *InlineQuery {
	if m != nil {
		return m.InlineQuery
	}
	return nil
}

func (m *Update) GetChosenInlineResult() *ChosenInlineResult {
	if m != nil {
		return m.ChosenInlineResult
	}
	return nil
}

func (m *Update) GetCallbackQuery() *CallbackQuery {
	if m != nil {
		return m.CallbackQuery
	}
	return nil
}

func (m *Update) GetShippingQuery() *ShippingQuery {
	if m != nil {
		return m.ShippingQuery
	}
	return nil
}

func (m *Update) GetPreCheckoutQuery() *PreCheckoutQuery {
	if m != nil {
		return m.PreCheckoutQuery
	}
	return nil
}

func (m *Update) GetPoll() *Poll {
	if m != nil {
		return m.Poll
	}
	return nil
}

// Contains information about the current status of a webhook.
type WebhookInfo struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	HasCustomCertificate bool     `protobuf:"varint,2,opt,name=has_custom_certificate,json=hasCustomCertificate,proto3" json:"has_custom_certificate,omitempty"`
	PendingUpdateCount   int32    `protobuf:"varint,3,opt,name=pending_update_count,json=pendingUpdateCount,proto3" json:"pending_update_count,omitempty"`
	LastErrorDate        int32    `protobuf:"varint,4,opt,name=last_error_date,json=lastErrorDate,proto3" json:"last_error_date,omitempty"`
	LastErrorMessage     string   `protobuf:"bytes,5,opt,name=last_error_message,json=lastErrorMessage,proto3" json:"last_error_message,omitempty"`
	MaxConnections       int32    `protobuf:"varint,6,opt,name=max_connections,json=maxConnections,proto3" json:"max_connections,omitempty"`
	AllowedUpdates       []string `protobuf:"bytes,7,rep,name=allowed_updates,json=allowedUpdates" json:"allowed_updates,omitempty"`
}

func (m *WebhookInfo) Reset()                    { *m = WebhookInfo{} }
func (m *WebhookInfo) String() string            { return proto.CompactTextString(m) }
func (*WebhookInfo) ProtoMessage()               {}
func (*WebhookInfo) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{1} }

func (m *WebhookInfo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *WebhookInfo) GetHasCustomCertificate() bool {
	if m != nil {
		return m.HasCustomCertificate
	}
	return false
}

func (m *WebhookInfo) GetPendingUpdateCount() int32 {
	if m != nil {
		return m.PendingUpdateCount
	}
	return 0
}

func (m *WebhookInfo) GetLastErrorDate() int32 {
	if m != nil {
		return m.LastErrorDate
	}
	return 0
}

func (m *WebhookInfo) GetLastErrorMessage() string {
	if m != nil {
		return m.LastErrorMessage
	}
	return ""
}

func (m *WebhookInfo) GetMaxConnections() int32 {
	if m != nil {
		return m.MaxConnections
	}
	return 0
}

func (m *WebhookInfo) GetAllowedUpdates() []string {
	if m != nil {
		return m.AllowedUpdates
	}
	return nil
}

// This object represents a Telegram user or bot.
type User struct {
	Id           int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	IsBot        bool   `protobuf:"varint,2,opt,name=is_bot,json=isBot,proto3" json:"is_bot,omitempty"`
	FirstName    string `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName     string `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	Username     string `protobuf:"bytes,5,opt,name=username,proto3" json:"username,omitempty"`
	LanguageCode string `protobuf:"bytes,6,opt,name=language_code,json=languageCode,proto3" json:"language_code,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{2} }

func (m *User) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *User) GetIsBot() bool {
	if m != nil {
		return m.IsBot
	}
	return false
}

func (m *User) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *User) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *User) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

// This object represents a chat.
type Chat struct {
	Id               int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type             string           `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Title            string           `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Username         string           `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	FirstName        string           `protobuf:"bytes,5,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName         string           `protobuf:"bytes,6,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	Photo            *ChatPhoto       `protobuf:"bytes,7,opt,name=photo" json:"photo,omitempty"`
	Description      string           `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	InviteLink       string           `protobuf:"bytes,9,opt,name=invite_link,json=inviteLink,proto3" json:"invite_link,omitempty"`
	PinnedMessage    *Message         `protobuf:"bytes,10,opt,name=pinned_message,json=pinnedMessage" json:"pinned_message,omitempty"`
	Permissions      *ChatPermissions `protobuf:"bytes,11,opt,name=permissions" json:"permissions,omitempty"`
	StickerSetName   string           `protobuf:"bytes,12,opt,name=sticker_set_name,json=stickerSetName,proto3" json:"sticker_set_name,omitempty"`
	CanSetStickerSet bool             `protobuf:"varint,13,opt,name=can_set_sticker_set,json=canSetStickerSet,proto3" json:"can_set_sticker_set,omitempty"`
}

func (m *Chat) Reset()                    { *m = Chat{} }
func (m *Chat) String() string            { return proto.CompactTextString(m) }
func (*Chat) ProtoMessage()               {}
func (*Chat) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{3} }

func (m *Chat) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Chat) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Chat) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Chat) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Chat) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *Chat) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *Chat) GetPhoto() *ChatPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *Chat) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Chat) GetInviteLink() string {
	if m != nil {
		return m.InviteLink
	}
	return ""
}

func (m *Chat) GetPinnedMessage() *Message {
	if m != nil {
		return m.PinnedMessage
	}
	return nil
}

func (m *Chat) GetPermissions() *ChatPermissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Chat) GetStickerSetName() string {
	if m != nil {
		return m.StickerSetName
	}
	return ""
}

func (m *Chat) GetCanSetStickerSet() bool {
	if m != nil {
		return m.CanSetStickerSet
	}
	return false
}

// This object represents a message.
type Message struct {
	MessageId             int32                 `protobuf:"varint,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	From                  *User                 `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	Date                  int32                 `protobuf:"varint,3,opt,name=date,proto3" json:"date,omitempty"`
	Chat                  *Chat                 `protobuf:"bytes,4,opt,name=chat" json:"chat,omitempty"`
	ForwardFrom           *User                 `protobuf:"bytes,5,opt,name=forward_from,json=forwardFrom" json:"forward_from,omitempty"`
	ForwardFromChat       *Chat                 `protobuf:"bytes,6,opt,name=forward_from_chat,json=forwardFromChat" json:"forward_from_chat,omitempty"`
	ForwardFromMessageId  int32                 `protobuf:"varint,7,opt,name=forward_from_message_id,json=forwardFromMessageId,proto3" json:"forward_from_message_id,omitempty"`
	ForwardSignature      string                `protobuf:"bytes,8,opt,name=forward_signature,json=forwardSignature,proto3" json:"forward_signature,omitempty"`
	ForwardSenderName     string                `protobuf:"bytes,9,opt,name=forward_sender_name,json=forwardSenderName,proto3" json:"forward_sender_name,omitempty"`
	ForwardDate           int32                 `protobuf:"varint,10,opt,name=forward_date,json=forwardDate,proto3" json:"forward_date,omitempty"`
	ReplyToMessage        *Message              `protobuf:"bytes,11,opt,name=reply_to_message,json=replyToMessage" json:"reply_to_message,omitempty"`
	EditDate              int32                 `protobuf:"varint,12,opt,name=edit_date,json=editDate,proto3" json:"edit_date,omitempty"`
	MediaGroupId          string                `protobuf:"bytes,13,opt,name=media_group_id,json=mediaGroupId,proto3" json:"media_group_id,omitempty"`
	AuthorSignature       string                `protobuf:"bytes,14,opt,name=author_signature,json=authorSignature,proto3" json:"author_signature,omitempty"`
	Text                  string                `protobuf:"bytes,15,opt,name=text,proto3" json:"text,omitempty"`
	Entities              []*MessageEntity      `protobuf:"bytes,16,rep,name=entities" json:"entities,omitempty"`
	CaptionEntities       []*MessageEntity      `protobuf:"bytes,17,rep,name=caption_entities,json=captionEntities" json:"caption_entities,omitempty"`
	Audio                 *Audio                `protobuf:"bytes,18,opt,name=audio" json:"audio,omitempty"`
	Document              *Document             `protobuf:"bytes,19,opt,name=document" json:"document,omitempty"`
	Animation             *Animation            `protobuf:"bytes,20,opt,name=animation" json:"animation,omitempty"`
	Game                  *Game                 `protobuf:"bytes,21,opt,name=game" json:"game,omitempty"`
	Photo                 []*PhotoSize          `protobuf:"bytes,22,rep,name=photo" json:"photo,omitempty"`
	Sticker               *Sticker              `protobuf:"bytes,23,opt,name=sticker" json:"sticker,omitempty"`
	Video                 *Video                `protobuf:"bytes,24,opt,name=video" json:"video,omitempty"`
	Voice                 *Voice                `protobuf:"bytes,25,opt,name=voice" json:"voice,omitempty"`
	VideoNote             *VideoNote            `protobuf:"bytes,26,opt,name=video_note,json=videoNote" json:"video_note,omitempty"`
	Caption               string                `protobuf:"bytes,27,opt,name=caption,proto3" json:"caption,omitempty"`
	Contact               *Contact              `protobuf:"bytes,28,opt,name=contact" json:"contact,omitempty"`
	Location              *Location             `protobuf:"bytes,29,opt,name=location" json:"location,omitempty"`
	Venue                 *Venue                `protobuf:"bytes,30,opt,name=venue" json:"venue,omitempty"`
	Poll                  *Poll                 `protobuf:"bytes,31,opt,name=poll" json:"poll,omitempty"`
	NewChatMembers        []*User               `protobuf:"bytes,32,rep,name=new_chat_members,json=newChatMembers" json:"new_chat_members,omitempty"`
	LeftChatMember        *User                 `protobuf:"bytes,33,opt,name=left_chat_member,json=leftChatMember" json:"left_chat_member,omitempty"`
	NewChatTitle          string                `protobuf:"bytes,34,opt,name=new_chat_title,json=newChatTitle,proto3" json:"new_chat_title,omitempty"`
	NewChatPhoto          []*PhotoSize          `protobuf:"bytes,35,rep,name=new_chat_photo,json=newChatPhoto" json:"new_chat_photo,omitempty"`
	DeleteChatPhoto       bool                  `protobuf:"varint,36,opt,name=delete_chat_photo,json=deleteChatPhoto,proto3" json:"delete_chat_photo,omitempty"`
	GroupChatCreated      bool                  `protobuf:"varint,37,opt,name=group_chat_created,json=groupChatCreated,proto3" json:"group_chat_created,omitempty"`
	SupergroupChatCreated bool                  `protobuf:"varint,38,opt,name=supergroup_chat_created,json=supergroupChatCreated,proto3" json:"supergroup_chat_created,omitempty"`
	ChannelChatCreated    bool                  `protobuf:"varint,39,opt,name=channel_chat_created,json=channelChatCreated,proto3" json:"channel_chat_created,omitempty"`
	MigrateToChatId       int32                 `protobuf:"varint,40,opt,name=migrate_to_chat_id,json=migrateToChatId,proto3" json:"migrate_to_chat_id,omitempty"`
	MigrateFromChatId     int32                 `protobuf:"varint,41,opt,name=migrate_from_chat_id,json=migrateFromChatId,proto3" json:"migrate_from_chat_id,omitempty"`
	PinnedMessage         *Message              `protobuf:"bytes,42,opt,name=pinned_message,json=pinnedMessage" json:"pinned_message,omitempty"`
	Invoice               *Invoice              `protobuf:"bytes,43,opt,name=invoice" json:"invoice,omitempty"`
	SuccessfulPayment     *SuccessfulPayment    `protobuf:"bytes,44,opt,name=successful_payment,json=successfulPayment" json:"successful_payment,omitempty"`
	ConnectedWebsite      string                `protobuf:"bytes,45,opt,name=connected_website,json=connectedWebsite,proto3" json:"connected_website,omitempty"`
	PassportData          *PassportData         `protobuf:"bytes,46,opt,name=passport_data,json=passportData" json:"passport_data,omitempty"`
	ReplyMarkup           *InlineKeyboardMarkup `protobuf:"bytes,47,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{4} }

func (m *Message) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *Message) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Message) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *Message) GetChat() *Chat {
	if m != nil {
		return m.Chat
	}
	return nil
}

func (m *Message) GetForwardFrom() *User {
	if m != nil {
		return m.ForwardFrom
	}
	return nil
}

func (m *Message) GetForwardFromChat() *Chat {
	if m != nil {
		return m.ForwardFromChat
	}
	return nil
}

func (m *Message) GetForwardFromMessageId() int32 {
	if m != nil {
		return m.ForwardFromMessageId
	}
	return 0
}

func (m *Message) GetForwardSignature() string {
	if m != nil {
		return m.ForwardSignature
	}
	return ""
}

func (m *Message) GetForwardSenderName() string {
	if m != nil {
		return m.ForwardSenderName
	}
	return ""
}

func (m *Message) GetForwardDate() int32 {
	if m != nil {
		return m.ForwardDate
	}
	return 0
}

func (m *Message) GetReplyToMessage() *Message {
	if m != nil {
		return m.ReplyToMessage
	}
	return nil
}

func (m *Message) GetEditDate() int32 {
	if m != nil {
		return m.EditDate
	}
	return 0
}

func (m *Message) GetMediaGroupId() string {
	if m != nil {
		return m.MediaGroupId
	}
	return ""
}

func (m *Message) GetAuthorSignature() string {
	if m != nil {
		return m.AuthorSignature
	}
	return ""
}

func (m *Message) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Message) GetEntities() []*MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *Message) GetCaptionEntities() []*MessageEntity {
	if m != nil {
		return m.CaptionEntities
	}
	return nil
}

func (m *Message) GetAudio() *Audio {
	if m != nil {
		return m.Audio
	}
	return nil
}

func (m *Message) GetDocument() *Document {
	if m != nil {
		return m.Document
	}
	return nil
}

func (m *Message) GetAnimation() *Animation {
	if m != nil {
		return m.Animation
	}
	return nil
}

func (m *Message) GetGame() *Game {
	if m != nil {
		return m.Game
	}
	return nil
}

func (m *Message) GetPhoto() []*PhotoSize {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *Message) GetSticker() *Sticker {
	if m != nil {
		return m.Sticker
	}
	return nil
}

func (m *Message) GetVideo() *Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *Message) GetVoice() *Voice {
	if m != nil {
		return m.Voice
	}
	return nil
}

func (m *Message) GetVideoNote() *VideoNote {
	if m != nil {
		return m.VideoNote
	}
	return nil
}

func (m *Message) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *Message) GetContact() *Contact {
	if m != nil {
		return m.Contact
	}
	return nil
}

func (m *Message) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Message) GetVenue() *Venue {
	if m != nil {
		return m.Venue
	}
	return nil
}

func (m *Message) GetPoll() *Poll {
	if m != nil {
		return m.Poll
	}
	return nil
}

func (m *Message) GetNewChatMembers() []*User {
	if m != nil {
		return m.NewChatMembers
	}
	return nil
}

func (m *Message) GetLeftChatMember() *User {
	if m != nil {
		return m.LeftChatMember
	}
	return nil
}

func (m *Message) GetNewChatTitle() string {
	if m != nil {
		return m.NewChatTitle
	}
	return ""
}

func (m *Message) GetNewChatPhoto() []*PhotoSize {
	if m != nil {
		return m.NewChatPhoto
	}
	return nil
}

func (m *Message) GetDeleteChatPhoto() bool {
	if m != nil {
		return m.DeleteChatPhoto
	}
	return false
}

func (m *Message) GetGroupChatCreated() bool {
	if m != nil {
		return m.GroupChatCreated
	}
	return false
}

func (m *Message) GetSupergroupChatCreated() bool {
	if m != nil {
		return m.SupergroupChatCreated
	}
	return false
}

func (m *Message) GetChannelChatCreated() bool {
	if m != nil {
		return m.ChannelChatCreated
	}
	return false
}

func (m *Message) GetMigrateToChatId() int32 {
	if m != nil {
		return m.MigrateToChatId
	}
	return 0
}

func (m *Message) GetMigrateFromChatId() int32 {
	if m != nil {
		return m.MigrateFromChatId
	}
	return 0
}

func (m *Message) GetPinnedMessage() *Message {
	if m != nil {
		return m.PinnedMessage
	}
	return nil
}

func (m *Message) GetInvoice() *Invoice {
	if m != nil {
		return m.Invoice
	}
	return nil
}

func (m *Message) GetSuccessfulPayment() *SuccessfulPayment {
	if m != nil {
		return m.SuccessfulPayment
	}
	return nil
}

func (m *Message) GetConnectedWebsite() string {
	if m != nil {
		return m.ConnectedWebsite
	}
	return ""
}

func (m *Message) GetPassportData() *PassportData {
	if m != nil {
		return m.PassportData
	}
	return nil
}

func (m *Message) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// This object represents one special entity in a text message. For example, hashtags, usernames, URLs, etc.
type MessageEntity struct {
	Type   string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Offset int32  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Length int32  `protobuf:"varint,3,opt,name=length,proto3" json:"length,omitempty"`
	Url    string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	User   *User  `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
}

func (m *MessageEntity) Reset()                    { *m = MessageEntity{} }
func (m *MessageEntity) String() string            { return proto.CompactTextString(m) }
func (*MessageEntity) ProtoMessage()               {}
func (*MessageEntity) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{5} }

func (m *MessageEntity) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MessageEntity) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *MessageEntity) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *MessageEntity) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *MessageEntity) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

// This object represents one size of a photo or a file / sticker thumbnail.
type PhotoSize struct {
	FileId   string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Width    int32  `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height   int32  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	FileSize int32  `protobuf:"varint,4,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *PhotoSize) Reset()                    { *m = PhotoSize{} }
func (m *PhotoSize) String() string            { return proto.CompactTextString(m) }
func (*PhotoSize) ProtoMessage()               {}
func (*PhotoSize) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{6} }

func (m *PhotoSize) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *PhotoSize) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *PhotoSize) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *PhotoSize) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents an audio file to be treated as music by the Telegram clients.
type Audio struct {
	FileId    string     `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Duration  int32      `protobuf:"varint,2,opt,name=duration,proto3" json:"duration,omitempty"`
	Performer string     `protobuf:"bytes,3,opt,name=performer,proto3" json:"performer,omitempty"`
	Title     string     `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	MimeType  string     `protobuf:"bytes,5,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize  int32      `protobuf:"varint,6,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	Thumb     *PhotoSize `protobuf:"bytes,7,opt,name=thumb" json:"thumb,omitempty"`
}

func (m *Audio) Reset()                    { *m = Audio{} }
func (m *Audio) String() string            { return proto.CompactTextString(m) }
func (*Audio) ProtoMessage()               {}
func (*Audio) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{7} }

func (m *Audio) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Audio) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Audio) GetPerformer() string {
	if m != nil {
		return m.Performer
	}
	return ""
}

func (m *Audio) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Audio) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Audio) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *Audio) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

// This object represents a general file (as opposed to photos, voice messages and audio files).
type Document struct {
	FileId   string     `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Thumb    *PhotoSize `protobuf:"bytes,2,opt,name=thumb" json:"thumb,omitempty"`
	FileName string     `protobuf:"bytes,3,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	MimeType string     `protobuf:"bytes,4,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize int32      `protobuf:"varint,5,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *Document) Reset()                    { *m = Document{} }
func (m *Document) String() string            { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()               {}
func (*Document) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{8} }

func (m *Document) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Document) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *Document) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Document) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Document) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents a video file.
type Video struct {
	FileId   string     `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Width    int32      `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height   int32      `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	Duration int32      `protobuf:"varint,4,opt,name=duration,proto3" json:"duration,omitempty"`
	Thumb    *PhotoSize `protobuf:"bytes,5,opt,name=thumb" json:"thumb,omitempty"`
	MimeType string     `protobuf:"bytes,6,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize int32      `protobuf:"varint,7,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *Video) Reset()                    { *m = Video{} }
func (m *Video) String() string            { return proto.CompactTextString(m) }
func (*Video) ProtoMessage()               {}
func (*Video) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{9} }

func (m *Video) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Video) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Video) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Video) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Video) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *Video) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Video) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).
type Animation struct {
	FileId   string     `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Width    int32      `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height   int32      `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	Duration int32      `protobuf:"varint,4,opt,name=duration,proto3" json:"duration,omitempty"`
	Thumb    *PhotoSize `protobuf:"bytes,5,opt,name=thumb" json:"thumb,omitempty"`
	FileName string     `protobuf:"bytes,6,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	MimeType string     `protobuf:"bytes,7,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize int32      `protobuf:"varint,8,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *Animation) Reset()                    { *m = Animation{} }
func (m *Animation) String() string            { return proto.CompactTextString(m) }
func (*Animation) ProtoMessage()               {}
func (*Animation) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{10} }

func (m *Animation) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Animation) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Animation) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Animation) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Animation) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *Animation) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Animation) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Animation) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents a voice note.
type Voice struct {
	FileId   string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Duration int32  `protobuf:"varint,2,opt,name=duration,proto3" json:"duration,omitempty"`
	MimeType string `protobuf:"bytes,3,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize int32  `protobuf:"varint,4,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *Voice) Reset()                    { *m = Voice{} }
func (m *Voice) String() string            { return proto.CompactTextString(m) }
func (*Voice) ProtoMessage()               {}
func (*Voice) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{11} }

func (m *Voice) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Voice) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Voice) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Voice) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents a video message (available in Telegram apps as of v.4.0).
type VideoNote struct {
	FileId   string     `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Length   int32      `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	Duration int32      `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
	Thumb    *PhotoSize `protobuf:"bytes,4,opt,name=thumb" json:"thumb,omitempty"`
	FileSize int32      `protobuf:"varint,5,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *VideoNote) Reset()                    { *m = VideoNote{} }
func (m *VideoNote) String() string            { return proto.CompactTextString(m) }
func (*VideoNote) ProtoMessage()               {}
func (*VideoNote) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{12} }

func (m *VideoNote) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *VideoNote) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *VideoNote) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *VideoNote) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *VideoNote) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents a phone contact.
type Contact struct {
	PhoneNumber string `protobuf:"bytes,1,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	FirstName   string `protobuf:"bytes,2,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName    string `protobuf:"bytes,3,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	UserId      int32  `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Vcard       string `protobuf:"bytes,5,opt,name=vcard,proto3" json:"vcard,omitempty"`
}

func (m *Contact) Reset()                    { *m = Contact{} }
func (m *Contact) String() string            { return proto.CompactTextString(m) }
func (*Contact) ProtoMessage()               {}
func (*Contact) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{13} }

func (m *Contact) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *Contact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *Contact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *Contact) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Contact) GetVcard() string {
	if m != nil {
		return m.Vcard
	}
	return ""
}

// This object represents a point on the map.
type Location struct {
	Longitude int64 `protobuf:"varint,1,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Latitude  int64 `protobuf:"varint,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{14} }

func (m *Location) GetLongitude() int64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *Location) GetLatitude() int64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

// This object represents a venue.
type Venue struct {
	Location       *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Title          string    `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Address        string    `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	FoursquareId   string    `protobuf:"bytes,4,opt,name=foursquare_id,json=foursquareId,proto3" json:"foursquare_id,omitempty"`
	FoursquareType string    `protobuf:"bytes,5,opt,name=foursquare_type,json=foursquareType,proto3" json:"foursquare_type,omitempty"`
}

func (m *Venue) Reset()                    { *m = Venue{} }
func (m *Venue) String() string            { return proto.CompactTextString(m) }
func (*Venue) ProtoMessage()               {}
func (*Venue) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{15} }

func (m *Venue) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Venue) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Venue) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Venue) GetFoursquareId() string {
	if m != nil {
		return m.FoursquareId
	}
	return ""
}

func (m *Venue) GetFoursquareType() string {
	if m != nil {
		return m.FoursquareType
	}
	return ""
}

// This object contains information about one answer option in a poll.
type PollOption struct {
	Text       string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	VoterCount int32  `protobuf:"varint,2,opt,name=voter_count,json=voterCount,proto3" json:"voter_count,omitempty"`
}

func (m *PollOption) Reset()                    { *m = PollOption{} }
func (m *PollOption) String() string            { return proto.CompactTextString(m) }
func (*PollOption) ProtoMessage()               {}
func (*PollOption) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{16} }

func (m *PollOption) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *PollOption) GetVoterCount() int32 {
	if m != nil {
		return m.VoterCount
	}
	return 0
}

// This object contains information about a poll.
type Poll struct {
	Id       string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Question string        `protobuf:"bytes,2,opt,name=question,proto3" json:"question,omitempty"`
	Options  []*PollOption `protobuf:"bytes,3,rep,name=options" json:"options,omitempty"`
	IsClosed bool          `protobuf:"varint,4,opt,name=is_closed,json=isClosed,proto3" json:"is_closed,omitempty"`
}

func (m *Poll) Reset()                    { *m = Poll{} }
func (m *Poll) String() string            { return proto.CompactTextString(m) }
func (*Poll) ProtoMessage()               {}
func (*Poll) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{17} }

func (m *Poll) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Poll) GetQuestion() string {
	if m != nil {
		return m.Question
	}
	return ""
}

func (m *Poll) GetOptions() []*PollOption {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Poll) GetIsClosed() bool {
	if m != nil {
		return m.IsClosed
	}
	return false
}

// This object represent a user's profile pictures.
type UserProfilePhotos struct {
	TotalCount int32        `protobuf:"varint,1,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	Photos     []*PhotoSize `protobuf:"bytes,2,rep,name=photos" json:"photos,omitempty"`
}

func (m *UserProfilePhotos) Reset()                    { *m = UserProfilePhotos{} }
func (m *UserProfilePhotos) String() string            { return proto.CompactTextString(m) }
func (*UserProfilePhotos) ProtoMessage()               {}
func (*UserProfilePhotos) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{18} }

func (m *UserProfilePhotos) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *UserProfilePhotos) GetPhotos() []*PhotoSize {
	if m != nil {
		return m.Photos
	}
	return nil
}

// This object represents a file ready to be downloaded. The file can be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile.
// Maximum file size to download is 20 MB
//
type File struct {
	FileId   string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	FileSize int32  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	FilePath string `protobuf:"bytes,3,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{19} }

func (m *File) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *File) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *File) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

// This object represents a custom keyboard with reply options (see Introduction to bots for details and examples).
type ReplyKeyboardMarkup struct {
	Keyboard        []*KeyboardButton `protobuf:"bytes,1,rep,name=keyboard" json:"keyboard,omitempty"`
	ResizeKeyboard  bool              `protobuf:"varint,2,opt,name=resize_keyboard,json=resizeKeyboard,proto3" json:"resize_keyboard,omitempty"`
	OneTimeKeyboard bool              `protobuf:"varint,3,opt,name=one_time_keyboard,json=oneTimeKeyboard,proto3" json:"one_time_keyboard,omitempty"`
	Selective       bool              `protobuf:"varint,4,opt,name=selective,proto3" json:"selective,omitempty"`
}

func (m *ReplyKeyboardMarkup) Reset()                    { *m = ReplyKeyboardMarkup{} }
func (m *ReplyKeyboardMarkup) String() string            { return proto.CompactTextString(m) }
func (*ReplyKeyboardMarkup) ProtoMessage()               {}
func (*ReplyKeyboardMarkup) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{20} }

func (m *ReplyKeyboardMarkup) GetKeyboard() []*KeyboardButton {
	if m != nil {
		return m.Keyboard
	}
	return nil
}

func (m *ReplyKeyboardMarkup) GetResizeKeyboard() bool {
	if m != nil {
		return m.ResizeKeyboard
	}
	return false
}

func (m *ReplyKeyboardMarkup) GetOneTimeKeyboard() bool {
	if m != nil {
		return m.OneTimeKeyboard
	}
	return false
}

func (m *ReplyKeyboardMarkup) GetSelective() bool {
	if m != nil {
		return m.Selective
	}
	return false
}

// This object represents one button of the reply keyboard. For simple text buttons String can be used instead of this object to specify text of the button. Optional fields are mutually exclusive.
// Note: request_contact and request_location options will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type KeyboardButton struct {
	Text            string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	RequestContact  bool   `protobuf:"varint,2,opt,name=request_contact,json=requestContact,proto3" json:"request_contact,omitempty"`
	RequestLocation bool   `protobuf:"varint,3,opt,name=request_location,json=requestLocation,proto3" json:"request_location,omitempty"`
}

func (m *KeyboardButton) Reset()                    { *m = KeyboardButton{} }
func (m *KeyboardButton) String() string            { return proto.CompactTextString(m) }
func (*KeyboardButton) ProtoMessage()               {}
func (*KeyboardButton) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{21} }

func (m *KeyboardButton) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *KeyboardButton) GetRequestContact() bool {
	if m != nil {
		return m.RequestContact
	}
	return false
}

func (m *KeyboardButton) GetRequestLocation() bool {
	if m != nil {
		return m.RequestLocation
	}
	return false
}

// Upon receiving a message with this object, Telegram clients will remove the current custom keyboard and display the default letter-keyboard. By default, custom keyboards are displayed until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are hidden immediately after the user presses a button (see ReplyKeyboardMarkup).
type ReplyKeyboardRemove struct {
	RemoveKeyboard bool `protobuf:"varint,1,opt,name=remove_keyboard,json=removeKeyboard,proto3" json:"remove_keyboard,omitempty"`
	Selective      bool `protobuf:"varint,2,opt,name=selective,proto3" json:"selective,omitempty"`
}

func (m *ReplyKeyboardRemove) Reset()                    { *m = ReplyKeyboardRemove{} }
func (m *ReplyKeyboardRemove) String() string            { return proto.CompactTextString(m) }
func (*ReplyKeyboardRemove) ProtoMessage()               {}
func (*ReplyKeyboardRemove) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{22} }

func (m *ReplyKeyboardRemove) GetRemoveKeyboard() bool {
	if m != nil {
		return m.RemoveKeyboard
	}
	return false
}

func (m *ReplyKeyboardRemove) GetSelective() bool {
	if m != nil {
		return m.Selective
	}
	return false
}

// This object represents an inline keyboard that appears right next to the message it belongs to.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will display unsupported message.
type InlineKeyboardMarkup struct {
	InlineKeyboard []*InlineKeyboardButton `protobuf:"bytes,1,rep,name=inline_keyboard,json=inlineKeyboard" json:"inline_keyboard,omitempty"`
}

func (m *InlineKeyboardMarkup) Reset()                    { *m = InlineKeyboardMarkup{} }
func (m *InlineKeyboardMarkup) String() string            { return proto.CompactTextString(m) }
func (*InlineKeyboardMarkup) ProtoMessage()               {}
func (*InlineKeyboardMarkup) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{23} }

func (m *InlineKeyboardMarkup) GetInlineKeyboard() []*InlineKeyboardButton {
	if m != nil {
		return m.InlineKeyboard
	}
	return nil
}

// This object represents one button of an inline keyboard. You must use exactly one of the optional fields.
type InlineKeyboardButton struct {
	Text                         string        `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Url                          string        `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	LoginUrl                     *LoginUrl     `protobuf:"bytes,3,opt,name=login_url,json=loginUrl" json:"login_url,omitempty"`
	CallbackData                 string        `protobuf:"bytes,4,opt,name=callback_data,json=callbackData,proto3" json:"callback_data,omitempty"`
	SwitchInlineQuery            string        `protobuf:"bytes,5,opt,name=switch_inline_query,json=switchInlineQuery,proto3" json:"switch_inline_query,omitempty"`
	SwitchInlineQueryCurrentChat string        `protobuf:"bytes,6,opt,name=switch_inline_query_current_chat,json=switchInlineQueryCurrentChat,proto3" json:"switch_inline_query_current_chat,omitempty"`
	CallbackGame                 *CallbackGame `protobuf:"bytes,7,opt,name=callback_game,json=callbackGame" json:"callback_game,omitempty"`
	Pay                          bool          `protobuf:"varint,8,opt,name=pay,proto3" json:"pay,omitempty"`
}

func (m *InlineKeyboardButton) Reset()                    { *m = InlineKeyboardButton{} }
func (m *InlineKeyboardButton) String() string            { return proto.CompactTextString(m) }
func (*InlineKeyboardButton) ProtoMessage()               {}
func (*InlineKeyboardButton) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{24} }

func (m *InlineKeyboardButton) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *InlineKeyboardButton) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *InlineKeyboardButton) GetLoginUrl() *LoginUrl {
	if m != nil {
		return m.LoginUrl
	}
	return nil
}

func (m *InlineKeyboardButton) GetCallbackData() string {
	if m != nil {
		return m.CallbackData
	}
	return ""
}

func (m *InlineKeyboardButton) GetSwitchInlineQuery() string {
	if m != nil {
		return m.SwitchInlineQuery
	}
	return ""
}

func (m *InlineKeyboardButton) GetSwitchInlineQueryCurrentChat() string {
	if m != nil {
		return m.SwitchInlineQueryCurrentChat
	}
	return ""
}

func (m *InlineKeyboardButton) GetCallbackGame() *CallbackGame {
	if m != nil {
		return m.CallbackGame
	}
	return nil
}

func (m *InlineKeyboardButton) GetPay() bool {
	if m != nil {
		return m.Pay
	}
	return false
}

// This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a great replacement for the Telegram Login Widget when the user is coming from Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:
// Telegram apps support these buttons as of version 5.7.
// Sample bot: @discussbot
//
type LoginUrl struct {
	Url                string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	ForwardText        string `protobuf:"bytes,2,opt,name=forward_text,json=forwardText,proto3" json:"forward_text,omitempty"`
	BotUsername        string `protobuf:"bytes,3,opt,name=bot_username,json=botUsername,proto3" json:"bot_username,omitempty"`
	RequestWriteAccess bool   `protobuf:"varint,4,opt,name=request_write_access,json=requestWriteAccess,proto3" json:"request_write_access,omitempty"`
}

func (m *LoginUrl) Reset()                    { *m = LoginUrl{} }
func (m *LoginUrl) String() string            { return proto.CompactTextString(m) }
func (*LoginUrl) ProtoMessage()               {}
func (*LoginUrl) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{25} }

func (m *LoginUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *LoginUrl) GetForwardText() string {
	if m != nil {
		return m.ForwardText
	}
	return ""
}

func (m *LoginUrl) GetBotUsername() string {
	if m != nil {
		return m.BotUsername
	}
	return ""
}

func (m *LoginUrl) GetRequestWriteAccess() bool {
	if m != nil {
		return m.RequestWriteAccess
	}
	return false
}

// This object represents an incoming callback query from a callback button in an inline keyboard. If the button that originated the query was attached to a message sent by the bot, the field message will be present. If the button was attached to a message sent via the bot (in inline mode), the field inline_message_id will be present. Exactly one of the fields data or game_short_name will be present.
// NOTE: After the user presses a callback button, Telegram clients will display a progress bar until you call answerCallbackQuery. It is, therefore, necessary to react by calling answerCallbackQuery even if no notification to the user is needed (e.g., without specifying any of the optional parameters).
//
type CallbackQuery struct {
	Id              string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	From            *User    `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	Message         *Message `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	InlineMessageId string   `protobuf:"bytes,4,opt,name=inline_message_id,json=inlineMessageId,proto3" json:"inline_message_id,omitempty"`
	ChatInstance    string   `protobuf:"bytes,5,opt,name=chat_instance,json=chatInstance,proto3" json:"chat_instance,omitempty"`
	Data            string   `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	GameShortName   string   `protobuf:"bytes,7,opt,name=game_short_name,json=gameShortName,proto3" json:"game_short_name,omitempty"`
}

func (m *CallbackQuery) Reset()                    { *m = CallbackQuery{} }
func (m *CallbackQuery) String() string            { return proto.CompactTextString(m) }
func (*CallbackQuery) ProtoMessage()               {}
func (*CallbackQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{26} }

func (m *CallbackQuery) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CallbackQuery) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *CallbackQuery) GetMessage() *Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *CallbackQuery) GetInlineMessageId() string {
	if m != nil {
		return m.InlineMessageId
	}
	return ""
}

func (m *CallbackQuery) GetChatInstance() string {
	if m != nil {
		return m.ChatInstance
	}
	return ""
}

func (m *CallbackQuery) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *CallbackQuery) GetGameShortName() string {
	if m != nil {
		return m.GameShortName
	}
	return ""
}

// Upon receiving a message with this object, Telegram clients will display a reply interface to the user (act as if the user has selected the botâ€˜s message and tapped â€™Reply'). This can be extremely useful if you want to create user-friendly step-by-step interfaces without having to sacrifice privacy mode.
// Example: A poll bot for groups runs in privacy mode (only receives commands, replies to its messages and mentions). There could be two ways to create a new poll:
//
// Explain the user how to send a command with parameters (e.g. /newpoll question answer1 answer2). May be appealing for hardcore users but lacks modern day polish.
// Guide the user through a step-by-step process. â€˜Please send me your questionâ€™, â€˜Cool, now letâ€™s add the first answer optionâ€˜, â€™Great. Keep adding answer options, then send /done when youâ€˜re readyâ€™.
//
// The last option is definitely more attractive. And if you use ForceReply in your botâ€˜s questions, it will receive the userâ€™s answers even if it only receives replies, commands and mentions â€” without any extra work for the user.
//
type ForceReply struct {
	ForceReply bool `protobuf:"varint,1,opt,name=force_reply,json=forceReply,proto3" json:"force_reply,omitempty"`
	Selective  bool `protobuf:"varint,2,opt,name=selective,proto3" json:"selective,omitempty"`
}

func (m *ForceReply) Reset()                    { *m = ForceReply{} }
func (m *ForceReply) String() string            { return proto.CompactTextString(m) }
func (*ForceReply) ProtoMessage()               {}
func (*ForceReply) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{27} }

func (m *ForceReply) GetForceReply() bool {
	if m != nil {
		return m.ForceReply
	}
	return false
}

func (m *ForceReply) GetSelective() bool {
	if m != nil {
		return m.Selective
	}
	return false
}

// This object represents a chat photo.
type ChatPhoto struct {
	SmallFileId string `protobuf:"bytes,1,opt,name=small_file_id,json=smallFileId,proto3" json:"small_file_id,omitempty"`
	BigFileId   string `protobuf:"bytes,2,opt,name=big_file_id,json=bigFileId,proto3" json:"big_file_id,omitempty"`
}

func (m *ChatPhoto) Reset()                    { *m = ChatPhoto{} }
func (m *ChatPhoto) String() string            { return proto.CompactTextString(m) }
func (*ChatPhoto) ProtoMessage()               {}
func (*ChatPhoto) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{28} }

func (m *ChatPhoto) GetSmallFileId() string {
	if m != nil {
		return m.SmallFileId
	}
	return ""
}

func (m *ChatPhoto) GetBigFileId() string {
	if m != nil {
		return m.BigFileId
	}
	return ""
}

// This object contains information about one member of a chat.
type ChatMember struct {
	User                  *User  `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	Status                string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	UntilDate             int32  `protobuf:"varint,3,opt,name=until_date,json=untilDate,proto3" json:"until_date,omitempty"`
	CanBeEdited           bool   `protobuf:"varint,4,opt,name=can_be_edited,json=canBeEdited,proto3" json:"can_be_edited,omitempty"`
	CanPostMessages       bool   `protobuf:"varint,5,opt,name=can_post_messages,json=canPostMessages,proto3" json:"can_post_messages,omitempty"`
	CanEditMessages       bool   `protobuf:"varint,6,opt,name=can_edit_messages,json=canEditMessages,proto3" json:"can_edit_messages,omitempty"`
	CanDeleteMessages     bool   `protobuf:"varint,7,opt,name=can_delete_messages,json=canDeleteMessages,proto3" json:"can_delete_messages,omitempty"`
	CanRestrictMembers    bool   `protobuf:"varint,8,opt,name=can_restrict_members,json=canRestrictMembers,proto3" json:"can_restrict_members,omitempty"`
	CanPromoteMembers     bool   `protobuf:"varint,9,opt,name=can_promote_members,json=canPromoteMembers,proto3" json:"can_promote_members,omitempty"`
	CanChangeInfo         bool   `protobuf:"varint,10,opt,name=can_change_info,json=canChangeInfo,proto3" json:"can_change_info,omitempty"`
	CanInviteUsers        bool   `protobuf:"varint,11,opt,name=can_invite_users,json=canInviteUsers,proto3" json:"can_invite_users,omitempty"`
	CanPinMessages        bool   `protobuf:"varint,12,opt,name=can_pin_messages,json=canPinMessages,proto3" json:"can_pin_messages,omitempty"`
	IsMember              bool   `protobuf:"varint,13,opt,name=is_member,json=isMember,proto3" json:"is_member,omitempty"`
	CanSendMessages       bool   `protobuf:"varint,14,opt,name=can_send_messages,json=canSendMessages,proto3" json:"can_send_messages,omitempty"`
	CanSendMediaMessages  bool   `protobuf:"varint,15,opt,name=can_send_media_messages,json=canSendMediaMessages,proto3" json:"can_send_media_messages,omitempty"`
	CanSendPolls          bool   `protobuf:"varint,16,opt,name=can_send_polls,json=canSendPolls,proto3" json:"can_send_polls,omitempty"`
	CanSendOtherMessages  bool   `protobuf:"varint,17,opt,name=can_send_other_messages,json=canSendOtherMessages,proto3" json:"can_send_other_messages,omitempty"`
	CanAddWebPagePreviews bool   `protobuf:"varint,18,opt,name=can_add_web_page_previews,json=canAddWebPagePreviews,proto3" json:"can_add_web_page_previews,omitempty"`
}

func (m *ChatMember) Reset()                    { *m = ChatMember{} }
func (m *ChatMember) String() string            { return proto.CompactTextString(m) }
func (*ChatMember) ProtoMessage()               {}
func (*ChatMember) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{29} }

func (m *ChatMember) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ChatMember) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ChatMember) GetUntilDate() int32 {
	if m != nil {
		return m.UntilDate
	}
	return 0
}

func (m *ChatMember) GetCanBeEdited() bool {
	if m != nil {
		return m.CanBeEdited
	}
	return false
}

func (m *ChatMember) GetCanPostMessages() bool {
	if m != nil {
		return m.CanPostMessages
	}
	return false
}

func (m *ChatMember) GetCanEditMessages() bool {
	if m != nil {
		return m.CanEditMessages
	}
	return false
}

func (m *ChatMember) GetCanDeleteMessages() bool {
	if m != nil {
		return m.CanDeleteMessages
	}
	return false
}

func (m *ChatMember) GetCanRestrictMembers() bool {
	if m != nil {
		return m.CanRestrictMembers
	}
	return false
}

func (m *ChatMember) GetCanPromoteMembers() bool {
	if m != nil {
		return m.CanPromoteMembers
	}
	return false
}

func (m *ChatMember) GetCanChangeInfo() bool {
	if m != nil {
		return m.CanChangeInfo
	}
	return false
}

func (m *ChatMember) GetCanInviteUsers() bool {
	if m != nil {
		return m.CanInviteUsers
	}
	return false
}

func (m *ChatMember) GetCanPinMessages() bool {
	if m != nil {
		return m.CanPinMessages
	}
	return false
}

func (m *ChatMember) GetIsMember() bool {
	if m != nil {
		return m.IsMember
	}
	return false
}

func (m *ChatMember) GetCanSendMessages() bool {
	if m != nil {
		return m.CanSendMessages
	}
	return false
}

func (m *ChatMember) GetCanSendMediaMessages() bool {
	if m != nil {
		return m.CanSendMediaMessages
	}
	return false
}

func (m *ChatMember) GetCanSendPolls() bool {
	if m != nil {
		return m.CanSendPolls
	}
	return false
}

func (m *ChatMember) GetCanSendOtherMessages() bool {
	if m != nil {
		return m.CanSendOtherMessages
	}
	return false
}

func (m *ChatMember) GetCanAddWebPagePreviews() bool {
	if m != nil {
		return m.CanAddWebPagePreviews
	}
	return false
}

// Describes actions that a non-administrator user is allowed to take in a chat.
type ChatPermissions struct {
	CanSendMessages       bool `protobuf:"varint,1,opt,name=can_send_messages,json=canSendMessages,proto3" json:"can_send_messages,omitempty"`
	CanSendMediaMessages  bool `protobuf:"varint,2,opt,name=can_send_media_messages,json=canSendMediaMessages,proto3" json:"can_send_media_messages,omitempty"`
	CanSendPolls          bool `protobuf:"varint,3,opt,name=can_send_polls,json=canSendPolls,proto3" json:"can_send_polls,omitempty"`
	CanSendOtherMessages  bool `protobuf:"varint,4,opt,name=can_send_other_messages,json=canSendOtherMessages,proto3" json:"can_send_other_messages,omitempty"`
	CanAddWebPagePreviews bool `protobuf:"varint,5,opt,name=can_add_web_page_previews,json=canAddWebPagePreviews,proto3" json:"can_add_web_page_previews,omitempty"`
	CanChangeInfo         bool `protobuf:"varint,6,opt,name=can_change_info,json=canChangeInfo,proto3" json:"can_change_info,omitempty"`
	CanInviteUsers        bool `protobuf:"varint,7,opt,name=can_invite_users,json=canInviteUsers,proto3" json:"can_invite_users,omitempty"`
	CanPinMessages        bool `protobuf:"varint,8,opt,name=can_pin_messages,json=canPinMessages,proto3" json:"can_pin_messages,omitempty"`
}

func (m *ChatPermissions) Reset()                    { *m = ChatPermissions{} }
func (m *ChatPermissions) String() string            { return proto.CompactTextString(m) }
func (*ChatPermissions) ProtoMessage()               {}
func (*ChatPermissions) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{30} }

func (m *ChatPermissions) GetCanSendMessages() bool {
	if m != nil {
		return m.CanSendMessages
	}
	return false
}

func (m *ChatPermissions) GetCanSendMediaMessages() bool {
	if m != nil {
		return m.CanSendMediaMessages
	}
	return false
}

func (m *ChatPermissions) GetCanSendPolls() bool {
	if m != nil {
		return m.CanSendPolls
	}
	return false
}

func (m *ChatPermissions) GetCanSendOtherMessages() bool {
	if m != nil {
		return m.CanSendOtherMessages
	}
	return false
}

func (m *ChatPermissions) GetCanAddWebPagePreviews() bool {
	if m != nil {
		return m.CanAddWebPagePreviews
	}
	return false
}

func (m *ChatPermissions) GetCanChangeInfo() bool {
	if m != nil {
		return m.CanChangeInfo
	}
	return false
}

func (m *ChatPermissions) GetCanInviteUsers() bool {
	if m != nil {
		return m.CanInviteUsers
	}
	return false
}

func (m *ChatPermissions) GetCanPinMessages() bool {
	if m != nil {
		return m.CanPinMessages
	}
	return false
}

// Contains information about why a request was unsuccessful.
// This object represents the content of a media message to be sent. It should be one of
// InputMediaAnimation
// InputMediaDocument
// InputMediaAudio
// InputMediaPhoto
// InputMediaVideo
type ResponseParameters struct {
	MigrateToChatId int32 `protobuf:"varint,1,opt,name=migrate_to_chat_id,json=migrateToChatId,proto3" json:"migrate_to_chat_id,omitempty"`
	RetryAfter      int32 `protobuf:"varint,2,opt,name=retry_after,json=retryAfter,proto3" json:"retry_after,omitempty"`
}

func (m *ResponseParameters) Reset()                    { *m = ResponseParameters{} }
func (m *ResponseParameters) String() string            { return proto.CompactTextString(m) }
func (*ResponseParameters) ProtoMessage()               {}
func (*ResponseParameters) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{31} }

func (m *ResponseParameters) GetMigrateToChatId() int32 {
	if m != nil {
		return m.MigrateToChatId
	}
	return 0
}

func (m *ResponseParameters) GetRetryAfter() int32 {
	if m != nil {
		return m.RetryAfter
	}
	return 0
}

// Represents a photo to be sent.
type InputMediaPhoto struct {
	Type      string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Media     string `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Caption   string `protobuf:"bytes,3,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode string `protobuf:"bytes,4,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
}

func (m *InputMediaPhoto) Reset()                    { *m = InputMediaPhoto{} }
func (m *InputMediaPhoto) String() string            { return proto.CompactTextString(m) }
func (*InputMediaPhoto) ProtoMessage()               {}
func (*InputMediaPhoto) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{32} }

func (m *InputMediaPhoto) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InputMediaPhoto) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *InputMediaPhoto) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaPhoto) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

// Represents a video to be sent.
type InputMediaVideo struct {
	Type              string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Media             string `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Thumb             string `protobuf:"bytes,3,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption           string `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode         string `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	Width             int32  `protobuf:"varint,6,opt,name=width,proto3" json:"width,omitempty"`
	Height            int32  `protobuf:"varint,7,opt,name=height,proto3" json:"height,omitempty"`
	Duration          int32  `protobuf:"varint,8,opt,name=duration,proto3" json:"duration,omitempty"`
	SupportsStreaming bool   `protobuf:"varint,9,opt,name=supports_streaming,json=supportsStreaming,proto3" json:"supports_streaming,omitempty"`
}

func (m *InputMediaVideo) Reset()                    { *m = InputMediaVideo{} }
func (m *InputMediaVideo) String() string            { return proto.CompactTextString(m) }
func (*InputMediaVideo) ProtoMessage()               {}
func (*InputMediaVideo) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{33} }

func (m *InputMediaVideo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InputMediaVideo) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *InputMediaVideo) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *InputMediaVideo) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaVideo) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InputMediaVideo) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *InputMediaVideo) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *InputMediaVideo) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *InputMediaVideo) GetSupportsStreaming() bool {
	if m != nil {
		return m.SupportsStreaming
	}
	return false
}

// Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent.
type InputMediaAnimation struct {
	Type      string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Media     string `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Thumb     string `protobuf:"bytes,3,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption   string `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode string `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	Width     int32  `protobuf:"varint,6,opt,name=width,proto3" json:"width,omitempty"`
	Height    int32  `protobuf:"varint,7,opt,name=height,proto3" json:"height,omitempty"`
	Duration  int32  `protobuf:"varint,8,opt,name=duration,proto3" json:"duration,omitempty"`
}

func (m *InputMediaAnimation) Reset()                    { *m = InputMediaAnimation{} }
func (m *InputMediaAnimation) String() string            { return proto.CompactTextString(m) }
func (*InputMediaAnimation) ProtoMessage()               {}
func (*InputMediaAnimation) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{34} }

func (m *InputMediaAnimation) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InputMediaAnimation) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *InputMediaAnimation) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *InputMediaAnimation) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaAnimation) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InputMediaAnimation) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *InputMediaAnimation) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *InputMediaAnimation) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// Represents an audio file to be treated as music to be sent.
type InputMediaAudio struct {
	Type      string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Media     string `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Thumb     string `protobuf:"bytes,3,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption   string `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode string `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	Duration  int32  `protobuf:"varint,6,opt,name=duration,proto3" json:"duration,omitempty"`
	Performer string `protobuf:"bytes,7,opt,name=performer,proto3" json:"performer,omitempty"`
	Title     string `protobuf:"bytes,8,opt,name=title,proto3" json:"title,omitempty"`
}

func (m *InputMediaAudio) Reset()                    { *m = InputMediaAudio{} }
func (m *InputMediaAudio) String() string            { return proto.CompactTextString(m) }
func (*InputMediaAudio) ProtoMessage()               {}
func (*InputMediaAudio) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{35} }

func (m *InputMediaAudio) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InputMediaAudio) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *InputMediaAudio) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *InputMediaAudio) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaAudio) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InputMediaAudio) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *InputMediaAudio) GetPerformer() string {
	if m != nil {
		return m.Performer
	}
	return ""
}

func (m *InputMediaAudio) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

// Represents a general file to be sent.
type InputMediaDocument struct {
	Type      string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Media     string `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Thumb     string `protobuf:"bytes,3,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption   string `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode string `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
}

func (m *InputMediaDocument) Reset()                    { *m = InputMediaDocument{} }
func (m *InputMediaDocument) String() string            { return proto.CompactTextString(m) }
func (*InputMediaDocument) ProtoMessage()               {}
func (*InputMediaDocument) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{36} }

func (m *InputMediaDocument) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InputMediaDocument) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *InputMediaDocument) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *InputMediaDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InputMediaDocument) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

// This object represents the contents of a file to be uploaded. Must be posted using multipart/form-data in the usual way that files are uploaded via the browser.
//  There are three ways to send files (photos, stickers, audio, media, etc.):
// Sending by file_id
// file_id
// file_id
// Sending by URL
// Objects and methods used in the inline mode are described in the Inline mode section.
type InputFile struct {
}

func (m *InputFile) Reset()                    { *m = InputFile{} }
func (m *InputFile) String() string            { return proto.CompactTextString(m) }
func (*InputFile) ProtoMessage()               {}
func (*InputFile) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{37} }

// Use this method to send answers to callback queries sent from inline keyboards. The answer will be displayed to the user as a notification at the top of the chat screen or as an alert. On success, True is returned.
// Alternatively, the user can be redirected to the specified Game URL. For this option to work, you must first create a game for your bot via @Botfather and accept the terms. Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with a parameter.
//
// Methods and objects used in the inline mode are described in the Inline mode section.
type AnswerCallbackQuery struct {
	CallbackQueryId string `protobuf:"bytes,1,opt,name=callback_query_id,json=callbackQueryId,proto3" json:"callback_query_id,omitempty"`
	Text            string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	ShowAlert       bool   `protobuf:"varint,3,opt,name=show_alert,json=showAlert,proto3" json:"show_alert,omitempty"`
	Url             string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	CacheTime       int32  `protobuf:"varint,5,opt,name=cache_time,json=cacheTime,proto3" json:"cache_time,omitempty"`
}

func (m *AnswerCallbackQuery) Reset()                    { *m = AnswerCallbackQuery{} }
func (m *AnswerCallbackQuery) String() string            { return proto.CompactTextString(m) }
func (*AnswerCallbackQuery) ProtoMessage()               {}
func (*AnswerCallbackQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{38} }

func (m *AnswerCallbackQuery) GetCallbackQueryId() string {
	if m != nil {
		return m.CallbackQueryId
	}
	return ""
}

func (m *AnswerCallbackQuery) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *AnswerCallbackQuery) GetShowAlert() bool {
	if m != nil {
		return m.ShowAlert
	}
	return false
}

func (m *AnswerCallbackQuery) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *AnswerCallbackQuery) GetCacheTime() int32 {
	if m != nil {
		return m.CacheTime
	}
	return 0
}

// The following methods allow you to change an existing message in the message history instead of sending a new one with a result of an action. This is most useful for messages with inline keyboards using callback queries, but can also help reduce clutter in conversations with regular chat bots.
// Please note, that it is currently only possible to edit messages without reply_markup or with inline keyboards.
// The following methods and objects allow your bot to handle stickers and sticker sets.
// This object represents a sticker.
type Sticker struct {
	FileId       string        `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Width        int32         `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height       int32         `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	IsAnimated   bool          `protobuf:"varint,4,opt,name=is_animated,json=isAnimated,proto3" json:"is_animated,omitempty"`
	Thumb        *PhotoSize    `protobuf:"bytes,5,opt,name=thumb" json:"thumb,omitempty"`
	Emoji        string        `protobuf:"bytes,6,opt,name=emoji,proto3" json:"emoji,omitempty"`
	SetName      string        `protobuf:"bytes,7,opt,name=set_name,json=setName,proto3" json:"set_name,omitempty"`
	MaskPosition *MaskPosition `protobuf:"bytes,8,opt,name=mask_position,json=maskPosition" json:"mask_position,omitempty"`
	FileSize     int32         `protobuf:"varint,9,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *Sticker) Reset()                    { *m = Sticker{} }
func (m *Sticker) String() string            { return proto.CompactTextString(m) }
func (*Sticker) ProtoMessage()               {}
func (*Sticker) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{39} }

func (m *Sticker) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *Sticker) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Sticker) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Sticker) GetIsAnimated() bool {
	if m != nil {
		return m.IsAnimated
	}
	return false
}

func (m *Sticker) GetThumb() *PhotoSize {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *Sticker) GetEmoji() string {
	if m != nil {
		return m.Emoji
	}
	return ""
}

func (m *Sticker) GetSetName() string {
	if m != nil {
		return m.SetName
	}
	return ""
}

func (m *Sticker) GetMaskPosition() *MaskPosition {
	if m != nil {
		return m.MaskPosition
	}
	return nil
}

func (m *Sticker) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// This object represents a sticker set.
type StickerSet struct {
	Name          string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Title         string     `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	IsAnimated    bool       `protobuf:"varint,3,opt,name=is_animated,json=isAnimated,proto3" json:"is_animated,omitempty"`
	ContainsMasks bool       `protobuf:"varint,4,opt,name=contains_masks,json=containsMasks,proto3" json:"contains_masks,omitempty"`
	Stickers      []*Sticker `protobuf:"bytes,5,rep,name=stickers" json:"stickers,omitempty"`
}

func (m *StickerSet) Reset()                    { *m = StickerSet{} }
func (m *StickerSet) String() string            { return proto.CompactTextString(m) }
func (*StickerSet) ProtoMessage()               {}
func (*StickerSet) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{40} }

func (m *StickerSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StickerSet) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *StickerSet) GetIsAnimated() bool {
	if m != nil {
		return m.IsAnimated
	}
	return false
}

func (m *StickerSet) GetContainsMasks() bool {
	if m != nil {
		return m.ContainsMasks
	}
	return false
}

func (m *StickerSet) GetStickers() []*Sticker {
	if m != nil {
		return m.Stickers
	}
	return nil
}

// This object describes the position on faces where a mask should be placed by default.
type MaskPosition struct {
	Point  string `protobuf:"bytes,1,opt,name=point,proto3" json:"point,omitempty"`
	XShift int64  `protobuf:"varint,2,opt,name=x_shift,json=xShift,proto3" json:"x_shift,omitempty"`
	YShift int64  `protobuf:"varint,3,opt,name=y_shift,json=yShift,proto3" json:"y_shift,omitempty"`
	Scale  int64  `protobuf:"varint,4,opt,name=scale,proto3" json:"scale,omitempty"`
}

func (m *MaskPosition) Reset()                    { *m = MaskPosition{} }
func (m *MaskPosition) String() string            { return proto.CompactTextString(m) }
func (*MaskPosition) ProtoMessage()               {}
func (*MaskPosition) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{41} }

func (m *MaskPosition) GetPoint() string {
	if m != nil {
		return m.Point
	}
	return ""
}

func (m *MaskPosition) GetXShift() int64 {
	if m != nil {
		return m.XShift
	}
	return 0
}

func (m *MaskPosition) GetYShift() int64 {
	if m != nil {
		return m.YShift
	}
	return 0
}

func (m *MaskPosition) GetScale() int64 {
	if m != nil {
		return m.Scale
	}
	return 0
}

// Use this method to add a new sticker to a set created by the bot. Returns True on success.
type AddStickerToSet struct {
	UserId       int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Name         string        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	PngSticker   string        `protobuf:"bytes,3,opt,name=png_sticker,json=pngSticker,proto3" json:"png_sticker,omitempty"`
	Emojis       string        `protobuf:"bytes,4,opt,name=emojis,proto3" json:"emojis,omitempty"`
	MaskPosition *MaskPosition `protobuf:"bytes,5,opt,name=mask_position,json=maskPosition" json:"mask_position,omitempty"`
}

func (m *AddStickerToSet) Reset()                    { *m = AddStickerToSet{} }
func (m *AddStickerToSet) String() string            { return proto.CompactTextString(m) }
func (*AddStickerToSet) ProtoMessage()               {}
func (*AddStickerToSet) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{42} }

func (m *AddStickerToSet) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AddStickerToSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AddStickerToSet) GetPngSticker() string {
	if m != nil {
		return m.PngSticker
	}
	return ""
}

func (m *AddStickerToSet) GetEmojis() string {
	if m != nil {
		return m.Emojis
	}
	return ""
}

func (m *AddStickerToSet) GetMaskPosition() *MaskPosition {
	if m != nil {
		return m.MaskPosition
	}
	return nil
}

// The following methods and objects allow your bot to work in inline mode.Please see our Introduction to Inline bots for more details.
// To enable this option, send the /setinline command to @BotFather and provide the placeholder text that the user will see in the input field after typing your botâ€™s name.
// This object represents an incoming inline query. When the user sends an empty query, your bot could return some default or trending results.
type InlineQuery struct {
	Id       string    `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	From     *User     `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	Location *Location `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	Query    string    `protobuf:"bytes,4,opt,name=query,proto3" json:"query,omitempty"`
	Offset   string    `protobuf:"bytes,5,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *InlineQuery) Reset()                    { *m = InlineQuery{} }
func (m *InlineQuery) String() string            { return proto.CompactTextString(m) }
func (*InlineQuery) ProtoMessage()               {}
func (*InlineQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{43} }

func (m *InlineQuery) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQuery) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *InlineQuery) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *InlineQuery) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *InlineQuery) GetOffset() string {
	if m != nil {
		return m.Offset
	}
	return ""
}

// Use this method to send answers to an inline query. On success, True is returned.No more than 50 results per query are allowed.
type AnswerInlineQuery struct {
	InlineQueryId     string               `protobuf:"bytes,1,opt,name=inline_query_id,json=inlineQueryId,proto3" json:"inline_query_id,omitempty"`
	Results           []*InlineQueryResult `protobuf:"bytes,2,rep,name=results" json:"results,omitempty"`
	CacheTime         int32                `protobuf:"varint,3,opt,name=cache_time,json=cacheTime,proto3" json:"cache_time,omitempty"`
	IsPersonal        bool                 `protobuf:"varint,4,opt,name=is_personal,json=isPersonal,proto3" json:"is_personal,omitempty"`
	NextOffset        string               `protobuf:"bytes,5,opt,name=next_offset,json=nextOffset,proto3" json:"next_offset,omitempty"`
	SwitchPmText      string               `protobuf:"bytes,6,opt,name=switch_pm_text,json=switchPmText,proto3" json:"switch_pm_text,omitempty"`
	SwitchPmParameter string               `protobuf:"bytes,7,opt,name=switch_pm_parameter,json=switchPmParameter,proto3" json:"switch_pm_parameter,omitempty"`
}

func (m *AnswerInlineQuery) Reset()                    { *m = AnswerInlineQuery{} }
func (m *AnswerInlineQuery) String() string            { return proto.CompactTextString(m) }
func (*AnswerInlineQuery) ProtoMessage()               {}
func (*AnswerInlineQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{44} }

func (m *AnswerInlineQuery) GetInlineQueryId() string {
	if m != nil {
		return m.InlineQueryId
	}
	return ""
}

func (m *AnswerInlineQuery) GetResults() []*InlineQueryResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *AnswerInlineQuery) GetCacheTime() int32 {
	if m != nil {
		return m.CacheTime
	}
	return 0
}

func (m *AnswerInlineQuery) GetIsPersonal() bool {
	if m != nil {
		return m.IsPersonal
	}
	return false
}

func (m *AnswerInlineQuery) GetNextOffset() string {
	if m != nil {
		return m.NextOffset
	}
	return ""
}

func (m *AnswerInlineQuery) GetSwitchPmText() string {
	if m != nil {
		return m.SwitchPmText
	}
	return ""
}

func (m *AnswerInlineQuery) GetSwitchPmParameter() string {
	if m != nil {
		return m.SwitchPmParameter
	}
	return ""
}

// This object represents one result of an inline query. Telegram clients currently support results of the following 20 types:
// InlineQueryResultCachedAudio
// InlineQueryResultCachedDocument
// InlineQueryResultCachedGif
// InlineQueryResultCachedMpeg4Gif
// InlineQueryResultCachedPhoto
// InlineQueryResultCachedSticker
// InlineQueryResultCachedVideo
// InlineQueryResultCachedVoice
// InlineQueryResultArticle
// InlineQueryResultAudio
// InlineQueryResultContact
// InlineQueryResultGame
// InlineQueryResultDocument
// InlineQueryResultGif
// InlineQueryResultLocation
// InlineQueryResultMpeg4Gif
// InlineQueryResultPhoto
// InlineQueryResultVenue
// InlineQueryResultVideo
// InlineQueryResultVoice
type InlineQueryResult struct {
}

func (m *InlineQueryResult) Reset()                    { *m = InlineQueryResult{} }
func (m *InlineQueryResult) String() string            { return proto.CompactTextString(m) }
func (*InlineQueryResult) ProtoMessage()               {}
func (*InlineQueryResult) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{45} }

// Represents a link to an article or web page.
type InlineQueryResultArticle struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Title               string                `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,4,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,5,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	Url                 string                `protobuf:"bytes,6,opt,name=url,proto3" json:"url,omitempty"`
	HideUrl             bool                  `protobuf:"varint,7,opt,name=hide_url,json=hideUrl,proto3" json:"hide_url,omitempty"`
	Description         string                `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	ThumbUrl            string                `protobuf:"bytes,9,opt,name=thumb_url,json=thumbUrl,proto3" json:"thumb_url,omitempty"`
	ThumbWidth          int32                 `protobuf:"varint,10,opt,name=thumb_width,json=thumbWidth,proto3" json:"thumb_width,omitempty"`
	ThumbHeight         int32                 `protobuf:"varint,11,opt,name=thumb_height,json=thumbHeight,proto3" json:"thumb_height,omitempty"`
}

func (m *InlineQueryResultArticle) Reset()         { *m = InlineQueryResultArticle{} }
func (m *InlineQueryResultArticle) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultArticle) ProtoMessage()    {}
func (*InlineQueryResultArticle) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{46}
}

func (m *InlineQueryResultArticle) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultArticle) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultArticle) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultArticle) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

func (m *InlineQueryResultArticle) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultArticle) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *InlineQueryResultArticle) GetHideUrl() bool {
	if m != nil {
		return m.HideUrl
	}
	return false
}

func (m *InlineQueryResultArticle) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *InlineQueryResultArticle) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *InlineQueryResultArticle) GetThumbWidth() int32 {
	if m != nil {
		return m.ThumbWidth
	}
	return 0
}

func (m *InlineQueryResultArticle) GetThumbHeight() int32 {
	if m != nil {
		return m.ThumbHeight
	}
	return 0
}

// Represents a link to a photo. By default, this photo will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the photo.
type InlineQueryResultPhoto struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	PhotoUrl            string                `protobuf:"bytes,3,opt,name=photo_url,json=photoUrl,proto3" json:"photo_url,omitempty"`
	ThumbUrl            string                `protobuf:"bytes,4,opt,name=thumb_url,json=thumbUrl,proto3" json:"thumb_url,omitempty"`
	PhotoWidth          int32                 `protobuf:"varint,5,opt,name=photo_width,json=photoWidth,proto3" json:"photo_width,omitempty"`
	PhotoHeight         int32                 `protobuf:"varint,6,opt,name=photo_height,json=photoHeight,proto3" json:"photo_height,omitempty"`
	Title               string                `protobuf:"bytes,7,opt,name=title,proto3" json:"title,omitempty"`
	Description         string                `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	Caption             string                `protobuf:"bytes,9,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,10,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,11,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,12,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultPhoto) Reset()                    { *m = InlineQueryResultPhoto{} }
func (m *InlineQueryResultPhoto) String() string            { return proto.CompactTextString(m) }
func (*InlineQueryResultPhoto) ProtoMessage()               {}
func (*InlineQueryResultPhoto) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{47} }

func (m *InlineQueryResultPhoto) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultPhoto) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultPhoto) GetPhotoUrl() string {
	if m != nil {
		return m.PhotoUrl
	}
	return ""
}

func (m *InlineQueryResultPhoto) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *InlineQueryResultPhoto) GetPhotoWidth() int32 {
	if m != nil {
		return m.PhotoWidth
	}
	return 0
}

func (m *InlineQueryResultPhoto) GetPhotoHeight() int32 {
	if m != nil {
		return m.PhotoHeight
	}
	return 0
}

func (m *InlineQueryResultPhoto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultPhoto) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *InlineQueryResultPhoto) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultPhoto) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultPhoto) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultPhoto) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to an animated GIF file. By default, this animated GIF file will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation.
type InlineQueryResultGif struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	GifUrl              string                `protobuf:"bytes,3,opt,name=gif_url,json=gifUrl,proto3" json:"gif_url,omitempty"`
	GifWidth            int32                 `protobuf:"varint,4,opt,name=gif_width,json=gifWidth,proto3" json:"gif_width,omitempty"`
	GifHeight           int32                 `protobuf:"varint,5,opt,name=gif_height,json=gifHeight,proto3" json:"gif_height,omitempty"`
	GifDuration         int32                 `protobuf:"varint,6,opt,name=gif_duration,json=gifDuration,proto3" json:"gif_duration,omitempty"`
	ThumbUrl            string                `protobuf:"bytes,7,opt,name=thumb_url,json=thumbUrl,proto3" json:"thumb_url,omitempty"`
	Title               string                `protobuf:"bytes,8,opt,name=title,proto3" json:"title,omitempty"`
	Caption             string                `protobuf:"bytes,9,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,10,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,11,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,12,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultGif) Reset()                    { *m = InlineQueryResultGif{} }
func (m *InlineQueryResultGif) String() string            { return proto.CompactTextString(m) }
func (*InlineQueryResultGif) ProtoMessage()               {}
func (*InlineQueryResultGif) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{48} }

func (m *InlineQueryResultGif) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultGif) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultGif) GetGifUrl() string {
	if m != nil {
		return m.GifUrl
	}
	return ""
}

func (m *InlineQueryResultGif) GetGifWidth() int32 {
	if m != nil {
		return m.GifWidth
	}
	return 0
}

func (m *InlineQueryResultGif) GetGifHeight() int32 {
	if m != nil {
		return m.GifHeight
	}
	return 0
}

func (m *InlineQueryResultGif) GetGifDuration() int32 {
	if m != nil {
		return m.GifDuration
	}
	return 0
}

func (m *InlineQueryResultGif) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *InlineQueryResultGif) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultGif) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultGif) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultGif) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultGif) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound). By default, this animated MPEG-4 file will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation.
type InlineQueryResultMpeg4Gif struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Mpeg4Url            string                `protobuf:"bytes,3,opt,name=mpeg4_url,json=mpeg4Url,proto3" json:"mpeg4_url,omitempty"`
	Mpeg4Width          int32                 `protobuf:"varint,4,opt,name=mpeg4_width,json=mpeg4Width,proto3" json:"mpeg4_width,omitempty"`
	Mpeg4Height         int32                 `protobuf:"varint,5,opt,name=mpeg4_height,json=mpeg4Height,proto3" json:"mpeg4_height,omitempty"`
	Mpeg4Duration       int32                 `protobuf:"varint,6,opt,name=mpeg4_duration,json=mpeg4Duration,proto3" json:"mpeg4_duration,omitempty"`
	ThumbUrl            string                `protobuf:"bytes,7,opt,name=thumb_url,json=thumbUrl,proto3" json:"thumb_url,omitempty"`
	Title               string                `protobuf:"bytes,8,opt,name=title,proto3" json:"title,omitempty"`
	Caption             string                `protobuf:"bytes,9,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,10,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,11,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,12,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultMpeg4Gif) Reset()         { *m = InlineQueryResultMpeg4Gif{} }
func (m *InlineQueryResultMpeg4Gif) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultMpeg4Gif) ProtoMessage()    {}
func (*InlineQueryResultMpeg4Gif) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{49}
}

func (m *InlineQueryResultMpeg4Gif) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultMpeg4Gif) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultMpeg4Gif) GetMpeg4Url() string {
	if m != nil {
		return m.Mpeg4Url
	}
	return ""
}

func (m *InlineQueryResultMpeg4Gif) GetMpeg4Width() int32 {
	if m != nil {
		return m.Mpeg4Width
	}
	return 0
}

func (m *InlineQueryResultMpeg4Gif) GetMpeg4Height() int32 {
	if m != nil {
		return m.Mpeg4Height
	}
	return 0
}

func (m *InlineQueryResultMpeg4Gif) GetMpeg4Duration() int32 {
	if m != nil {
		return m.Mpeg4Duration
	}
	return 0
}

func (m *InlineQueryResultMpeg4Gif) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *InlineQueryResultMpeg4Gif) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultMpeg4Gif) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultMpeg4Gif) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultMpeg4Gif) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultMpeg4Gif) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to a page containing an embedded video player or a video file. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the video.
// If an InlineQueryResultVideo message contains an embedded video (e.g., YouTube), you must replace its content using input_message_content.
//
type InlineQueryResultVideo struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	VideoUrl            string                `protobuf:"bytes,3,opt,name=video_url,json=videoUrl,proto3" json:"video_url,omitempty"`
	MimeType            string                `protobuf:"bytes,4,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	ThumbUrl            string                `protobuf:"bytes,5,opt,name=thumb_url,json=thumbUrl,proto3" json:"thumb_url,omitempty"`
	Title               string                `protobuf:"bytes,6,opt,name=title,proto3" json:"title,omitempty"`
	Caption             string                `protobuf:"bytes,7,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,8,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	VideoWidth          int32                 `protobuf:"varint,9,opt,name=video_width,json=videoWidth,proto3" json:"video_width,omitempty"`
	VideoHeight         int32                 `protobuf:"varint,10,opt,name=video_height,json=videoHeight,proto3" json:"video_height,omitempty"`
	VideoDuration       int32                 `protobuf:"varint,11,opt,name=video_duration,json=videoDuration,proto3" json:"video_duration,omitempty"`
	Description         string                `protobuf:"bytes,12,opt,name=description,proto3" json:"description,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,13,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,14,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultVideo) Reset()                    { *m = InlineQueryResultVideo{} }
func (m *InlineQueryResultVideo) String() string            { return proto.CompactTextString(m) }
func (*InlineQueryResultVideo) ProtoMessage()               {}
func (*InlineQueryResultVideo) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{50} }

func (m *InlineQueryResultVideo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultVideo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultVideo) GetVideoUrl() string {
	if m != nil {
		return m.VideoUrl
	}
	return ""
}

func (m *InlineQueryResultVideo) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *InlineQueryResultVideo) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *InlineQueryResultVideo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultVideo) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultVideo) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultVideo) GetVideoWidth() int32 {
	if m != nil {
		return m.VideoWidth
	}
	return 0
}

func (m *InlineQueryResultVideo) GetVideoHeight() int32 {
	if m != nil {
		return m.VideoHeight
	}
	return 0
}

func (m *InlineQueryResultVideo) GetVideoDuration() int32 {
	if m != nil {
		return m.VideoDuration
	}
	return 0
}

func (m *InlineQueryResultVideo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *InlineQueryResultVideo) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultVideo) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to an mp3 audio file. By default, this audio file will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the audio.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type InlineQueryResultAudio struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	AudioUrl            string                `protobuf:"bytes,3,opt,name=audio_url,json=audioUrl,proto3" json:"audio_url,omitempty"`
	Title               string                `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	Caption             string                `protobuf:"bytes,5,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,6,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	Performer           string                `protobuf:"bytes,7,opt,name=performer,proto3" json:"performer,omitempty"`
	AudioDuration       int32                 `protobuf:"varint,8,opt,name=audio_duration,json=audioDuration,proto3" json:"audio_duration,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,9,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,10,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultAudio) Reset()                    { *m = InlineQueryResultAudio{} }
func (m *InlineQueryResultAudio) String() string            { return proto.CompactTextString(m) }
func (*InlineQueryResultAudio) ProtoMessage()               {}
func (*InlineQueryResultAudio) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{51} }

func (m *InlineQueryResultAudio) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultAudio) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultAudio) GetAudioUrl() string {
	if m != nil {
		return m.AudioUrl
	}
	return ""
}

func (m *InlineQueryResultAudio) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultAudio) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultAudio) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultAudio) GetPerformer() string {
	if m != nil {
		return m.Performer
	}
	return ""
}

func (m *InlineQueryResultAudio) GetAudioDuration() int32 {
	if m != nil {
		return m.AudioDuration
	}
	return 0
}

func (m *InlineQueryResultAudio) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultAudio) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to a voice recording in an .ogg container encoded with OPUS. By default, this voice recording will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the the voice message.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type InlineQueryResultVoice struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	VoiceUrl            string                `protobuf:"bytes,3,opt,name=voice_url,json=voiceUrl,proto3" json:"voice_url,omitempty"`
	Title               string                `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	Caption             string                `protobuf:"bytes,5,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,6,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	VoiceDuration       int32                 `protobuf:"varint,7,opt,name=voice_duration,json=voiceDuration,proto3" json:"voice_duration,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,8,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,9,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultVoice) Reset()                    { *m = InlineQueryResultVoice{} }
func (m *InlineQueryResultVoice) String() string            { return proto.CompactTextString(m) }
func (*InlineQueryResultVoice) ProtoMessage()               {}
func (*InlineQueryResultVoice) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{52} }

func (m *InlineQueryResultVoice) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultVoice) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultVoice) GetVoiceUrl() string {
	if m != nil {
		return m.VoiceUrl
	}
	return ""
}

func (m *InlineQueryResultVoice) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultVoice) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultVoice) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultVoice) GetVoiceDuration() int32 {
	if m != nil {
		return m.VoiceDuration
	}
	return 0
}

func (m *InlineQueryResultVoice) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultVoice) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to a file. By default, this file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the file. Currently, only .PDF and .ZIP files can be sent using this method.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type InlineQueryResultDocument struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Title               string                `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Caption             string                `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	DocumentUrl         string                `protobuf:"bytes,6,opt,name=document_url,json=documentUrl,proto3" json:"document_url,omitempty"`
	MimeType            string                `protobuf:"bytes,7,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	Description         string                `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,9,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,10,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
	ThumbUrl            string                `protobuf:"bytes,11,opt,name=thumb_url,json=thumbUrl,proto3" json:"thumb_url,omitempty"`
	ThumbWidth          int32                 `protobuf:"varint,12,opt,name=thumb_width,json=thumbWidth,proto3" json:"thumb_width,omitempty"`
	ThumbHeight         int32                 `protobuf:"varint,13,opt,name=thumb_height,json=thumbHeight,proto3" json:"thumb_height,omitempty"`
}

func (m *InlineQueryResultDocument) Reset()         { *m = InlineQueryResultDocument{} }
func (m *InlineQueryResultDocument) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultDocument) ProtoMessage()    {}
func (*InlineQueryResultDocument) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{53}
}

func (m *InlineQueryResultDocument) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultDocument) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultDocument) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultDocument) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultDocument) GetDocumentUrl() string {
	if m != nil {
		return m.DocumentUrl
	}
	return ""
}

func (m *InlineQueryResultDocument) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *InlineQueryResultDocument) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *InlineQueryResultDocument) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultDocument) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

func (m *InlineQueryResultDocument) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *InlineQueryResultDocument) GetThumbWidth() int32 {
	if m != nil {
		return m.ThumbWidth
	}
	return 0
}

func (m *InlineQueryResultDocument) GetThumbHeight() int32 {
	if m != nil {
		return m.ThumbHeight
	}
	return 0
}

// Represents a location on a map. By default, the location will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the location.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type InlineQueryResultLocation struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Latitude            int64                 `protobuf:"varint,3,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude           int64                 `protobuf:"varint,4,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Title               string                `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	LivePeriod          int32                 `protobuf:"varint,6,opt,name=live_period,json=livePeriod,proto3" json:"live_period,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,7,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,8,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
	ThumbUrl            string                `protobuf:"bytes,9,opt,name=thumb_url,json=thumbUrl,proto3" json:"thumb_url,omitempty"`
	ThumbWidth          int32                 `protobuf:"varint,10,opt,name=thumb_width,json=thumbWidth,proto3" json:"thumb_width,omitempty"`
	ThumbHeight         int32                 `protobuf:"varint,11,opt,name=thumb_height,json=thumbHeight,proto3" json:"thumb_height,omitempty"`
}

func (m *InlineQueryResultLocation) Reset()         { *m = InlineQueryResultLocation{} }
func (m *InlineQueryResultLocation) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultLocation) ProtoMessage()    {}
func (*InlineQueryResultLocation) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{54}
}

func (m *InlineQueryResultLocation) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultLocation) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultLocation) GetLatitude() int64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *InlineQueryResultLocation) GetLongitude() int64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *InlineQueryResultLocation) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultLocation) GetLivePeriod() int32 {
	if m != nil {
		return m.LivePeriod
	}
	return 0
}

func (m *InlineQueryResultLocation) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultLocation) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

func (m *InlineQueryResultLocation) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *InlineQueryResultLocation) GetThumbWidth() int32 {
	if m != nil {
		return m.ThumbWidth
	}
	return 0
}

func (m *InlineQueryResultLocation) GetThumbHeight() int32 {
	if m != nil {
		return m.ThumbHeight
	}
	return 0
}

// Represents a venue. By default, the venue will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the venue.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type InlineQueryResultVenue struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Latitude            int64                 `protobuf:"varint,3,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude           int64                 `protobuf:"varint,4,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Title               string                `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	Address             string                `protobuf:"bytes,6,opt,name=address,proto3" json:"address,omitempty"`
	FoursquareId        string                `protobuf:"bytes,7,opt,name=foursquare_id,json=foursquareId,proto3" json:"foursquare_id,omitempty"`
	FoursquareType      string                `protobuf:"bytes,8,opt,name=foursquare_type,json=foursquareType,proto3" json:"foursquare_type,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,9,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,10,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
	ThumbUrl            string                `protobuf:"bytes,11,opt,name=thumb_url,json=thumbUrl,proto3" json:"thumb_url,omitempty"`
	ThumbWidth          int32                 `protobuf:"varint,12,opt,name=thumb_width,json=thumbWidth,proto3" json:"thumb_width,omitempty"`
	ThumbHeight         int32                 `protobuf:"varint,13,opt,name=thumb_height,json=thumbHeight,proto3" json:"thumb_height,omitempty"`
}

func (m *InlineQueryResultVenue) Reset()                    { *m = InlineQueryResultVenue{} }
func (m *InlineQueryResultVenue) String() string            { return proto.CompactTextString(m) }
func (*InlineQueryResultVenue) ProtoMessage()               {}
func (*InlineQueryResultVenue) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{55} }

func (m *InlineQueryResultVenue) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultVenue) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultVenue) GetLatitude() int64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *InlineQueryResultVenue) GetLongitude() int64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *InlineQueryResultVenue) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultVenue) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *InlineQueryResultVenue) GetFoursquareId() string {
	if m != nil {
		return m.FoursquareId
	}
	return ""
}

func (m *InlineQueryResultVenue) GetFoursquareType() string {
	if m != nil {
		return m.FoursquareType
	}
	return ""
}

func (m *InlineQueryResultVenue) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultVenue) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

func (m *InlineQueryResultVenue) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *InlineQueryResultVenue) GetThumbWidth() int32 {
	if m != nil {
		return m.ThumbWidth
	}
	return 0
}

func (m *InlineQueryResultVenue) GetThumbHeight() int32 {
	if m != nil {
		return m.ThumbHeight
	}
	return 0
}

// Represents a contact with a phone number. By default, this contact will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the contact.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type InlineQueryResultContact struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	PhoneNumber         string                `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	FirstName           string                `protobuf:"bytes,4,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName            string                `protobuf:"bytes,5,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	Vcard               string                `protobuf:"bytes,6,opt,name=vcard,proto3" json:"vcard,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,7,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,8,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
	ThumbUrl            string                `protobuf:"bytes,9,opt,name=thumb_url,json=thumbUrl,proto3" json:"thumb_url,omitempty"`
	ThumbWidth          int32                 `protobuf:"varint,10,opt,name=thumb_width,json=thumbWidth,proto3" json:"thumb_width,omitempty"`
	ThumbHeight         int32                 `protobuf:"varint,11,opt,name=thumb_height,json=thumbHeight,proto3" json:"thumb_height,omitempty"`
}

func (m *InlineQueryResultContact) Reset()         { *m = InlineQueryResultContact{} }
func (m *InlineQueryResultContact) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultContact) ProtoMessage()    {}
func (*InlineQueryResultContact) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{56}
}

func (m *InlineQueryResultContact) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultContact) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultContact) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *InlineQueryResultContact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *InlineQueryResultContact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *InlineQueryResultContact) GetVcard() string {
	if m != nil {
		return m.Vcard
	}
	return ""
}

func (m *InlineQueryResultContact) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultContact) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

func (m *InlineQueryResultContact) GetThumbUrl() string {
	if m != nil {
		return m.ThumbUrl
	}
	return ""
}

func (m *InlineQueryResultContact) GetThumbWidth() int32 {
	if m != nil {
		return m.ThumbWidth
	}
	return 0
}

func (m *InlineQueryResultContact) GetThumbHeight() int32 {
	if m != nil {
		return m.ThumbHeight
	}
	return 0
}

// Represents a Game.
// Note: This will only work in Telegram versions released after October 1, 2016. Older clients will not display any inline results if a game result is among them.
type InlineQueryResultGame struct {
	Type          string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id            string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	GameShortName string                `protobuf:"bytes,3,opt,name=game_short_name,json=gameShortName,proto3" json:"game_short_name,omitempty"`
	ReplyMarkup   *InlineKeyboardMarkup `protobuf:"bytes,4,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *InlineQueryResultGame) Reset()                    { *m = InlineQueryResultGame{} }
func (m *InlineQueryResultGame) String() string            { return proto.CompactTextString(m) }
func (*InlineQueryResultGame) ProtoMessage()               {}
func (*InlineQueryResultGame) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{57} }

func (m *InlineQueryResultGame) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultGame) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultGame) GetGameShortName() string {
	if m != nil {
		return m.GameShortName
	}
	return ""
}

func (m *InlineQueryResultGame) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// Represents a link to a photo stored on the Telegram servers. By default, this photo will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the photo.
type InlineQueryResultCachedPhoto struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	PhotoFileId         string                `protobuf:"bytes,3,opt,name=photo_file_id,json=photoFileId,proto3" json:"photo_file_id,omitempty"`
	Title               string                `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	Description         string                `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Caption             string                `protobuf:"bytes,6,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,7,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,8,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,9,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultCachedPhoto) Reset()         { *m = InlineQueryResultCachedPhoto{} }
func (m *InlineQueryResultCachedPhoto) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultCachedPhoto) ProtoMessage()    {}
func (*InlineQueryResultCachedPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{58}
}

func (m *InlineQueryResultCachedPhoto) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultCachedPhoto) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultCachedPhoto) GetPhotoFileId() string {
	if m != nil {
		return m.PhotoFileId
	}
	return ""
}

func (m *InlineQueryResultCachedPhoto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultCachedPhoto) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *InlineQueryResultCachedPhoto) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultCachedPhoto) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultCachedPhoto) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultCachedPhoto) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to an animated GIF file stored on the Telegram servers. By default, this animated GIF file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with specified content instead of the animation.
type InlineQueryResultCachedGif struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	GifFileId           string                `protobuf:"bytes,3,opt,name=gif_file_id,json=gifFileId,proto3" json:"gif_file_id,omitempty"`
	Title               string                `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	Caption             string                `protobuf:"bytes,5,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,6,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,7,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,8,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultCachedGif) Reset()         { *m = InlineQueryResultCachedGif{} }
func (m *InlineQueryResultCachedGif) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultCachedGif) ProtoMessage()    {}
func (*InlineQueryResultCachedGif) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{59}
}

func (m *InlineQueryResultCachedGif) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultCachedGif) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultCachedGif) GetGifFileId() string {
	if m != nil {
		return m.GifFileId
	}
	return ""
}

func (m *InlineQueryResultCachedGif) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultCachedGif) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultCachedGif) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultCachedGif) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultCachedGif) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the Telegram servers. By default, this animated MPEG-4 file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation.
type InlineQueryResultCachedMpeg4Gif struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Mpeg4FileId         string                `protobuf:"bytes,3,opt,name=mpeg4_file_id,json=mpeg4FileId,proto3" json:"mpeg4_file_id,omitempty"`
	Title               string                `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	Caption             string                `protobuf:"bytes,5,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,6,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,7,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,8,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultCachedMpeg4Gif) Reset()         { *m = InlineQueryResultCachedMpeg4Gif{} }
func (m *InlineQueryResultCachedMpeg4Gif) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultCachedMpeg4Gif) ProtoMessage()    {}
func (*InlineQueryResultCachedMpeg4Gif) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{60}
}

func (m *InlineQueryResultCachedMpeg4Gif) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultCachedMpeg4Gif) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultCachedMpeg4Gif) GetMpeg4FileId() string {
	if m != nil {
		return m.Mpeg4FileId
	}
	return ""
}

func (m *InlineQueryResultCachedMpeg4Gif) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultCachedMpeg4Gif) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultCachedMpeg4Gif) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultCachedMpeg4Gif) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultCachedMpeg4Gif) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to a sticker stored on the Telegram servers. By default, this sticker will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the sticker.
// Note: This will only work in Telegram versions released after 9 April, 2016 for static stickers and after 06 July, 2019 for animated stickers. Older clients will ignore them.
type InlineQueryResultCachedSticker struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	StickerFileId       string                `protobuf:"bytes,3,opt,name=sticker_file_id,json=stickerFileId,proto3" json:"sticker_file_id,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,4,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,5,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultCachedSticker) Reset()         { *m = InlineQueryResultCachedSticker{} }
func (m *InlineQueryResultCachedSticker) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultCachedSticker) ProtoMessage()    {}
func (*InlineQueryResultCachedSticker) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{61}
}

func (m *InlineQueryResultCachedSticker) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultCachedSticker) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultCachedSticker) GetStickerFileId() string {
	if m != nil {
		return m.StickerFileId
	}
	return ""
}

func (m *InlineQueryResultCachedSticker) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultCachedSticker) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to a file stored on the Telegram servers. By default, this file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the file.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type InlineQueryResultCachedDocument struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Title               string                `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	DocumentFileId      string                `protobuf:"bytes,4,opt,name=document_file_id,json=documentFileId,proto3" json:"document_file_id,omitempty"`
	Description         string                `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Caption             string                `protobuf:"bytes,6,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,7,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,8,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,9,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultCachedDocument) Reset()         { *m = InlineQueryResultCachedDocument{} }
func (m *InlineQueryResultCachedDocument) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultCachedDocument) ProtoMessage()    {}
func (*InlineQueryResultCachedDocument) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{62}
}

func (m *InlineQueryResultCachedDocument) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultCachedDocument) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultCachedDocument) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultCachedDocument) GetDocumentFileId() string {
	if m != nil {
		return m.DocumentFileId
	}
	return ""
}

func (m *InlineQueryResultCachedDocument) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *InlineQueryResultCachedDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultCachedDocument) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultCachedDocument) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultCachedDocument) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to a video file stored on the Telegram servers. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the video.
type InlineQueryResultCachedVideo struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	VideoFileId         string                `protobuf:"bytes,3,opt,name=video_file_id,json=videoFileId,proto3" json:"video_file_id,omitempty"`
	Title               string                `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	Description         string                `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Caption             string                `protobuf:"bytes,6,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,7,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,8,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,9,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultCachedVideo) Reset()         { *m = InlineQueryResultCachedVideo{} }
func (m *InlineQueryResultCachedVideo) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultCachedVideo) ProtoMessage()    {}
func (*InlineQueryResultCachedVideo) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{63}
}

func (m *InlineQueryResultCachedVideo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultCachedVideo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultCachedVideo) GetVideoFileId() string {
	if m != nil {
		return m.VideoFileId
	}
	return ""
}

func (m *InlineQueryResultCachedVideo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultCachedVideo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *InlineQueryResultCachedVideo) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultCachedVideo) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultCachedVideo) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultCachedVideo) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to a voice message stored on the Telegram servers. By default, this voice message will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the voice message.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type InlineQueryResultCachedVoice struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	VoiceFileId         string                `protobuf:"bytes,3,opt,name=voice_file_id,json=voiceFileId,proto3" json:"voice_file_id,omitempty"`
	Title               string                `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	Caption             string                `protobuf:"bytes,5,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,6,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,7,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,8,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultCachedVoice) Reset()         { *m = InlineQueryResultCachedVoice{} }
func (m *InlineQueryResultCachedVoice) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultCachedVoice) ProtoMessage()    {}
func (*InlineQueryResultCachedVoice) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{64}
}

func (m *InlineQueryResultCachedVoice) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultCachedVoice) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultCachedVoice) GetVoiceFileId() string {
	if m != nil {
		return m.VoiceFileId
	}
	return ""
}

func (m *InlineQueryResultCachedVoice) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InlineQueryResultCachedVoice) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultCachedVoice) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultCachedVoice) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultCachedVoice) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// Represents a link to an mp3 audio file stored on the Telegram servers. By default, this audio file will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the audio.
// Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.
type InlineQueryResultCachedAudio struct {
	Type                string                `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id                  string                `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	AudioFileId         string                `protobuf:"bytes,3,opt,name=audio_file_id,json=audioFileId,proto3" json:"audio_file_id,omitempty"`
	Caption             string                `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string                `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	ReplyMarkup         *InlineKeyboardMarkup `protobuf:"bytes,6,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
	InputMessageContent *InputMessageContent  `protobuf:"bytes,7,opt,name=input_message_content,json=inputMessageContent" json:"input_message_content,omitempty"`
}

func (m *InlineQueryResultCachedAudio) Reset()         { *m = InlineQueryResultCachedAudio{} }
func (m *InlineQueryResultCachedAudio) String() string { return proto.CompactTextString(m) }
func (*InlineQueryResultCachedAudio) ProtoMessage()    {}
func (*InlineQueryResultCachedAudio) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{65}
}

func (m *InlineQueryResultCachedAudio) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *InlineQueryResultCachedAudio) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InlineQueryResultCachedAudio) GetAudioFileId() string {
	if m != nil {
		return m.AudioFileId
	}
	return ""
}

func (m *InlineQueryResultCachedAudio) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *InlineQueryResultCachedAudio) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InlineQueryResultCachedAudio) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *InlineQueryResultCachedAudio) GetInputMessageContent() *InputMessageContent {
	if m != nil {
		return m.InputMessageContent
	}
	return nil
}

// This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 4 types:
// InputTextMessageContent
// InputLocationMessageContent
// InputVenueMessageContent
// InputContactMessageContent
type InputMessageContent struct {
}

func (m *InputMessageContent) Reset()                    { *m = InputMessageContent{} }
func (m *InputMessageContent) String() string            { return proto.CompactTextString(m) }
func (*InputMessageContent) ProtoMessage()               {}
func (*InputMessageContent) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{66} }

// Represents the content of a text message to be sent as the result of an inline query.
type InputTextMessageContent struct {
	MessageText           string `protobuf:"bytes,1,opt,name=message_text,json=messageText,proto3" json:"message_text,omitempty"`
	ParseMode             string `protobuf:"bytes,2,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	DisableWebPagePreview bool   `protobuf:"varint,3,opt,name=disable_web_page_preview,json=disableWebPagePreview,proto3" json:"disable_web_page_preview,omitempty"`
}

func (m *InputTextMessageContent) Reset()                    { *m = InputTextMessageContent{} }
func (m *InputTextMessageContent) String() string            { return proto.CompactTextString(m) }
func (*InputTextMessageContent) ProtoMessage()               {}
func (*InputTextMessageContent) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{67} }

func (m *InputTextMessageContent) GetMessageText() string {
	if m != nil {
		return m.MessageText
	}
	return ""
}

func (m *InputTextMessageContent) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *InputTextMessageContent) GetDisableWebPagePreview() bool {
	if m != nil {
		return m.DisableWebPagePreview
	}
	return false
}

// Represents the content of a location message to be sent as the result of an inline query.
type InputLocationMessageContent struct {
	Latitude   int64 `protobuf:"varint,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude  int64 `protobuf:"varint,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
	LivePeriod int32 `protobuf:"varint,3,opt,name=live_period,json=livePeriod,proto3" json:"live_period,omitempty"`
}

func (m *InputLocationMessageContent) Reset()         { *m = InputLocationMessageContent{} }
func (m *InputLocationMessageContent) String() string { return proto.CompactTextString(m) }
func (*InputLocationMessageContent) ProtoMessage()    {}
func (*InputLocationMessageContent) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{68}
}

func (m *InputLocationMessageContent) GetLatitude() int64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *InputLocationMessageContent) GetLongitude() int64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *InputLocationMessageContent) GetLivePeriod() int32 {
	if m != nil {
		return m.LivePeriod
	}
	return 0
}

// Represents the content of a venue message to be sent as the result of an inline query.
type InputVenueMessageContent struct {
	Latitude       int64  `protobuf:"varint,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude      int64  `protobuf:"varint,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Title          string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Address        string `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	FoursquareId   string `protobuf:"bytes,5,opt,name=foursquare_id,json=foursquareId,proto3" json:"foursquare_id,omitempty"`
	FoursquareType string `protobuf:"bytes,6,opt,name=foursquare_type,json=foursquareType,proto3" json:"foursquare_type,omitempty"`
}

func (m *InputVenueMessageContent) Reset()         { *m = InputVenueMessageContent{} }
func (m *InputVenueMessageContent) String() string { return proto.CompactTextString(m) }
func (*InputVenueMessageContent) ProtoMessage()    {}
func (*InputVenueMessageContent) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{69}
}

func (m *InputVenueMessageContent) GetLatitude() int64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *InputVenueMessageContent) GetLongitude() int64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *InputVenueMessageContent) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InputVenueMessageContent) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *InputVenueMessageContent) GetFoursquareId() string {
	if m != nil {
		return m.FoursquareId
	}
	return ""
}

func (m *InputVenueMessageContent) GetFoursquareType() string {
	if m != nil {
		return m.FoursquareType
	}
	return ""
}

// Represents the content of a contact message to be sent as the result of an inline query.
type InputContactMessageContent struct {
	PhoneNumber string `protobuf:"bytes,1,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	FirstName   string `protobuf:"bytes,2,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName    string `protobuf:"bytes,3,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	Vcard       string `protobuf:"bytes,4,opt,name=vcard,proto3" json:"vcard,omitempty"`
}

func (m *InputContactMessageContent) Reset()         { *m = InputContactMessageContent{} }
func (m *InputContactMessageContent) String() string { return proto.CompactTextString(m) }
func (*InputContactMessageContent) ProtoMessage()    {}
func (*InputContactMessageContent) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{70}
}

func (m *InputContactMessageContent) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *InputContactMessageContent) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *InputContactMessageContent) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *InputContactMessageContent) GetVcard() string {
	if m != nil {
		return m.Vcard
	}
	return ""
}

// Represents a result of an inline query that was chosen by the user and sent to their chat partner.
// Note: It is necessary to enable inline feedback via @Botfather in order to receive these objects in updates.
type ChosenInlineResult struct {
	ResultId        string    `protobuf:"bytes,1,opt,name=result_id,json=resultId,proto3" json:"result_id,omitempty"`
	From            *User     `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	Location        *Location `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	InlineMessageId string    `protobuf:"bytes,4,opt,name=inline_message_id,json=inlineMessageId,proto3" json:"inline_message_id,omitempty"`
	Query           string    `protobuf:"bytes,5,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *ChosenInlineResult) Reset()                    { *m = ChosenInlineResult{} }
func (m *ChosenInlineResult) String() string            { return proto.CompactTextString(m) }
func (*ChosenInlineResult) ProtoMessage()               {}
func (*ChosenInlineResult) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{71} }

func (m *ChosenInlineResult) GetResultId() string {
	if m != nil {
		return m.ResultId
	}
	return ""
}

func (m *ChosenInlineResult) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ChosenInlineResult) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *ChosenInlineResult) GetInlineMessageId() string {
	if m != nil {
		return m.InlineMessageId
	}
	return ""
}

func (m *ChosenInlineResult) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

// Your bot can accept payments from Telegram users. Please see the introduction to payments for more details on the process and how to set up payments for your bot. Please note that users will need Telegram v.4.0 or higher to use payments (released on May 18, 2017).
// If you sent an invoice requesting a shipping address and the parameter is_flexible was specified, the Bot API will send an Update with a shipping_query field to the bot. Use this method to reply to shipping queries. On success, True is returned.
type AnswerShippingQuery struct {
	ShippingQueryId string            `protobuf:"bytes,1,opt,name=shipping_query_id,json=shippingQueryId,proto3" json:"shipping_query_id,omitempty"`
	Ok              bool              `protobuf:"varint,2,opt,name=ok,proto3" json:"ok,omitempty"`
	ShippingOptions []*ShippingOption `protobuf:"bytes,3,rep,name=shipping_options,json=shippingOptions" json:"shipping_options,omitempty"`
	ErrorMessage    string            `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *AnswerShippingQuery) Reset()                    { *m = AnswerShippingQuery{} }
func (m *AnswerShippingQuery) String() string            { return proto.CompactTextString(m) }
func (*AnswerShippingQuery) ProtoMessage()               {}
func (*AnswerShippingQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{72} }

func (m *AnswerShippingQuery) GetShippingQueryId() string {
	if m != nil {
		return m.ShippingQueryId
	}
	return ""
}

func (m *AnswerShippingQuery) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *AnswerShippingQuery) GetShippingOptions() []*ShippingOption {
	if m != nil {
		return m.ShippingOptions
	}
	return nil
}

func (m *AnswerShippingQuery) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of an Update with the field pre_checkout_query. Use this method to respond to such pre-checkout queries. On success, True is returned. Note: The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.
type AnswerPreCheckoutQuery struct {
	PreCheckoutQueryId string `protobuf:"bytes,1,opt,name=pre_checkout_query_id,json=preCheckoutQueryId,proto3" json:"pre_checkout_query_id,omitempty"`
	Ok                 bool   `protobuf:"varint,2,opt,name=ok,proto3" json:"ok,omitempty"`
	ErrorMessage       string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *AnswerPreCheckoutQuery) Reset()                    { *m = AnswerPreCheckoutQuery{} }
func (m *AnswerPreCheckoutQuery) String() string            { return proto.CompactTextString(m) }
func (*AnswerPreCheckoutQuery) ProtoMessage()               {}
func (*AnswerPreCheckoutQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{73} }

func (m *AnswerPreCheckoutQuery) GetPreCheckoutQueryId() string {
	if m != nil {
		return m.PreCheckoutQueryId
	}
	return ""
}

func (m *AnswerPreCheckoutQuery) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *AnswerPreCheckoutQuery) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// This object represents a portion of the price for goods or services.
type LabeledPrice struct {
	Label  string `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Amount int32  `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *LabeledPrice) Reset()                    { *m = LabeledPrice{} }
func (m *LabeledPrice) String() string            { return proto.CompactTextString(m) }
func (*LabeledPrice) ProtoMessage()               {}
func (*LabeledPrice) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{74} }

func (m *LabeledPrice) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *LabeledPrice) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// This object contains basic information about an invoice.
type Invoice struct {
	Title          string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description    string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	StartParameter string `protobuf:"bytes,3,opt,name=start_parameter,json=startParameter,proto3" json:"start_parameter,omitempty"`
	Currency       string `protobuf:"bytes,4,opt,name=currency,proto3" json:"currency,omitempty"`
	TotalAmount    int32  `protobuf:"varint,5,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
}

func (m *Invoice) Reset()                    { *m = Invoice{} }
func (m *Invoice) String() string            { return proto.CompactTextString(m) }
func (*Invoice) ProtoMessage()               {}
func (*Invoice) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{75} }

func (m *Invoice) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Invoice) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Invoice) GetStartParameter() string {
	if m != nil {
		return m.StartParameter
	}
	return ""
}

func (m *Invoice) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *Invoice) GetTotalAmount() int32 {
	if m != nil {
		return m.TotalAmount
	}
	return 0
}

// This object represents a shipping address.
type ShippingAddress struct {
	CountryCode string `protobuf:"bytes,1,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty"`
	State       string `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	City        string `protobuf:"bytes,3,opt,name=city,proto3" json:"city,omitempty"`
	StreetLine1 string `protobuf:"bytes,4,opt,name=street_line1,json=streetLine1,proto3" json:"street_line1,omitempty"`
	StreetLine2 string `protobuf:"bytes,5,opt,name=street_line2,json=streetLine2,proto3" json:"street_line2,omitempty"`
	PostCode    string `protobuf:"bytes,6,opt,name=post_code,json=postCode,proto3" json:"post_code,omitempty"`
}

func (m *ShippingAddress) Reset()                    { *m = ShippingAddress{} }
func (m *ShippingAddress) String() string            { return proto.CompactTextString(m) }
func (*ShippingAddress) ProtoMessage()               {}
func (*ShippingAddress) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{76} }

func (m *ShippingAddress) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *ShippingAddress) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *ShippingAddress) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *ShippingAddress) GetStreetLine1() string {
	if m != nil {
		return m.StreetLine1
	}
	return ""
}

func (m *ShippingAddress) GetStreetLine2() string {
	if m != nil {
		return m.StreetLine2
	}
	return ""
}

func (m *ShippingAddress) GetPostCode() string {
	if m != nil {
		return m.PostCode
	}
	return ""
}

// This object represents information about an order.
type OrderInfo struct {
	Name            string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	PhoneNumber     string           `protobuf:"bytes,2,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	Email           string           `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	ShippingAddress *ShippingAddress `protobuf:"bytes,4,opt,name=shipping_address,json=shippingAddress" json:"shipping_address,omitempty"`
}

func (m *OrderInfo) Reset()                    { *m = OrderInfo{} }
func (m *OrderInfo) String() string            { return proto.CompactTextString(m) }
func (*OrderInfo) ProtoMessage()               {}
func (*OrderInfo) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{77} }

func (m *OrderInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OrderInfo) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *OrderInfo) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *OrderInfo) GetShippingAddress() *ShippingAddress {
	if m != nil {
		return m.ShippingAddress
	}
	return nil
}

// This object represents one shipping option.
type ShippingOption struct {
	Id     string          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Title  string          `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Prices []*LabeledPrice `protobuf:"bytes,3,rep,name=prices" json:"prices,omitempty"`
}

func (m *ShippingOption) Reset()                    { *m = ShippingOption{} }
func (m *ShippingOption) String() string            { return proto.CompactTextString(m) }
func (*ShippingOption) ProtoMessage()               {}
func (*ShippingOption) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{78} }

func (m *ShippingOption) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ShippingOption) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ShippingOption) GetPrices() []*LabeledPrice {
	if m != nil {
		return m.Prices
	}
	return nil
}

// This object contains basic information about a successful payment.
type SuccessfulPayment struct {
	Currency                string     `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	TotalAmount             int32      `protobuf:"varint,2,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
	InvoicePayload          string     `protobuf:"bytes,3,opt,name=invoice_payload,json=invoicePayload,proto3" json:"invoice_payload,omitempty"`
	ShippingOptionId        string     `protobuf:"bytes,4,opt,name=shipping_option_id,json=shippingOptionId,proto3" json:"shipping_option_id,omitempty"`
	OrderInfo               *OrderInfo `protobuf:"bytes,5,opt,name=order_info,json=orderInfo" json:"order_info,omitempty"`
	TelegramPaymentChargeId string     `protobuf:"bytes,6,opt,name=telegram_payment_charge_id,json=telegramPaymentChargeId,proto3" json:"telegram_payment_charge_id,omitempty"`
	ProviderPaymentChargeId string     `protobuf:"bytes,7,opt,name=provider_payment_charge_id,json=providerPaymentChargeId,proto3" json:"provider_payment_charge_id,omitempty"`
}

func (m *SuccessfulPayment) Reset()                    { *m = SuccessfulPayment{} }
func (m *SuccessfulPayment) String() string            { return proto.CompactTextString(m) }
func (*SuccessfulPayment) ProtoMessage()               {}
func (*SuccessfulPayment) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{79} }

func (m *SuccessfulPayment) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *SuccessfulPayment) GetTotalAmount() int32 {
	if m != nil {
		return m.TotalAmount
	}
	return 0
}

func (m *SuccessfulPayment) GetInvoicePayload() string {
	if m != nil {
		return m.InvoicePayload
	}
	return ""
}

func (m *SuccessfulPayment) GetShippingOptionId() string {
	if m != nil {
		return m.ShippingOptionId
	}
	return ""
}

func (m *SuccessfulPayment) GetOrderInfo() *OrderInfo {
	if m != nil {
		return m.OrderInfo
	}
	return nil
}

func (m *SuccessfulPayment) GetTelegramPaymentChargeId() string {
	if m != nil {
		return m.TelegramPaymentChargeId
	}
	return ""
}

func (m *SuccessfulPayment) GetProviderPaymentChargeId() string {
	if m != nil {
		return m.ProviderPaymentChargeId
	}
	return ""
}

// This object contains information about an incoming shipping query.
type ShippingQuery struct {
	Id              string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	From            *User            `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	InvoicePayload  string           `protobuf:"bytes,3,opt,name=invoice_payload,json=invoicePayload,proto3" json:"invoice_payload,omitempty"`
	ShippingAddress *ShippingAddress `protobuf:"bytes,4,opt,name=shipping_address,json=shippingAddress" json:"shipping_address,omitempty"`
}

func (m *ShippingQuery) Reset()                    { *m = ShippingQuery{} }
func (m *ShippingQuery) String() string            { return proto.CompactTextString(m) }
func (*ShippingQuery) ProtoMessage()               {}
func (*ShippingQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{80} }

func (m *ShippingQuery) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ShippingQuery) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ShippingQuery) GetInvoicePayload() string {
	if m != nil {
		return m.InvoicePayload
	}
	return ""
}

func (m *ShippingQuery) GetShippingAddress() *ShippingAddress {
	if m != nil {
		return m.ShippingAddress
	}
	return nil
}

// This object contains information about an incoming pre-checkout query.
type PreCheckoutQuery struct {
	Id               string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	From             *User      `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	Currency         string     `protobuf:"bytes,3,opt,name=currency,proto3" json:"currency,omitempty"`
	TotalAmount      int32      `protobuf:"varint,4,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
	InvoicePayload   string     `protobuf:"bytes,5,opt,name=invoice_payload,json=invoicePayload,proto3" json:"invoice_payload,omitempty"`
	ShippingOptionId string     `protobuf:"bytes,6,opt,name=shipping_option_id,json=shippingOptionId,proto3" json:"shipping_option_id,omitempty"`
	OrderInfo        *OrderInfo `protobuf:"bytes,7,opt,name=order_info,json=orderInfo" json:"order_info,omitempty"`
}

func (m *PreCheckoutQuery) Reset()                    { *m = PreCheckoutQuery{} }
func (m *PreCheckoutQuery) String() string            { return proto.CompactTextString(m) }
func (*PreCheckoutQuery) ProtoMessage()               {}
func (*PreCheckoutQuery) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{81} }

func (m *PreCheckoutQuery) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PreCheckoutQuery) GetFrom() *User {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *PreCheckoutQuery) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *PreCheckoutQuery) GetTotalAmount() int32 {
	if m != nil {
		return m.TotalAmount
	}
	return 0
}

func (m *PreCheckoutQuery) GetInvoicePayload() string {
	if m != nil {
		return m.InvoicePayload
	}
	return ""
}

func (m *PreCheckoutQuery) GetShippingOptionId() string {
	if m != nil {
		return m.ShippingOptionId
	}
	return ""
}

func (m *PreCheckoutQuery) GetOrderInfo() *OrderInfo {
	if m != nil {
		return m.OrderInfo
	}
	return nil
}

// Telegram Passport is a unified authorization method for services that require personal identification. Users can upload their documents once, then instantly share their data with services that require real-world ID (finance, ICOs, etc.). Please see the manual for details.
// Contains information about Telegram Passport data shared with the bot by the user.
type PassportData struct {
	Data        []*EncryptedPassportElement `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
	Credentials *EncryptedCredentials       `protobuf:"bytes,2,opt,name=credentials" json:"credentials,omitempty"`
}

func (m *PassportData) Reset()                    { *m = PassportData{} }
func (m *PassportData) String() string            { return proto.CompactTextString(m) }
func (*PassportData) ProtoMessage()               {}
func (*PassportData) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{82} }

func (m *PassportData) GetData() []*EncryptedPassportElement {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *PassportData) GetCredentials() *EncryptedCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

// This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format when decrypted and don't exceed 10MB.
type PassportFile struct {
	FileId   string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	FileSize int32  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	FileDate int32  `protobuf:"varint,3,opt,name=file_date,json=fileDate,proto3" json:"file_date,omitempty"`
}

func (m *PassportFile) Reset()                    { *m = PassportFile{} }
func (m *PassportFile) String() string            { return proto.CompactTextString(m) }
func (*PassportFile) ProtoMessage()               {}
func (*PassportFile) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{83} }

func (m *PassportFile) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *PassportFile) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *PassportFile) GetFileDate() int32 {
	if m != nil {
		return m.FileDate
	}
	return 0
}

// Contains information about documents or other Telegram Passport elements shared with the bot by the user.
type EncryptedPassportElement struct {
	Type        string          `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Data        string          `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	PhoneNumber string          `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	Email       string          `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
	Files       []*PassportFile `protobuf:"bytes,5,rep,name=files" json:"files,omitempty"`
	FrontSide   *PassportFile   `protobuf:"bytes,6,opt,name=front_side,json=frontSide" json:"front_side,omitempty"`
	ReverseSide *PassportFile   `protobuf:"bytes,7,opt,name=reverse_side,json=reverseSide" json:"reverse_side,omitempty"`
	Selfie      *PassportFile   `protobuf:"bytes,8,opt,name=selfie" json:"selfie,omitempty"`
	Translation []*PassportFile `protobuf:"bytes,9,rep,name=translation" json:"translation,omitempty"`
	Hash        string          `protobuf:"bytes,10,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *EncryptedPassportElement) Reset()         { *m = EncryptedPassportElement{} }
func (m *EncryptedPassportElement) String() string { return proto.CompactTextString(m) }
func (*EncryptedPassportElement) ProtoMessage()    {}
func (*EncryptedPassportElement) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{84}
}

func (m *EncryptedPassportElement) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *EncryptedPassportElement) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *EncryptedPassportElement) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *EncryptedPassportElement) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *EncryptedPassportElement) GetFiles() []*PassportFile {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *EncryptedPassportElement) GetFrontSide() *PassportFile {
	if m != nil {
		return m.FrontSide
	}
	return nil
}

func (m *EncryptedPassportElement) GetReverseSide() *PassportFile {
	if m != nil {
		return m.ReverseSide
	}
	return nil
}

func (m *EncryptedPassportElement) GetSelfie() *PassportFile {
	if m != nil {
		return m.Selfie
	}
	return nil
}

func (m *EncryptedPassportElement) GetTranslation() []*PassportFile {
	if m != nil {
		return m.Translation
	}
	return nil
}

func (m *EncryptedPassportElement) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

// Contains data required for decrypting and authenticating EncryptedPassportElement. See the Telegram Passport Documentation for a complete description of the data decryption and authentication processes.
type EncryptedCredentials struct {
	Data   string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Hash   string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Secret string `protobuf:"bytes,3,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (m *EncryptedCredentials) Reset()                    { *m = EncryptedCredentials{} }
func (m *EncryptedCredentials) String() string            { return proto.CompactTextString(m) }
func (*EncryptedCredentials) ProtoMessage()               {}
func (*EncryptedCredentials) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{85} }

func (m *EncryptedCredentials) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *EncryptedCredentials) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *EncryptedCredentials) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

// This object represents an error in the Telegram Passport element which was submitted that should be resolved by the user. It should be one of:
// PassportElementErrorDataField
// PassportElementErrorFrontSide
// PassportElementErrorReverseSide
// PassportElementErrorSelfie
// PassportElementErrorFile
// PassportElementErrorFiles
// PassportElementErrorTranslationFile
// PassportElementErrorTranslationFiles
// PassportElementErrorUnspecified
type PassportElementError struct {
}

func (m *PassportElementError) Reset()                    { *m = PassportElementError{} }
func (m *PassportElementError) String() string            { return proto.CompactTextString(m) }
func (*PassportElementError) ProtoMessage()               {}
func (*PassportElementError) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{86} }

// Represents an issue in one of the data fields that was provided by the user. The error is considered resolved when the field's value changes.
type PassportElementErrorDataField struct {
	Source    string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type      string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FieldName string `protobuf:"bytes,3,opt,name=field_name,json=fieldName,proto3" json:"field_name,omitempty"`
	DataHash  string `protobuf:"bytes,4,opt,name=data_hash,json=dataHash,proto3" json:"data_hash,omitempty"`
	Message   string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorDataField) Reset()         { *m = PassportElementErrorDataField{} }
func (m *PassportElementErrorDataField) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorDataField) ProtoMessage()    {}
func (*PassportElementErrorDataField) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{87}
}

func (m *PassportElementErrorDataField) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorDataField) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorDataField) GetFieldName() string {
	if m != nil {
		return m.FieldName
	}
	return ""
}

func (m *PassportElementErrorDataField) GetDataHash() string {
	if m != nil {
		return m.DataHash
	}
	return ""
}

func (m *PassportElementErrorDataField) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with the front side of a document. The error is considered resolved when the file with the front side of the document changes.
type PassportElementErrorFrontSide struct {
	Source   string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorFrontSide) Reset()         { *m = PassportElementErrorFrontSide{} }
func (m *PassportElementErrorFrontSide) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorFrontSide) ProtoMessage()    {}
func (*PassportElementErrorFrontSide) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{88}
}

func (m *PassportElementErrorFrontSide) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorFrontSide) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorFrontSide) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *PassportElementErrorFrontSide) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with the reverse side of a document. The error is considered resolved when the file with reverse side of the document changes.
type PassportElementErrorReverseSide struct {
	Source   string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorReverseSide) Reset()         { *m = PassportElementErrorReverseSide{} }
func (m *PassportElementErrorReverseSide) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorReverseSide) ProtoMessage()    {}
func (*PassportElementErrorReverseSide) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{89}
}

func (m *PassportElementErrorReverseSide) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorReverseSide) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorReverseSide) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *PassportElementErrorReverseSide) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with the selfie with a document. The error is considered resolved when the file with the selfie changes.
type PassportElementErrorSelfie struct {
	Source   string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorSelfie) Reset()         { *m = PassportElementErrorSelfie{} }
func (m *PassportElementErrorSelfie) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorSelfie) ProtoMessage()    {}
func (*PassportElementErrorSelfie) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{90}
}

func (m *PassportElementErrorSelfie) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorSelfie) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorSelfie) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *PassportElementErrorSelfie) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with a document scan. The error is considered resolved when the file with the document scan changes.
type PassportElementErrorFile struct {
	Source   string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorFile) Reset()         { *m = PassportElementErrorFile{} }
func (m *PassportElementErrorFile) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorFile) ProtoMessage()    {}
func (*PassportElementErrorFile) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{91}
}

func (m *PassportElementErrorFile) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorFile) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorFile) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *PassportElementErrorFile) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with a list of scans. The error is considered resolved when the list of files containing the scans changes.
type PassportElementErrorFiles struct {
	Source     string   `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type       string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHashes []string `protobuf:"bytes,3,rep,name=file_hashes,json=fileHashes" json:"file_hashes,omitempty"`
	Message    string   `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorFiles) Reset()         { *m = PassportElementErrorFiles{} }
func (m *PassportElementErrorFiles) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorFiles) ProtoMessage()    {}
func (*PassportElementErrorFiles) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{92}
}

func (m *PassportElementErrorFiles) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorFiles) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorFiles) GetFileHashes() []string {
	if m != nil {
		return m.FileHashes
	}
	return nil
}

func (m *PassportElementErrorFiles) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with one of the files that constitute the translation of a document. The error is considered resolved when the file changes.
type PassportElementErrorTranslationFile struct {
	Source   string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Message  string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorTranslationFile) Reset()         { *m = PassportElementErrorTranslationFile{} }
func (m *PassportElementErrorTranslationFile) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorTranslationFile) ProtoMessage()    {}
func (*PassportElementErrorTranslationFile) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{93}
}

func (m *PassportElementErrorTranslationFile) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorTranslationFile) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorTranslationFile) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *PassportElementErrorTranslationFile) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue with the translated version of a document. The error is considered resolved when a file with the document translation change.
type PassportElementErrorTranslationFiles struct {
	Source     string   `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type       string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	FileHashes []string `protobuf:"bytes,3,rep,name=file_hashes,json=fileHashes" json:"file_hashes,omitempty"`
	Message    string   `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorTranslationFiles) Reset()         { *m = PassportElementErrorTranslationFiles{} }
func (m *PassportElementErrorTranslationFiles) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorTranslationFiles) ProtoMessage()    {}
func (*PassportElementErrorTranslationFiles) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{94}
}

func (m *PassportElementErrorTranslationFiles) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorTranslationFiles) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorTranslationFiles) GetFileHashes() []string {
	if m != nil {
		return m.FileHashes
	}
	return nil
}

func (m *PassportElementErrorTranslationFiles) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Represents an issue in an unspecified place. The error is considered resolved when new data is added.
type PassportElementErrorUnspecified struct {
	Source      string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type        string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	ElementHash string `protobuf:"bytes,3,opt,name=element_hash,json=elementHash,proto3" json:"element_hash,omitempty"`
	Message     string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PassportElementErrorUnspecified) Reset()         { *m = PassportElementErrorUnspecified{} }
func (m *PassportElementErrorUnspecified) String() string { return proto.CompactTextString(m) }
func (*PassportElementErrorUnspecified) ProtoMessage()    {}
func (*PassportElementErrorUnspecified) Descriptor() ([]byte, []int) {
	return fileDescriptorTgbotapi, []int{95}
}

func (m *PassportElementErrorUnspecified) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *PassportElementErrorUnspecified) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PassportElementErrorUnspecified) GetElementHash() string {
	if m != nil {
		return m.ElementHash
	}
	return ""
}

func (m *PassportElementErrorUnspecified) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Your bot can offer users HTML5 games to play solo or to compete against each other in groups and one-on-one chats. Create games via @BotFather using the /newgame command. Please note that this kind of power requires responsibility: you will need to accept the terms for each game that your bots will be offering.
// This object represents a game. Use BotFather to create and edit games, their short names will act as unique identifiers.
type Game struct {
	Title        string           `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description  string           `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Photo        []*PhotoSize     `protobuf:"bytes,3,rep,name=photo" json:"photo,omitempty"`
	Text         string           `protobuf:"bytes,4,opt,name=text,proto3" json:"text,omitempty"`
	TextEntities []*MessageEntity `protobuf:"bytes,5,rep,name=text_entities,json=textEntities" json:"text_entities,omitempty"`
	Animation    *Animation       `protobuf:"bytes,6,opt,name=animation" json:"animation,omitempty"`
}

func (m *Game) Reset()                    { *m = Game{} }
func (m *Game) String() string            { return proto.CompactTextString(m) }
func (*Game) ProtoMessage()               {}
func (*Game) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{96} }

func (m *Game) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Game) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Game) GetPhoto() []*PhotoSize {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *Game) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Game) GetTextEntities() []*MessageEntity {
	if m != nil {
		return m.TextEntities
	}
	return nil
}

func (m *Game) GetAnimation() *Animation {
	if m != nil {
		return m.Animation
	}
	return nil
}

// A placeholder, currently holds no information. Use BotFather to set up your game.
type CallbackGame struct {
}

func (m *CallbackGame) Reset()                    { *m = CallbackGame{} }
func (m *CallbackGame) String() string            { return proto.CompactTextString(m) }
func (*CallbackGame) ProtoMessage()               {}
func (*CallbackGame) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{97} }

// This object represents one row of the high scores table for a game.
// And thatâ€˜s about all weâ€™ve got for now.If you've got any questions, please check out our Bot FAQ Â»
type GameHighScore struct {
	Position int32 `protobuf:"varint,1,opt,name=position,proto3" json:"position,omitempty"`
	User     *User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Score    int32 `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *GameHighScore) Reset()                    { *m = GameHighScore{} }
func (m *GameHighScore) String() string            { return proto.CompactTextString(m) }
func (*GameHighScore) ProtoMessage()               {}
func (*GameHighScore) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{98} }

func (m *GameHighScore) GetPosition() int32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *GameHighScore) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *GameHighScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

type ReplyMarkup struct {
	// Types that are valid to be assigned to ReplyMarkup:
	//	*ReplyMarkup_InlineKeyboardMarkup
	//	*ReplyMarkup_ReplyKeyboardMarkup
	//	*ReplyMarkup_ReplyKeyboardRemove
	//	*ReplyMarkup_ForceReply
	ReplyMarkup isReplyMarkup_ReplyMarkup `protobuf_oneof:"ReplyMarkup"`
}

func (m *ReplyMarkup) Reset()                    { *m = ReplyMarkup{} }
func (m *ReplyMarkup) String() string            { return proto.CompactTextString(m) }
func (*ReplyMarkup) ProtoMessage()               {}
func (*ReplyMarkup) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{99} }

type isReplyMarkup_ReplyMarkup interface {
	isReplyMarkup_ReplyMarkup()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplyMarkup_InlineKeyboardMarkup struct {
	InlineKeyboardMarkup *InlineKeyboardMarkup `protobuf:"bytes,1,opt,name=InlineKeyboardMarkup,oneof"`
}
type ReplyMarkup_ReplyKeyboardMarkup struct {
	ReplyKeyboardMarkup *ReplyKeyboardMarkup `protobuf:"bytes,2,opt,name=ReplyKeyboardMarkup,oneof"`
}
type ReplyMarkup_ReplyKeyboardRemove struct {
	ReplyKeyboardRemove *ReplyKeyboardRemove `protobuf:"bytes,3,opt,name=ReplyKeyboardRemove,oneof"`
}
type ReplyMarkup_ForceReply struct {
	ForceReply *ForceReply `protobuf:"bytes,4,opt,name=ForceReply,oneof"`
}

func (*ReplyMarkup_InlineKeyboardMarkup) isReplyMarkup_ReplyMarkup() {}
func (*ReplyMarkup_ReplyKeyboardMarkup) isReplyMarkup_ReplyMarkup()  {}
func (*ReplyMarkup_ReplyKeyboardRemove) isReplyMarkup_ReplyMarkup()  {}
func (*ReplyMarkup_ForceReply) isReplyMarkup_ReplyMarkup()           {}

func (m *ReplyMarkup) GetReplyMarkup() isReplyMarkup_ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *ReplyMarkup) GetInlineKeyboardMarkup() *InlineKeyboardMarkup {
	if x, ok := m.GetReplyMarkup().(*ReplyMarkup_InlineKeyboardMarkup); ok {
		return x.InlineKeyboardMarkup
	}
	return nil
}

func (m *ReplyMarkup) GetReplyKeyboardMarkup() *ReplyKeyboardMarkup {
	if x, ok := m.GetReplyMarkup().(*ReplyMarkup_ReplyKeyboardMarkup); ok {
		return x.ReplyKeyboardMarkup
	}
	return nil
}

func (m *ReplyMarkup) GetReplyKeyboardRemove() *ReplyKeyboardRemove {
	if x, ok := m.GetReplyMarkup().(*ReplyMarkup_ReplyKeyboardRemove); ok {
		return x.ReplyKeyboardRemove
	}
	return nil
}

func (m *ReplyMarkup) GetForceReply() *ForceReply {
	if x, ok := m.GetReplyMarkup().(*ReplyMarkup_ForceReply); ok {
		return x.ForceReply
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReplyMarkup) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReplyMarkup_OneofMarshaler, _ReplyMarkup_OneofUnmarshaler, _ReplyMarkup_OneofSizer, []interface{}{
		(*ReplyMarkup_InlineKeyboardMarkup)(nil),
		(*ReplyMarkup_ReplyKeyboardMarkup)(nil),
		(*ReplyMarkup_ReplyKeyboardRemove)(nil),
		(*ReplyMarkup_ForceReply)(nil),
	}
}

func _ReplyMarkup_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReplyMarkup)
	// ReplyMarkup
	switch x := m.ReplyMarkup.(type) {
	case *ReplyMarkup_InlineKeyboardMarkup:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InlineKeyboardMarkup); err != nil {
			return err
		}
	case *ReplyMarkup_ReplyKeyboardMarkup:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReplyKeyboardMarkup); err != nil {
			return err
		}
	case *ReplyMarkup_ReplyKeyboardRemove:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReplyKeyboardRemove); err != nil {
			return err
		}
	case *ReplyMarkup_ForceReply:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ForceReply); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReplyMarkup.ReplyMarkup has unexpected type %T", x)
	}
	return nil
}

func _ReplyMarkup_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReplyMarkup)
	switch tag {
	case 1: // ReplyMarkup.InlineKeyboardMarkup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InlineKeyboardMarkup)
		err := b.DecodeMessage(msg)
		m.ReplyMarkup = &ReplyMarkup_InlineKeyboardMarkup{msg}
		return true, err
	case 2: // ReplyMarkup.ReplyKeyboardMarkup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReplyKeyboardMarkup)
		err := b.DecodeMessage(msg)
		m.ReplyMarkup = &ReplyMarkup_ReplyKeyboardMarkup{msg}
		return true, err
	case 3: // ReplyMarkup.ReplyKeyboardRemove
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReplyKeyboardRemove)
		err := b.DecodeMessage(msg)
		m.ReplyMarkup = &ReplyMarkup_ReplyKeyboardRemove{msg}
		return true, err
	case 4: // ReplyMarkup.ForceReply
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ForceReply)
		err := b.DecodeMessage(msg)
		m.ReplyMarkup = &ReplyMarkup_ForceReply{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReplyMarkup_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReplyMarkup)
	// ReplyMarkup
	switch x := m.ReplyMarkup.(type) {
	case *ReplyMarkup_InlineKeyboardMarkup:
		s := proto.Size(x.InlineKeyboardMarkup)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplyMarkup_ReplyKeyboardMarkup:
		s := proto.Size(x.ReplyKeyboardMarkup)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplyMarkup_ReplyKeyboardRemove:
		s := proto.Size(x.ReplyKeyboardRemove)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReplyMarkup_ForceReply:
		s := proto.Size(x.ForceReply)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// This object represents the content of a media message to be sent. It should be one of
// InputMediaAnimation
// InputMediaDocument
// InputMediaAudio
// InputMediaPhoto
// InputMediaVideo
type InputMedia struct {
	// Types that are valid to be assigned to InputMedia:
	//	*InputMedia_InputMediaAnimation
	//	*InputMedia_InputMediaDocument
	//	*InputMedia_InputMediaAudio
	//	*InputMedia_InputMediaPhoto
	//	*InputMedia_InputMediaVideo
	InputMedia isInputMedia_InputMedia `protobuf_oneof:"InputMedia"`
}

func (m *InputMedia) Reset()                    { *m = InputMedia{} }
func (m *InputMedia) String() string            { return proto.CompactTextString(m) }
func (*InputMedia) ProtoMessage()               {}
func (*InputMedia) Descriptor() ([]byte, []int) { return fileDescriptorTgbotapi, []int{100} }

type isInputMedia_InputMedia interface {
	isInputMedia_InputMedia()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InputMedia_InputMediaAnimation struct {
	InputMediaAnimation *InputMediaAnimation `protobuf:"bytes,1,opt,name=InputMediaAnimation,oneof"`
}
type InputMedia_InputMediaDocument struct {
	InputMediaDocument *InputMediaDocument `protobuf:"bytes,2,opt,name=InputMediaDocument,oneof"`
}
type InputMedia_InputMediaAudio struct {
	InputMediaAudio *InputMediaAudio `protobuf:"bytes,3,opt,name=InputMediaAudio,oneof"`
}
type InputMedia_InputMediaPhoto struct {
	InputMediaPhoto *InputMediaPhoto `protobuf:"bytes,4,opt,name=InputMediaPhoto,oneof"`
}
type InputMedia_InputMediaVideo struct {
	InputMediaVideo *InputMediaVideo `protobuf:"bytes,5,opt,name=InputMediaVideo,oneof"`
}

func (*InputMedia_InputMediaAnimation) isInputMedia_InputMedia() {}
func (*InputMedia_InputMediaDocument) isInputMedia_InputMedia()  {}
func (*InputMedia_InputMediaAudio) isInputMedia_InputMedia()     {}
func (*InputMedia_InputMediaPhoto) isInputMedia_InputMedia()     {}
func (*InputMedia_InputMediaVideo) isInputMedia_InputMedia()     {}

func (m *InputMedia) GetInputMedia() isInputMedia_InputMedia {
	if m != nil {
		return m.InputMedia
	}
	return nil
}

func (m *InputMedia) GetInputMediaAnimation() *InputMediaAnimation {
	if x, ok := m.GetInputMedia().(*InputMedia_InputMediaAnimation); ok {
		return x.InputMediaAnimation
	}
	return nil
}

func (m *InputMedia) GetInputMediaDocument() *InputMediaDocument {
	if x, ok := m.GetInputMedia().(*InputMedia_InputMediaDocument); ok {
		return x.InputMediaDocument
	}
	return nil
}

func (m *InputMedia) GetInputMediaAudio() *InputMediaAudio {
	if x, ok := m.GetInputMedia().(*InputMedia_InputMediaAudio); ok {
		return x.InputMediaAudio
	}
	return nil
}

func (m *InputMedia) GetInputMediaPhoto() *InputMediaPhoto {
	if x, ok := m.GetInputMedia().(*InputMedia_InputMediaPhoto); ok {
		return x.InputMediaPhoto
	}
	return nil
}

func (m *InputMedia) GetInputMediaVideo() *InputMediaVideo {
	if x, ok := m.GetInputMedia().(*InputMedia_InputMediaVideo); ok {
		return x.InputMediaVideo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InputMedia) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InputMedia_OneofMarshaler, _InputMedia_OneofUnmarshaler, _InputMedia_OneofSizer, []interface{}{
		(*InputMedia_InputMediaAnimation)(nil),
		(*InputMedia_InputMediaDocument)(nil),
		(*InputMedia_InputMediaAudio)(nil),
		(*InputMedia_InputMediaPhoto)(nil),
		(*InputMedia_InputMediaVideo)(nil),
	}
}

func _InputMedia_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InputMedia)
	// InputMedia
	switch x := m.InputMedia.(type) {
	case *InputMedia_InputMediaAnimation:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InputMediaAnimation); err != nil {
			return err
		}
	case *InputMedia_InputMediaDocument:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InputMediaDocument); err != nil {
			return err
		}
	case *InputMedia_InputMediaAudio:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InputMediaAudio); err != nil {
			return err
		}
	case *InputMedia_InputMediaPhoto:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InputMediaPhoto); err != nil {
			return err
		}
	case *InputMedia_InputMediaVideo:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InputMediaVideo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InputMedia.InputMedia has unexpected type %T", x)
	}
	return nil
}

func _InputMedia_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InputMedia)
	switch tag {
	case 1: // InputMedia.InputMediaAnimation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InputMediaAnimation)
		err := b.DecodeMessage(msg)
		m.InputMedia = &InputMedia_InputMediaAnimation{msg}
		return true, err
	case 2: // InputMedia.InputMediaDocument
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InputMediaDocument)
		err := b.DecodeMessage(msg)
		m.InputMedia = &InputMedia_InputMediaDocument{msg}
		return true, err
	case 3: // InputMedia.InputMediaAudio
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InputMediaAudio)
		err := b.DecodeMessage(msg)
		m.InputMedia = &InputMedia_InputMediaAudio{msg}
		return true, err
	case 4: // InputMedia.InputMediaPhoto
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InputMediaPhoto)
		err := b.DecodeMessage(msg)
		m.InputMedia = &InputMedia_InputMediaPhoto{msg}
		return true, err
	case 5: // InputMedia.InputMediaVideo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InputMediaVideo)
		err := b.DecodeMessage(msg)
		m.InputMedia = &InputMedia_InputMediaVideo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InputMedia_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InputMedia)
	// InputMedia
	switch x := m.InputMedia.(type) {
	case *InputMedia_InputMediaAnimation:
		s := proto.Size(x.InputMediaAnimation)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InputMedia_InputMediaDocument:
		s := proto.Size(x.InputMediaDocument)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InputMedia_InputMediaAudio:
		s := proto.Size(x.InputMediaAudio)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InputMedia_InputMediaPhoto:
		s := proto.Size(x.InputMediaPhoto)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InputMedia_InputMediaVideo:
		s := proto.Size(x.InputMediaVideo)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Update)(nil), "botproto.Update")
	proto.RegisterType((*WebhookInfo)(nil), "botproto.WebhookInfo")
	proto.RegisterType((*User)(nil), "botproto.User")
	proto.RegisterType((*Chat)(nil), "botproto.Chat")
	proto.RegisterType((*Message)(nil), "botproto.Message")
	proto.RegisterType((*MessageEntity)(nil), "botproto.MessageEntity")
	proto.RegisterType((*PhotoSize)(nil), "botproto.PhotoSize")
	proto.RegisterType((*Audio)(nil), "botproto.Audio")
	proto.RegisterType((*Document)(nil), "botproto.Document")
	proto.RegisterType((*Video)(nil), "botproto.Video")
	proto.RegisterType((*Animation)(nil), "botproto.Animation")
	proto.RegisterType((*Voice)(nil), "botproto.Voice")
	proto.RegisterType((*VideoNote)(nil), "botproto.VideoNote")
	proto.RegisterType((*Contact)(nil), "botproto.Contact")
	proto.RegisterType((*Location)(nil), "botproto.Location")
	proto.RegisterType((*Venue)(nil), "botproto.Venue")
	proto.RegisterType((*PollOption)(nil), "botproto.PollOption")
	proto.RegisterType((*Poll)(nil), "botproto.Poll")
	proto.RegisterType((*UserProfilePhotos)(nil), "botproto.UserProfilePhotos")
	proto.RegisterType((*File)(nil), "botproto.File")
	proto.RegisterType((*ReplyKeyboardMarkup)(nil), "botproto.ReplyKeyboardMarkup")
	proto.RegisterType((*KeyboardButton)(nil), "botproto.KeyboardButton")
	proto.RegisterType((*ReplyKeyboardRemove)(nil), "botproto.ReplyKeyboardRemove")
	proto.RegisterType((*InlineKeyboardMarkup)(nil), "botproto.InlineKeyboardMarkup")
	proto.RegisterType((*InlineKeyboardButton)(nil), "botproto.InlineKeyboardButton")
	proto.RegisterType((*LoginUrl)(nil), "botproto.LoginUrl")
	proto.RegisterType((*CallbackQuery)(nil), "botproto.CallbackQuery")
	proto.RegisterType((*ForceReply)(nil), "botproto.ForceReply")
	proto.RegisterType((*ChatPhoto)(nil), "botproto.ChatPhoto")
	proto.RegisterType((*ChatMember)(nil), "botproto.ChatMember")
	proto.RegisterType((*ChatPermissions)(nil), "botproto.ChatPermissions")
	proto.RegisterType((*ResponseParameters)(nil), "botproto.ResponseParameters")
	proto.RegisterType((*InputMediaPhoto)(nil), "botproto.InputMediaPhoto")
	proto.RegisterType((*InputMediaVideo)(nil), "botproto.InputMediaVideo")
	proto.RegisterType((*InputMediaAnimation)(nil), "botproto.InputMediaAnimation")
	proto.RegisterType((*InputMediaAudio)(nil), "botproto.InputMediaAudio")
	proto.RegisterType((*InputMediaDocument)(nil), "botproto.InputMediaDocument")
	proto.RegisterType((*InputFile)(nil), "botproto.InputFile")
	proto.RegisterType((*AnswerCallbackQuery)(nil), "botproto.answerCallbackQuery")
	proto.RegisterType((*Sticker)(nil), "botproto.Sticker")
	proto.RegisterType((*StickerSet)(nil), "botproto.StickerSet")
	proto.RegisterType((*MaskPosition)(nil), "botproto.MaskPosition")
	proto.RegisterType((*AddStickerToSet)(nil), "botproto.addStickerToSet")
	proto.RegisterType((*InlineQuery)(nil), "botproto.InlineQuery")
	proto.RegisterType((*AnswerInlineQuery)(nil), "botproto.answerInlineQuery")
	proto.RegisterType((*InlineQueryResult)(nil), "botproto.InlineQueryResult")
	proto.RegisterType((*InlineQueryResultArticle)(nil), "botproto.InlineQueryResultArticle")
	proto.RegisterType((*InlineQueryResultPhoto)(nil), "botproto.InlineQueryResultPhoto")
	proto.RegisterType((*InlineQueryResultGif)(nil), "botproto.InlineQueryResultGif")
	proto.RegisterType((*InlineQueryResultMpeg4Gif)(nil), "botproto.InlineQueryResultMpeg4Gif")
	proto.RegisterType((*InlineQueryResultVideo)(nil), "botproto.InlineQueryResultVideo")
	proto.RegisterType((*InlineQueryResultAudio)(nil), "botproto.InlineQueryResultAudio")
	proto.RegisterType((*InlineQueryResultVoice)(nil), "botproto.InlineQueryResultVoice")
	proto.RegisterType((*InlineQueryResultDocument)(nil), "botproto.InlineQueryResultDocument")
	proto.RegisterType((*InlineQueryResultLocation)(nil), "botproto.InlineQueryResultLocation")
	proto.RegisterType((*InlineQueryResultVenue)(nil), "botproto.InlineQueryResultVenue")
	proto.RegisterType((*InlineQueryResultContact)(nil), "botproto.InlineQueryResultContact")
	proto.RegisterType((*InlineQueryResultGame)(nil), "botproto.InlineQueryResultGame")
	proto.RegisterType((*InlineQueryResultCachedPhoto)(nil), "botproto.InlineQueryResultCachedPhoto")
	proto.RegisterType((*InlineQueryResultCachedGif)(nil), "botproto.InlineQueryResultCachedGif")
	proto.RegisterType((*InlineQueryResultCachedMpeg4Gif)(nil), "botproto.InlineQueryResultCachedMpeg4Gif")
	proto.RegisterType((*InlineQueryResultCachedSticker)(nil), "botproto.InlineQueryResultCachedSticker")
	proto.RegisterType((*InlineQueryResultCachedDocument)(nil), "botproto.InlineQueryResultCachedDocument")
	proto.RegisterType((*InlineQueryResultCachedVideo)(nil), "botproto.InlineQueryResultCachedVideo")
	proto.RegisterType((*InlineQueryResultCachedVoice)(nil), "botproto.InlineQueryResultCachedVoice")
	proto.RegisterType((*InlineQueryResultCachedAudio)(nil), "botproto.InlineQueryResultCachedAudio")
	proto.RegisterType((*InputMessageContent)(nil), "botproto.InputMessageContent")
	proto.RegisterType((*InputTextMessageContent)(nil), "botproto.InputTextMessageContent")
	proto.RegisterType((*InputLocationMessageContent)(nil), "botproto.InputLocationMessageContent")
	proto.RegisterType((*InputVenueMessageContent)(nil), "botproto.InputVenueMessageContent")
	proto.RegisterType((*InputContactMessageContent)(nil), "botproto.InputContactMessageContent")
	proto.RegisterType((*ChosenInlineResult)(nil), "botproto.ChosenInlineResult")
	proto.RegisterType((*AnswerShippingQuery)(nil), "botproto.answerShippingQuery")
	proto.RegisterType((*AnswerPreCheckoutQuery)(nil), "botproto.answerPreCheckoutQuery")
	proto.RegisterType((*LabeledPrice)(nil), "botproto.LabeledPrice")
	proto.RegisterType((*Invoice)(nil), "botproto.Invoice")
	proto.RegisterType((*ShippingAddress)(nil), "botproto.ShippingAddress")
	proto.RegisterType((*OrderInfo)(nil), "botproto.OrderInfo")
	proto.RegisterType((*ShippingOption)(nil), "botproto.ShippingOption")
	proto.RegisterType((*SuccessfulPayment)(nil), "botproto.SuccessfulPayment")
	proto.RegisterType((*ShippingQuery)(nil), "botproto.ShippingQuery")
	proto.RegisterType((*PreCheckoutQuery)(nil), "botproto.PreCheckoutQuery")
	proto.RegisterType((*PassportData)(nil), "botproto.PassportData")
	proto.RegisterType((*PassportFile)(nil), "botproto.PassportFile")
	proto.RegisterType((*EncryptedPassportElement)(nil), "botproto.EncryptedPassportElement")
	proto.RegisterType((*EncryptedCredentials)(nil), "botproto.EncryptedCredentials")
	proto.RegisterType((*PassportElementError)(nil), "botproto.PassportElementError")
	proto.RegisterType((*PassportElementErrorDataField)(nil), "botproto.PassportElementErrorDataField")
	proto.RegisterType((*PassportElementErrorFrontSide)(nil), "botproto.PassportElementErrorFrontSide")
	proto.RegisterType((*PassportElementErrorReverseSide)(nil), "botproto.PassportElementErrorReverseSide")
	proto.RegisterType((*PassportElementErrorSelfie)(nil), "botproto.PassportElementErrorSelfie")
	proto.RegisterType((*PassportElementErrorFile)(nil), "botproto.PassportElementErrorFile")
	proto.RegisterType((*PassportElementErrorFiles)(nil), "botproto.PassportElementErrorFiles")
	proto.RegisterType((*PassportElementErrorTranslationFile)(nil), "botproto.PassportElementErrorTranslationFile")
	proto.RegisterType((*PassportElementErrorTranslationFiles)(nil), "botproto.PassportElementErrorTranslationFiles")
	proto.RegisterType((*PassportElementErrorUnspecified)(nil), "botproto.PassportElementErrorUnspecified")
	proto.RegisterType((*Game)(nil), "botproto.Game")
	proto.RegisterType((*CallbackGame)(nil), "botproto.CallbackGame")
	proto.RegisterType((*GameHighScore)(nil), "botproto.GameHighScore")
	proto.RegisterType((*ReplyMarkup)(nil), "botproto.ReplyMarkup")
	proto.RegisterType((*InputMedia)(nil), "botproto.InputMedia")
}
func (m *Update) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Update) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpdateId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.UpdateId))
	}
	if m.Message != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Message.Size()))
		n1, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.EditedMessage != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.EditedMessage.Size()))
		n2, err := m.EditedMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ChannelPost != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ChannelPost.Size()))
		n3, err := m.ChannelPost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.EditedChannelPost != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.EditedChannelPost.Size()))
		n4, err := m.EditedChannelPost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.InlineQuery != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InlineQuery.Size()))
		n5, err := m.InlineQuery.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ChosenInlineResult != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ChosenInlineResult.Size()))
		n6, err := m.ChosenInlineResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.CallbackQuery != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.CallbackQuery.Size()))
		n7, err := m.CallbackQuery.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ShippingQuery != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ShippingQuery.Size()))
		n8, err := m.ShippingQuery.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.PreCheckoutQuery != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.PreCheckoutQuery.Size()))
		n9, err := m.PreCheckoutQuery.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Poll != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Poll.Size()))
		n10, err := m.Poll.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *WebhookInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebhookInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.HasCustomCertificate {
		dAtA[i] = 0x10
		i++
		if m.HasCustomCertificate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PendingUpdateCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.PendingUpdateCount))
	}
	if m.LastErrorDate != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.LastErrorDate))
	}
	if len(m.LastErrorMessage) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LastErrorMessage)))
		i += copy(dAtA[i:], m.LastErrorMessage)
	}
	if m.MaxConnections != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MaxConnections))
	}
	if len(m.AllowedUpdates) > 0 {
		for _, s := range m.AllowedUpdates {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Id))
	}
	if m.IsBot {
		dAtA[i] = 0x10
		i++
		if m.IsBot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.LanguageCode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LanguageCode)))
		i += copy(dAtA[i:], m.LanguageCode)
	}
	return i, nil
}

func (m *Chat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Id))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.Photo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Photo.Size()))
		n11, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.InviteLink) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InviteLink)))
		i += copy(dAtA[i:], m.InviteLink)
	}
	if m.PinnedMessage != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.PinnedMessage.Size()))
		n12, err := m.PinnedMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Permissions != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Permissions.Size()))
		n13, err := m.Permissions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.StickerSetName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.StickerSetName)))
		i += copy(dAtA[i:], m.StickerSetName)
	}
	if m.CanSetStickerSet {
		dAtA[i] = 0x68
		i++
		if m.CanSetStickerSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MessageId))
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.From.Size()))
		n14, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Date != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Date))
	}
	if m.Chat != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Chat.Size()))
		n15, err := m.Chat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.ForwardFrom != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ForwardFrom.Size()))
		n16, err := m.ForwardFrom.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.ForwardFromChat != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ForwardFromChat.Size()))
		n17, err := m.ForwardFromChat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.ForwardFromMessageId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ForwardFromMessageId))
	}
	if len(m.ForwardSignature) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ForwardSignature)))
		i += copy(dAtA[i:], m.ForwardSignature)
	}
	if len(m.ForwardSenderName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ForwardSenderName)))
		i += copy(dAtA[i:], m.ForwardSenderName)
	}
	if m.ForwardDate != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ForwardDate))
	}
	if m.ReplyToMessage != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyToMessage.Size()))
		n18, err := m.ReplyToMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.EditDate != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.EditDate))
	}
	if len(m.MediaGroupId) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MediaGroupId)))
		i += copy(dAtA[i:], m.MediaGroupId)
	}
	if len(m.AuthorSignature) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.AuthorSignature)))
		i += copy(dAtA[i:], m.AuthorSignature)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.Entities) > 0 {
		for _, msg := range m.Entities {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CaptionEntities) > 0 {
		for _, msg := range m.CaptionEntities {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Audio != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Audio.Size()))
		n19, err := m.Audio.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Document != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Document.Size()))
		n20, err := m.Document.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Animation != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Animation.Size()))
		n21, err := m.Animation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Game != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Game.Size()))
		n22, err := m.Game.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Photo) > 0 {
		for _, msg := range m.Photo {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Sticker != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Sticker.Size()))
		n23, err := m.Sticker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Video != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Video.Size()))
		n24, err := m.Video.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Voice != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Voice.Size()))
		n25, err := m.Voice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.VideoNote != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.VideoNote.Size()))
		n26, err := m.VideoNote.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if m.Contact != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Contact.Size()))
		n27, err := m.Contact.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Location != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Location.Size()))
		n28, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Venue != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Venue.Size()))
		n29, err := m.Venue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Poll != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Poll.Size()))
		n30, err := m.Poll.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.NewChatMembers) > 0 {
		for _, msg := range m.NewChatMembers {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LeftChatMember != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.LeftChatMember.Size()))
		n31, err := m.LeftChatMember.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.NewChatTitle) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.NewChatTitle)))
		i += copy(dAtA[i:], m.NewChatTitle)
	}
	if len(m.NewChatPhoto) > 0 {
		for _, msg := range m.NewChatPhoto {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DeleteChatPhoto {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		if m.DeleteChatPhoto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GroupChatCreated {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		if m.GroupChatCreated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SupergroupChatCreated {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if m.SupergroupChatCreated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ChannelChatCreated {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		if m.ChannelChatCreated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MigrateToChatId != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MigrateToChatId))
	}
	if m.MigrateFromChatId != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MigrateFromChatId))
	}
	if m.PinnedMessage != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.PinnedMessage.Size()))
		n32, err := m.PinnedMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Invoice != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Invoice.Size()))
		n33, err := m.Invoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.SuccessfulPayment != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.SuccessfulPayment.Size()))
		n34, err := m.SuccessfulPayment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.ConnectedWebsite) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ConnectedWebsite)))
		i += copy(dAtA[i:], m.ConnectedWebsite)
	}
	if m.PassportData != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.PassportData.Size()))
		n35, err := m.PassportData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n36, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *MessageEntity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageEntity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Offset))
	}
	if m.Length != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Length))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.User != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.User.Size()))
		n37, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *PhotoSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoSize) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *Audio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Audio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if len(m.Performer) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Performer)))
		i += copy(dAtA[i:], m.Performer)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	if m.Thumb != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n38, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Document) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Thumb != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n39, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.FileName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *Video) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Video) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if m.Thumb != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n40, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *Animation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Animation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if m.Thumb != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n41, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.FileName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *Voice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Voice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *VideoNote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoNote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Length))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if m.Thumb != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n42, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *Contact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.UserId))
	}
	if len(m.Vcard) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Vcard)))
		i += copy(dAtA[i:], m.Vcard)
	}
	return i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Longitude != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Longitude))
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Latitude))
	}
	return i, nil
}

func (m *Venue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Venue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Location.Size()))
		n43, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.FoursquareId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FoursquareId)))
		i += copy(dAtA[i:], m.FoursquareId)
	}
	if len(m.FoursquareType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FoursquareType)))
		i += copy(dAtA[i:], m.FoursquareType)
	}
	return i, nil
}

func (m *PollOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PollOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.VoterCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.VoterCount))
	}
	return i, nil
}

func (m *Poll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Poll) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Question) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Question)))
		i += copy(dAtA[i:], m.Question)
	}
	if len(m.Options) > 0 {
		for _, msg := range m.Options {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsClosed {
		dAtA[i] = 0x20
		i++
		if m.IsClosed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UserProfilePhotos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserProfilePhotos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.TotalCount))
	}
	if len(m.Photos) > 0 {
		for _, msg := range m.Photos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	if len(m.FilePath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FilePath)))
		i += copy(dAtA[i:], m.FilePath)
	}
	return i, nil
}

func (m *ReplyKeyboardMarkup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyKeyboardMarkup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyboard) > 0 {
		for _, msg := range m.Keyboard {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ResizeKeyboard {
		dAtA[i] = 0x10
		i++
		if m.ResizeKeyboard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OneTimeKeyboard {
		dAtA[i] = 0x18
		i++
		if m.OneTimeKeyboard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Selective {
		dAtA[i] = 0x20
		i++
		if m.Selective {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *KeyboardButton) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyboardButton) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.RequestContact {
		dAtA[i] = 0x10
		i++
		if m.RequestContact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RequestLocation {
		dAtA[i] = 0x18
		i++
		if m.RequestLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReplyKeyboardRemove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyKeyboardRemove) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RemoveKeyboard {
		dAtA[i] = 0x8
		i++
		if m.RemoveKeyboard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Selective {
		dAtA[i] = 0x10
		i++
		if m.Selective {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InlineKeyboardMarkup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineKeyboardMarkup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InlineKeyboard) > 0 {
		for _, msg := range m.InlineKeyboard {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InlineKeyboardButton) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineKeyboardButton) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.LoginUrl != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.LoginUrl.Size()))
		n44, err := m.LoginUrl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.CallbackData) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.CallbackData)))
		i += copy(dAtA[i:], m.CallbackData)
	}
	if len(m.SwitchInlineQuery) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.SwitchInlineQuery)))
		i += copy(dAtA[i:], m.SwitchInlineQuery)
	}
	if len(m.SwitchInlineQueryCurrentChat) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.SwitchInlineQueryCurrentChat)))
		i += copy(dAtA[i:], m.SwitchInlineQueryCurrentChat)
	}
	if m.CallbackGame != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.CallbackGame.Size()))
		n45, err := m.CallbackGame.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Pay {
		dAtA[i] = 0x40
		i++
		if m.Pay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LoginUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginUrl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.ForwardText) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ForwardText)))
		i += copy(dAtA[i:], m.ForwardText)
	}
	if len(m.BotUsername) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.BotUsername)))
		i += copy(dAtA[i:], m.BotUsername)
	}
	if m.RequestWriteAccess {
		dAtA[i] = 0x20
		i++
		if m.RequestWriteAccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CallbackQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallbackQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.From.Size()))
		n46, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.Message != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Message.Size()))
		n47, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if len(m.InlineMessageId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InlineMessageId)))
		i += copy(dAtA[i:], m.InlineMessageId)
	}
	if len(m.ChatInstance) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ChatInstance)))
		i += copy(dAtA[i:], m.ChatInstance)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.GameShortName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.GameShortName)))
		i += copy(dAtA[i:], m.GameShortName)
	}
	return i, nil
}

func (m *ForceReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForceReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ForceReply {
		dAtA[i] = 0x8
		i++
		if m.ForceReply {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Selective {
		dAtA[i] = 0x10
		i++
		if m.Selective {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChatPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SmallFileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.SmallFileId)))
		i += copy(dAtA[i:], m.SmallFileId)
	}
	if len(m.BigFileId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.BigFileId)))
		i += copy(dAtA[i:], m.BigFileId)
	}
	return i, nil
}

func (m *ChatMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.User.Size()))
		n48, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.UntilDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.UntilDate))
	}
	if m.CanBeEdited {
		dAtA[i] = 0x20
		i++
		if m.CanBeEdited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPostMessages {
		dAtA[i] = 0x28
		i++
		if m.CanPostMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanEditMessages {
		dAtA[i] = 0x30
		i++
		if m.CanEditMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanDeleteMessages {
		dAtA[i] = 0x38
		i++
		if m.CanDeleteMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanRestrictMembers {
		dAtA[i] = 0x40
		i++
		if m.CanRestrictMembers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPromoteMembers {
		dAtA[i] = 0x48
		i++
		if m.CanPromoteMembers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanChangeInfo {
		dAtA[i] = 0x50
		i++
		if m.CanChangeInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanInviteUsers {
		dAtA[i] = 0x58
		i++
		if m.CanInviteUsers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPinMessages {
		dAtA[i] = 0x60
		i++
		if m.CanPinMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsMember {
		dAtA[i] = 0x68
		i++
		if m.IsMember {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendMessages {
		dAtA[i] = 0x70
		i++
		if m.CanSendMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendMediaMessages {
		dAtA[i] = 0x78
		i++
		if m.CanSendMediaMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendPolls {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.CanSendPolls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendOtherMessages {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.CanSendOtherMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanAddWebPagePreviews {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.CanAddWebPagePreviews {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChatPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatPermissions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CanSendMessages {
		dAtA[i] = 0x8
		i++
		if m.CanSendMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendMediaMessages {
		dAtA[i] = 0x10
		i++
		if m.CanSendMediaMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendPolls {
		dAtA[i] = 0x18
		i++
		if m.CanSendPolls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanSendOtherMessages {
		dAtA[i] = 0x20
		i++
		if m.CanSendOtherMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanAddWebPagePreviews {
		dAtA[i] = 0x28
		i++
		if m.CanAddWebPagePreviews {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanChangeInfo {
		dAtA[i] = 0x30
		i++
		if m.CanChangeInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanInviteUsers {
		dAtA[i] = 0x38
		i++
		if m.CanInviteUsers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPinMessages {
		dAtA[i] = 0x40
		i++
		if m.CanPinMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ResponseParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseParameters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MigrateToChatId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MigrateToChatId))
	}
	if m.RetryAfter != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.RetryAfter))
	}
	return i, nil
}

func (m *InputMediaPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	return i, nil
}

func (m *InputMediaVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaVideo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.Width != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if m.SupportsStreaming {
		dAtA[i] = 0x48
		i++
		if m.SupportsStreaming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InputMediaAnimation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaAnimation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.Width != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *InputMediaAudio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaAudio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Duration))
	}
	if len(m.Performer) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Performer)))
		i += copy(dAtA[i:], m.Performer)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	return i, nil
}

func (m *InputMediaDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMediaDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	return i, nil
}

func (m *InputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AnswerCallbackQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnswerCallbackQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallbackQueryId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.CallbackQueryId)))
		i += copy(dAtA[i:], m.CallbackQueryId)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.ShowAlert {
		dAtA[i] = 0x18
		i++
		if m.ShowAlert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.CacheTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.CacheTime))
	}
	return i, nil
}

func (m *Sticker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sticker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Height))
	}
	if m.IsAnimated {
		dAtA[i] = 0x20
		i++
		if m.IsAnimated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Thumb != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Thumb.Size()))
		n49, err := m.Thumb.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if len(m.Emoji) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Emoji)))
		i += copy(dAtA[i:], m.Emoji)
	}
	if len(m.SetName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.SetName)))
		i += copy(dAtA[i:], m.SetName)
	}
	if m.MaskPosition != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MaskPosition.Size()))
		n50, err := m.MaskPosition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *StickerSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickerSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.IsAnimated {
		dAtA[i] = 0x18
		i++
		if m.IsAnimated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ContainsMasks {
		dAtA[i] = 0x20
		i++
		if m.ContainsMasks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Stickers) > 0 {
		for _, msg := range m.Stickers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MaskPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaskPosition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Point) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Point)))
		i += copy(dAtA[i:], m.Point)
	}
	if m.XShift != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.XShift))
	}
	if m.YShift != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.YShift))
	}
	if m.Scale != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Scale))
	}
	return i, nil
}

func (m *AddStickerToSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddStickerToSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.UserId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PngSticker) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PngSticker)))
		i += copy(dAtA[i:], m.PngSticker)
	}
	if len(m.Emojis) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Emojis)))
		i += copy(dAtA[i:], m.Emojis)
	}
	if m.MaskPosition != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.MaskPosition.Size()))
		n51, err := m.MaskPosition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}

func (m *InlineQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.From.Size()))
		n52, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.Location != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Location.Size()))
		n53, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if len(m.Query) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	if len(m.Offset) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Offset)))
		i += copy(dAtA[i:], m.Offset)
	}
	return i, nil
}

func (m *AnswerInlineQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnswerInlineQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InlineQueryId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InlineQueryId)))
		i += copy(dAtA[i:], m.InlineQueryId)
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CacheTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.CacheTime))
	}
	if m.IsPersonal {
		dAtA[i] = 0x20
		i++
		if m.IsPersonal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.NextOffset) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.NextOffset)))
		i += copy(dAtA[i:], m.NextOffset)
	}
	if len(m.SwitchPmText) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.SwitchPmText)))
		i += copy(dAtA[i:], m.SwitchPmText)
	}
	if len(m.SwitchPmParameter) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.SwitchPmParameter)))
		i += copy(dAtA[i:], m.SwitchPmParameter)
	}
	return i, nil
}

func (m *InlineQueryResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *InlineQueryResultArticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultArticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n54, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n55, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.HideUrl {
		dAtA[i] = 0x38
		i++
		if m.HideUrl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.ThumbUrl) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ThumbUrl)))
		i += copy(dAtA[i:], m.ThumbUrl)
	}
	if m.ThumbWidth != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ThumbWidth))
	}
	if m.ThumbHeight != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ThumbHeight))
	}
	return i, nil
}

func (m *InlineQueryResultPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.PhotoUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PhotoUrl)))
		i += copy(dAtA[i:], m.PhotoUrl)
	}
	if len(m.ThumbUrl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ThumbUrl)))
		i += copy(dAtA[i:], m.ThumbUrl)
	}
	if m.PhotoWidth != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.PhotoWidth))
	}
	if m.PhotoHeight != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.PhotoHeight))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n56, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n57, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}

func (m *InlineQueryResultGif) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultGif) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.GifUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.GifUrl)))
		i += copy(dAtA[i:], m.GifUrl)
	}
	if m.GifWidth != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.GifWidth))
	}
	if m.GifHeight != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.GifHeight))
	}
	if m.GifDuration != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.GifDuration))
	}
	if len(m.ThumbUrl) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ThumbUrl)))
		i += copy(dAtA[i:], m.ThumbUrl)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n58, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n59, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}

func (m *InlineQueryResultMpeg4Gif) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultMpeg4Gif) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Mpeg4Url) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Mpeg4Url)))
		i += copy(dAtA[i:], m.Mpeg4Url)
	}
	if m.Mpeg4Width != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Mpeg4Width))
	}
	if m.Mpeg4Height != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Mpeg4Height))
	}
	if m.Mpeg4Duration != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Mpeg4Duration))
	}
	if len(m.ThumbUrl) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ThumbUrl)))
		i += copy(dAtA[i:], m.ThumbUrl)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n60, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n61, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}

func (m *InlineQueryResultVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultVideo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.VideoUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.VideoUrl)))
		i += copy(dAtA[i:], m.VideoUrl)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if len(m.ThumbUrl) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ThumbUrl)))
		i += copy(dAtA[i:], m.ThumbUrl)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.VideoWidth != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.VideoWidth))
	}
	if m.VideoHeight != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.VideoHeight))
	}
	if m.VideoDuration != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.VideoDuration))
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n62, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n63, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}

func (m *InlineQueryResultAudio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultAudio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.AudioUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.AudioUrl)))
		i += copy(dAtA[i:], m.AudioUrl)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if len(m.Performer) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Performer)))
		i += copy(dAtA[i:], m.Performer)
	}
	if m.AudioDuration != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.AudioDuration))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n64, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n65, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}

func (m *InlineQueryResultVoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultVoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.VoiceUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.VoiceUrl)))
		i += copy(dAtA[i:], m.VoiceUrl)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.VoiceDuration != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.VoiceDuration))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n66, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n67, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}

func (m *InlineQueryResultDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if len(m.DocumentUrl) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.DocumentUrl)))
		i += copy(dAtA[i:], m.DocumentUrl)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n68, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n69, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if len(m.ThumbUrl) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ThumbUrl)))
		i += copy(dAtA[i:], m.ThumbUrl)
	}
	if m.ThumbWidth != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ThumbWidth))
	}
	if m.ThumbHeight != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ThumbHeight))
	}
	return i, nil
}

func (m *InlineQueryResultLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Longitude))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.LivePeriod != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.LivePeriod))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n70, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n71, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if len(m.ThumbUrl) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ThumbUrl)))
		i += copy(dAtA[i:], m.ThumbUrl)
	}
	if m.ThumbWidth != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ThumbWidth))
	}
	if m.ThumbHeight != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ThumbHeight))
	}
	return i, nil
}

func (m *InlineQueryResultVenue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultVenue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Longitude))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.FoursquareId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FoursquareId)))
		i += copy(dAtA[i:], m.FoursquareId)
	}
	if len(m.FoursquareType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FoursquareType)))
		i += copy(dAtA[i:], m.FoursquareType)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n72, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n73, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if len(m.ThumbUrl) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ThumbUrl)))
		i += copy(dAtA[i:], m.ThumbUrl)
	}
	if m.ThumbWidth != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ThumbWidth))
	}
	if m.ThumbHeight != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ThumbHeight))
	}
	return i, nil
}

func (m *InlineQueryResultContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultContact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if len(m.Vcard) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Vcard)))
		i += copy(dAtA[i:], m.Vcard)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n74, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n75, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if len(m.ThumbUrl) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ThumbUrl)))
		i += copy(dAtA[i:], m.ThumbUrl)
	}
	if m.ThumbWidth != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ThumbWidth))
	}
	if m.ThumbHeight != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ThumbHeight))
	}
	return i, nil
}

func (m *InlineQueryResultGame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultGame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.GameShortName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.GameShortName)))
		i += copy(dAtA[i:], m.GameShortName)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n76, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}

func (m *InlineQueryResultCachedPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultCachedPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.PhotoFileId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PhotoFileId)))
		i += copy(dAtA[i:], m.PhotoFileId)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n77, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n78, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}

func (m *InlineQueryResultCachedGif) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultCachedGif) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.GifFileId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.GifFileId)))
		i += copy(dAtA[i:], m.GifFileId)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n79, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n80, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}

func (m *InlineQueryResultCachedMpeg4Gif) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultCachedMpeg4Gif) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Mpeg4FileId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Mpeg4FileId)))
		i += copy(dAtA[i:], m.Mpeg4FileId)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n81, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n82, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	return i, nil
}

func (m *InlineQueryResultCachedSticker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultCachedSticker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.StickerFileId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.StickerFileId)))
		i += copy(dAtA[i:], m.StickerFileId)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n83, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n84, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	return i, nil
}

func (m *InlineQueryResultCachedDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultCachedDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.DocumentFileId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.DocumentFileId)))
		i += copy(dAtA[i:], m.DocumentFileId)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n85, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n86, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	return i, nil
}

func (m *InlineQueryResultCachedVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultCachedVideo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.VideoFileId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.VideoFileId)))
		i += copy(dAtA[i:], m.VideoFileId)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n87, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n88, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	return i, nil
}

func (m *InlineQueryResultCachedVoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultCachedVoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.VoiceFileId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.VoiceFileId)))
		i += copy(dAtA[i:], m.VoiceFileId)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n89, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n90, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	return i, nil
}

func (m *InlineQueryResultCachedAudio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineQueryResultCachedAudio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.AudioFileId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.AudioFileId)))
		i += copy(dAtA[i:], m.AudioFileId)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n91, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if m.InputMessageContent != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMessageContent.Size()))
		n92, err := m.InputMessageContent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	return i, nil
}

func (m *InputMessageContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMessageContent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *InputTextMessageContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputTextMessageContent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MessageText) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.MessageText)))
		i += copy(dAtA[i:], m.MessageText)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.DisableWebPagePreview {
		dAtA[i] = 0x18
		i++
		if m.DisableWebPagePreview {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InputLocationMessageContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputLocationMessageContent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Latitude != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Longitude))
	}
	if m.LivePeriod != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.LivePeriod))
	}
	return i, nil
}

func (m *InputVenueMessageContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputVenueMessageContent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Latitude != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Longitude))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.FoursquareId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FoursquareId)))
		i += copy(dAtA[i:], m.FoursquareId)
	}
	if len(m.FoursquareType) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FoursquareType)))
		i += copy(dAtA[i:], m.FoursquareType)
	}
	return i, nil
}

func (m *InputContactMessageContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputContactMessageContent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if len(m.Vcard) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Vcard)))
		i += copy(dAtA[i:], m.Vcard)
	}
	return i, nil
}

func (m *ChosenInlineResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChosenInlineResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResultId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ResultId)))
		i += copy(dAtA[i:], m.ResultId)
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.From.Size()))
		n93, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	if m.Location != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Location.Size()))
		n94, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	if len(m.InlineMessageId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InlineMessageId)))
		i += copy(dAtA[i:], m.InlineMessageId)
	}
	if len(m.Query) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	return i, nil
}

func (m *AnswerShippingQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnswerShippingQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ShippingQueryId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ShippingQueryId)))
		i += copy(dAtA[i:], m.ShippingQueryId)
	}
	if m.Ok {
		dAtA[i] = 0x10
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ShippingOptions) > 0 {
		for _, msg := range m.ShippingOptions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	return i, nil
}

func (m *AnswerPreCheckoutQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnswerPreCheckoutQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PreCheckoutQueryId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PreCheckoutQueryId)))
		i += copy(dAtA[i:], m.PreCheckoutQueryId)
	}
	if m.Ok {
		dAtA[i] = 0x10
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	return i, nil
}

func (m *LabeledPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabeledPrice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Amount))
	}
	return i, nil
}

func (m *Invoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Invoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.StartParameter) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.StartParameter)))
		i += copy(dAtA[i:], m.StartParameter)
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if m.TotalAmount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.TotalAmount))
	}
	return i, nil
}

func (m *ShippingAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShippingAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CountryCode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.CountryCode)))
		i += copy(dAtA[i:], m.CountryCode)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.StreetLine1) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.StreetLine1)))
		i += copy(dAtA[i:], m.StreetLine1)
	}
	if len(m.StreetLine2) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.StreetLine2)))
		i += copy(dAtA[i:], m.StreetLine2)
	}
	if len(m.PostCode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PostCode)))
		i += copy(dAtA[i:], m.PostCode)
	}
	return i, nil
}

func (m *OrderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.ShippingAddress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ShippingAddress.Size()))
		n95, err := m.ShippingAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	return i, nil
}

func (m *ShippingOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShippingOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Prices) > 0 {
		for _, msg := range m.Prices {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SuccessfulPayment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuccessfulPayment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Currency) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if m.TotalAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.TotalAmount))
	}
	if len(m.InvoicePayload) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InvoicePayload)))
		i += copy(dAtA[i:], m.InvoicePayload)
	}
	if len(m.ShippingOptionId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ShippingOptionId)))
		i += copy(dAtA[i:], m.ShippingOptionId)
	}
	if m.OrderInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.OrderInfo.Size()))
		n96, err := m.OrderInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	if len(m.TelegramPaymentChargeId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.TelegramPaymentChargeId)))
		i += copy(dAtA[i:], m.TelegramPaymentChargeId)
	}
	if len(m.ProviderPaymentChargeId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ProviderPaymentChargeId)))
		i += copy(dAtA[i:], m.ProviderPaymentChargeId)
	}
	return i, nil
}

func (m *ShippingQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShippingQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.From.Size()))
		n97, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	if len(m.InvoicePayload) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InvoicePayload)))
		i += copy(dAtA[i:], m.InvoicePayload)
	}
	if m.ShippingAddress != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ShippingAddress.Size()))
		n98, err := m.ShippingAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	return i, nil
}

func (m *PreCheckoutQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreCheckoutQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.From.Size()))
		n99, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n99
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if m.TotalAmount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.TotalAmount))
	}
	if len(m.InvoicePayload) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.InvoicePayload)))
		i += copy(dAtA[i:], m.InvoicePayload)
	}
	if len(m.ShippingOptionId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ShippingOptionId)))
		i += copy(dAtA[i:], m.ShippingOptionId)
	}
	if m.OrderInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.OrderInfo.Size()))
		n100, err := m.OrderInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n100
	}
	return i, nil
}

func (m *PassportData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Credentials != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Credentials.Size()))
		n101, err := m.Credentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	return i, nil
}

func (m *PassportFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileSize))
	}
	if m.FileDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FileDate))
	}
	return i, nil
}

func (m *EncryptedPassportElement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedPassportElement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FrontSide != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.FrontSide.Size()))
		n102, err := m.FrontSide.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n102
	}
	if m.ReverseSide != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReverseSide.Size()))
		n103, err := m.ReverseSide.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	if m.Selfie != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Selfie.Size()))
		n104, err := m.Selfie.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n104
	}
	if len(m.Translation) > 0 {
		for _, msg := range m.Translation {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	return i, nil
}

func (m *EncryptedCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedCredentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if len(m.Secret) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	return i, nil
}

func (m *PassportElementError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PassportElementErrorDataField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorDataField) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FieldName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FieldName)))
		i += copy(dAtA[i:], m.FieldName)
	}
	if len(m.DataHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.DataHash)))
		i += copy(dAtA[i:], m.DataHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorFrontSide) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorFrontSide) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorReverseSide) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorReverseSide) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorSelfie) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorSelfie) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorFiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorFiles) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHashes) > 0 {
		for _, s := range m.FileHashes {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorTranslationFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorTranslationFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorTranslationFiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorTranslationFiles) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.FileHashes) > 0 {
		for _, s := range m.FileHashes {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *PassportElementErrorUnspecified) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassportElementErrorUnspecified) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.ElementHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.ElementHash)))
		i += copy(dAtA[i:], m.ElementHash)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *Game) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Game) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Photo) > 0 {
		for _, msg := range m.Photo {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.TextEntities) > 0 {
		for _, msg := range m.TextEntities {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTgbotapi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Animation != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Animation.Size()))
		n105, err := m.Animation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	return i, nil
}

func (m *CallbackGame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallbackGame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GameHighScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameHighScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Position))
	}
	if m.User != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.User.Size()))
		n106, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *ReplyMarkup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyMarkup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyMarkup != nil {
		nn107, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn107
	}
	return i, nil
}

func (m *ReplyMarkup_InlineKeyboardMarkup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InlineKeyboardMarkup != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InlineKeyboardMarkup.Size()))
		n108, err := m.InlineKeyboardMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n108
	}
	return i, nil
}
func (m *ReplyMarkup_ReplyKeyboardMarkup) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ReplyKeyboardMarkup != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyKeyboardMarkup.Size()))
		n109, err := m.ReplyKeyboardMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n109
	}
	return i, nil
}
func (m *ReplyMarkup_ReplyKeyboardRemove) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ReplyKeyboardRemove != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ReplyKeyboardRemove.Size()))
		n110, err := m.ReplyKeyboardRemove.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	return i, nil
}
func (m *ReplyMarkup_ForceReply) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ForceReply != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.ForceReply.Size()))
		n111, err := m.ForceReply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n111
	}
	return i, nil
}
func (m *InputMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputMedia) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InputMedia != nil {
		nn112, err := m.InputMedia.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn112
	}
	return i, nil
}

func (m *InputMedia_InputMediaAnimation) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InputMediaAnimation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMediaAnimation.Size()))
		n113, err := m.InputMediaAnimation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n113
	}
	return i, nil
}
func (m *InputMedia_InputMediaDocument) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InputMediaDocument != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMediaDocument.Size()))
		n114, err := m.InputMediaDocument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n114
	}
	return i, nil
}
func (m *InputMedia_InputMediaAudio) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InputMediaAudio != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMediaAudio.Size()))
		n115, err := m.InputMediaAudio.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	return i, nil
}
func (m *InputMedia_InputMediaPhoto) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InputMediaPhoto != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMediaPhoto.Size()))
		n116, err := m.InputMediaPhoto.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	return i, nil
}
func (m *InputMedia_InputMediaVideo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InputMediaVideo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTgbotapi(dAtA, i, uint64(m.InputMediaVideo.Size()))
		n117, err := m.InputMediaVideo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n117
	}
	return i, nil
}
func encodeFixed64Tgbotapi(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Tgbotapi(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTgbotapi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Update) Size() (n int) {
	var l int
	_ = l
	if m.UpdateId != 0 {
		n += 1 + sovTgbotapi(uint64(m.UpdateId))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.EditedMessage != nil {
		l = m.EditedMessage.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ChannelPost != nil {
		l = m.ChannelPost.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.EditedChannelPost != nil {
		l = m.EditedChannelPost.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InlineQuery != nil {
		l = m.InlineQuery.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ChosenInlineResult != nil {
		l = m.ChosenInlineResult.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.CallbackQuery != nil {
		l = m.CallbackQuery.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ShippingQuery != nil {
		l = m.ShippingQuery.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.PreCheckoutQuery != nil {
		l = m.PreCheckoutQuery.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Poll != nil {
		l = m.Poll.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *WebhookInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.HasCustomCertificate {
		n += 2
	}
	if m.PendingUpdateCount != 0 {
		n += 1 + sovTgbotapi(uint64(m.PendingUpdateCount))
	}
	if m.LastErrorDate != 0 {
		n += 1 + sovTgbotapi(uint64(m.LastErrorDate))
	}
	l = len(m.LastErrorMessage)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.MaxConnections != 0 {
		n += 1 + sovTgbotapi(uint64(m.MaxConnections))
	}
	if len(m.AllowedUpdates) > 0 {
		for _, s := range m.AllowedUpdates {
			l = len(s)
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTgbotapi(uint64(m.Id))
	}
	if m.IsBot {
		n += 2
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.LanguageCode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *Chat) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTgbotapi(uint64(m.Id))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.InviteLink)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.PinnedMessage != nil {
		l = m.PinnedMessage.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.StickerSetName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.CanSetStickerSet {
		n += 2
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.MessageId != 0 {
		n += 1 + sovTgbotapi(uint64(m.MessageId))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Date != 0 {
		n += 1 + sovTgbotapi(uint64(m.Date))
	}
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ForwardFrom != nil {
		l = m.ForwardFrom.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ForwardFromChat != nil {
		l = m.ForwardFromChat.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ForwardFromMessageId != 0 {
		n += 1 + sovTgbotapi(uint64(m.ForwardFromMessageId))
	}
	l = len(m.ForwardSignature)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ForwardSenderName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ForwardDate != 0 {
		n += 1 + sovTgbotapi(uint64(m.ForwardDate))
	}
	if m.ReplyToMessage != nil {
		l = m.ReplyToMessage.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.EditDate != 0 {
		n += 1 + sovTgbotapi(uint64(m.EditDate))
	}
	l = len(m.MediaGroupId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.AuthorSignature)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 2 + l + sovTgbotapi(uint64(l))
		}
	}
	if len(m.CaptionEntities) > 0 {
		for _, e := range m.CaptionEntities {
			l = e.Size()
			n += 2 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.Audio != nil {
		l = m.Audio.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Document != nil {
		l = m.Document.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Animation != nil {
		l = m.Animation.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Game != nil {
		l = m.Game.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Photo) > 0 {
		for _, e := range m.Photo {
			l = e.Size()
			n += 2 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.Sticker != nil {
		l = m.Sticker.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Voice != nil {
		l = m.Voice.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.VideoNote != nil {
		l = m.VideoNote.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Contact != nil {
		l = m.Contact.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Venue != nil {
		l = m.Venue.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Poll != nil {
		l = m.Poll.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if len(m.NewChatMembers) > 0 {
		for _, e := range m.NewChatMembers {
			l = e.Size()
			n += 2 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.LeftChatMember != nil {
		l = m.LeftChatMember.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.NewChatTitle)
	if l > 0 {
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if len(m.NewChatPhoto) > 0 {
		for _, e := range m.NewChatPhoto {
			l = e.Size()
			n += 2 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.DeleteChatPhoto {
		n += 3
	}
	if m.GroupChatCreated {
		n += 3
	}
	if m.SupergroupChatCreated {
		n += 3
	}
	if m.ChannelChatCreated {
		n += 3
	}
	if m.MigrateToChatId != 0 {
		n += 2 + sovTgbotapi(uint64(m.MigrateToChatId))
	}
	if m.MigrateFromChatId != 0 {
		n += 2 + sovTgbotapi(uint64(m.MigrateFromChatId))
	}
	if m.PinnedMessage != nil {
		l = m.PinnedMessage.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.Invoice != nil {
		l = m.Invoice.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.SuccessfulPayment != nil {
		l = m.SuccessfulPayment.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ConnectedWebsite)
	if l > 0 {
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.PassportData != nil {
		l = m.PassportData.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 2 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *MessageEntity) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovTgbotapi(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovTgbotapi(uint64(m.Length))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PhotoSize) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *Audio) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	l = len(m.Performer)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *Document) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *Video) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *Animation) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *Voice) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *VideoNote) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Length != 0 {
		n += 1 + sovTgbotapi(uint64(m.Length))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *Contact) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovTgbotapi(uint64(m.UserId))
	}
	l = len(m.Vcard)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *Location) Size() (n int) {
	var l int
	_ = l
	if m.Longitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Longitude))
	}
	if m.Latitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Latitude))
	}
	return n
}

func (m *Venue) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FoursquareId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FoursquareType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PollOption) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.VoterCount != 0 {
		n += 1 + sovTgbotapi(uint64(m.VoterCount))
	}
	return n
}

func (m *Poll) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Question)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.IsClosed {
		n += 2
	}
	return n
}

func (m *UserProfilePhotos) Size() (n int) {
	var l int
	_ = l
	if m.TotalCount != 0 {
		n += 1 + sovTgbotapi(uint64(m.TotalCount))
	}
	if len(m.Photos) > 0 {
		for _, e := range m.Photos {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	return n
}

func (m *File) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ReplyKeyboardMarkup) Size() (n int) {
	var l int
	_ = l
	if len(m.Keyboard) > 0 {
		for _, e := range m.Keyboard {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.ResizeKeyboard {
		n += 2
	}
	if m.OneTimeKeyboard {
		n += 2
	}
	if m.Selective {
		n += 2
	}
	return n
}

func (m *KeyboardButton) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.RequestContact {
		n += 2
	}
	if m.RequestLocation {
		n += 2
	}
	return n
}

func (m *ReplyKeyboardRemove) Size() (n int) {
	var l int
	_ = l
	if m.RemoveKeyboard {
		n += 2
	}
	if m.Selective {
		n += 2
	}
	return n
}

func (m *InlineKeyboardMarkup) Size() (n int) {
	var l int
	_ = l
	if len(m.InlineKeyboard) > 0 {
		for _, e := range m.InlineKeyboard {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	return n
}

func (m *InlineKeyboardButton) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.LoginUrl != nil {
		l = m.LoginUrl.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.CallbackData)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.SwitchInlineQuery)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.SwitchInlineQueryCurrentChat)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.CallbackGame != nil {
		l = m.CallbackGame.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Pay {
		n += 2
	}
	return n
}

func (m *LoginUrl) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ForwardText)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.BotUsername)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.RequestWriteAccess {
		n += 2
	}
	return n
}

func (m *CallbackQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.InlineMessageId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ChatInstance)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.GameShortName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ForceReply) Size() (n int) {
	var l int
	_ = l
	if m.ForceReply {
		n += 2
	}
	if m.Selective {
		n += 2
	}
	return n
}

func (m *ChatPhoto) Size() (n int) {
	var l int
	_ = l
	l = len(m.SmallFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.BigFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ChatMember) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.UntilDate != 0 {
		n += 1 + sovTgbotapi(uint64(m.UntilDate))
	}
	if m.CanBeEdited {
		n += 2
	}
	if m.CanPostMessages {
		n += 2
	}
	if m.CanEditMessages {
		n += 2
	}
	if m.CanDeleteMessages {
		n += 2
	}
	if m.CanRestrictMembers {
		n += 2
	}
	if m.CanPromoteMembers {
		n += 2
	}
	if m.CanChangeInfo {
		n += 2
	}
	if m.CanInviteUsers {
		n += 2
	}
	if m.CanPinMessages {
		n += 2
	}
	if m.IsMember {
		n += 2
	}
	if m.CanSendMessages {
		n += 2
	}
	if m.CanSendMediaMessages {
		n += 2
	}
	if m.CanSendPolls {
		n += 3
	}
	if m.CanSendOtherMessages {
		n += 3
	}
	if m.CanAddWebPagePreviews {
		n += 3
	}
	return n
}

func (m *ChatPermissions) Size() (n int) {
	var l int
	_ = l
	if m.CanSendMessages {
		n += 2
	}
	if m.CanSendMediaMessages {
		n += 2
	}
	if m.CanSendPolls {
		n += 2
	}
	if m.CanSendOtherMessages {
		n += 2
	}
	if m.CanAddWebPagePreviews {
		n += 2
	}
	if m.CanChangeInfo {
		n += 2
	}
	if m.CanInviteUsers {
		n += 2
	}
	if m.CanPinMessages {
		n += 2
	}
	return n
}

func (m *ResponseParameters) Size() (n int) {
	var l int
	_ = l
	if m.MigrateToChatId != 0 {
		n += 1 + sovTgbotapi(uint64(m.MigrateToChatId))
	}
	if m.RetryAfter != 0 {
		n += 1 + sovTgbotapi(uint64(m.RetryAfter))
	}
	return n
}

func (m *InputMediaPhoto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InputMediaVideo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	if m.SupportsStreaming {
		n += 2
	}
	return n
}

func (m *InputMediaAnimation) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	return n
}

func (m *InputMediaAudio) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Duration))
	}
	l = len(m.Performer)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InputMediaDocument) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InputFile) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AnswerCallbackQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.CallbackQueryId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ShowAlert {
		n += 2
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.CacheTime != 0 {
		n += 1 + sovTgbotapi(uint64(m.CacheTime))
	}
	return n
}

func (m *Sticker) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Height))
	}
	if m.IsAnimated {
		n += 2
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Emoji)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.SetName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.MaskPosition != nil {
		l = m.MaskPosition.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	return n
}

func (m *StickerSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.IsAnimated {
		n += 2
	}
	if m.ContainsMasks {
		n += 2
	}
	if len(m.Stickers) > 0 {
		for _, e := range m.Stickers {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	return n
}

func (m *MaskPosition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Point)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.XShift != 0 {
		n += 1 + sovTgbotapi(uint64(m.XShift))
	}
	if m.YShift != 0 {
		n += 1 + sovTgbotapi(uint64(m.YShift))
	}
	if m.Scale != 0 {
		n += 1 + sovTgbotapi(uint64(m.Scale))
	}
	return n
}

func (m *AddStickerToSet) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovTgbotapi(uint64(m.UserId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PngSticker)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Emojis)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.MaskPosition != nil {
		l = m.MaskPosition.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Offset)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *AnswerInlineQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.InlineQueryId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.CacheTime != 0 {
		n += 1 + sovTgbotapi(uint64(m.CacheTime))
	}
	if m.IsPersonal {
		n += 2
	}
	l = len(m.NextOffset)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.SwitchPmText)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.SwitchPmParameter)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResult) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *InlineQueryResultArticle) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.HideUrl {
		n += 2
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ThumbUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ThumbWidth != 0 {
		n += 1 + sovTgbotapi(uint64(m.ThumbWidth))
	}
	if m.ThumbHeight != 0 {
		n += 1 + sovTgbotapi(uint64(m.ThumbHeight))
	}
	return n
}

func (m *InlineQueryResultPhoto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PhotoUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ThumbUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.PhotoWidth != 0 {
		n += 1 + sovTgbotapi(uint64(m.PhotoWidth))
	}
	if m.PhotoHeight != 0 {
		n += 1 + sovTgbotapi(uint64(m.PhotoHeight))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultGif) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.GifUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.GifWidth != 0 {
		n += 1 + sovTgbotapi(uint64(m.GifWidth))
	}
	if m.GifHeight != 0 {
		n += 1 + sovTgbotapi(uint64(m.GifHeight))
	}
	if m.GifDuration != 0 {
		n += 1 + sovTgbotapi(uint64(m.GifDuration))
	}
	l = len(m.ThumbUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultMpeg4Gif) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Mpeg4Url)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Mpeg4Width != 0 {
		n += 1 + sovTgbotapi(uint64(m.Mpeg4Width))
	}
	if m.Mpeg4Height != 0 {
		n += 1 + sovTgbotapi(uint64(m.Mpeg4Height))
	}
	if m.Mpeg4Duration != 0 {
		n += 1 + sovTgbotapi(uint64(m.Mpeg4Duration))
	}
	l = len(m.ThumbUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultVideo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.VideoUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ThumbUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.VideoWidth != 0 {
		n += 1 + sovTgbotapi(uint64(m.VideoWidth))
	}
	if m.VideoHeight != 0 {
		n += 1 + sovTgbotapi(uint64(m.VideoHeight))
	}
	if m.VideoDuration != 0 {
		n += 1 + sovTgbotapi(uint64(m.VideoDuration))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultAudio) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.AudioUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Performer)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.AudioDuration != 0 {
		n += 1 + sovTgbotapi(uint64(m.AudioDuration))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultVoice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.VoiceUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.VoiceDuration != 0 {
		n += 1 + sovTgbotapi(uint64(m.VoiceDuration))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultDocument) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.DocumentUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ThumbUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ThumbWidth != 0 {
		n += 1 + sovTgbotapi(uint64(m.ThumbWidth))
	}
	if m.ThumbHeight != 0 {
		n += 1 + sovTgbotapi(uint64(m.ThumbHeight))
	}
	return n
}

func (m *InlineQueryResultLocation) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Latitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Longitude))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.LivePeriod != 0 {
		n += 1 + sovTgbotapi(uint64(m.LivePeriod))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ThumbUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ThumbWidth != 0 {
		n += 1 + sovTgbotapi(uint64(m.ThumbWidth))
	}
	if m.ThumbHeight != 0 {
		n += 1 + sovTgbotapi(uint64(m.ThumbHeight))
	}
	return n
}

func (m *InlineQueryResultVenue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Latitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Longitude))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FoursquareId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FoursquareType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ThumbUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ThumbWidth != 0 {
		n += 1 + sovTgbotapi(uint64(m.ThumbWidth))
	}
	if m.ThumbHeight != 0 {
		n += 1 + sovTgbotapi(uint64(m.ThumbHeight))
	}
	return n
}

func (m *InlineQueryResultContact) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Vcard)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ThumbUrl)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ThumbWidth != 0 {
		n += 1 + sovTgbotapi(uint64(m.ThumbWidth))
	}
	if m.ThumbHeight != 0 {
		n += 1 + sovTgbotapi(uint64(m.ThumbHeight))
	}
	return n
}

func (m *InlineQueryResultGame) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.GameShortName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultCachedPhoto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PhotoFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultCachedGif) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.GifFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultCachedMpeg4Gif) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Mpeg4FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultCachedSticker) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.StickerFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultCachedDocument) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.DocumentFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultCachedVideo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.VideoFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultCachedVoice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.VoiceFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InlineQueryResultCachedAudio) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.AudioFileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.InputMessageContent != nil {
		l = m.InputMessageContent.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InputMessageContent) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *InputTextMessageContent) Size() (n int) {
	var l int
	_ = l
	l = len(m.MessageText)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.DisableWebPagePreview {
		n += 2
	}
	return n
}

func (m *InputLocationMessageContent) Size() (n int) {
	var l int
	_ = l
	if m.Latitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Longitude))
	}
	if m.LivePeriod != 0 {
		n += 1 + sovTgbotapi(uint64(m.LivePeriod))
	}
	return n
}

func (m *InputVenueMessageContent) Size() (n int) {
	var l int
	_ = l
	if m.Latitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		n += 1 + sovTgbotapi(uint64(m.Longitude))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FoursquareId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FoursquareType)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *InputContactMessageContent) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Vcard)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ChosenInlineResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResultId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.InlineMessageId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *AnswerShippingQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.ShippingQueryId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Ok {
		n += 2
	}
	if len(m.ShippingOptions) > 0 {
		for _, e := range m.ShippingOptions {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *AnswerPreCheckoutQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.PreCheckoutQueryId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Ok {
		n += 2
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *LabeledPrice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovTgbotapi(uint64(m.Amount))
	}
	return n
}

func (m *Invoice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.StartParameter)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.TotalAmount != 0 {
		n += 1 + sovTgbotapi(uint64(m.TotalAmount))
	}
	return n
}

func (m *ShippingAddress) Size() (n int) {
	var l int
	_ = l
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.StreetLine1)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.StreetLine2)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PostCode)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *OrderInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ShippingAddress != nil {
		l = m.ShippingAddress.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ShippingOption) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Prices) > 0 {
		for _, e := range m.Prices {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	return n
}

func (m *SuccessfulPayment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.TotalAmount != 0 {
		n += 1 + sovTgbotapi(uint64(m.TotalAmount))
	}
	l = len(m.InvoicePayload)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ShippingOptionId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.OrderInfo != nil {
		l = m.OrderInfo.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.TelegramPaymentChargeId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ProviderPaymentChargeId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *ShippingQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.InvoicePayload)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ShippingAddress != nil {
		l = m.ShippingAddress.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PreCheckoutQuery) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.TotalAmount != 0 {
		n += 1 + sovTgbotapi(uint64(m.TotalAmount))
	}
	l = len(m.InvoicePayload)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ShippingOptionId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.OrderInfo != nil {
		l = m.OrderInfo.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportData) Size() (n int) {
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportFile) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileSize))
	}
	if m.FileDate != 0 {
		n += 1 + sovTgbotapi(uint64(m.FileDate))
	}
	return n
}

func (m *EncryptedPassportElement) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.FrontSide != nil {
		l = m.FrontSide.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.ReverseSide != nil {
		l = m.ReverseSide.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Selfie != nil {
		l = m.Selfie.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Translation) > 0 {
		for _, e := range m.Translation {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *EncryptedCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementError) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PassportElementErrorDataField) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FieldName)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.DataHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorFrontSide) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorReverseSide) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorSelfie) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorFile) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorFiles) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.FileHashes) > 0 {
		for _, s := range m.FileHashes {
			l = len(s)
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorTranslationFile) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorTranslationFiles) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.FileHashes) > 0 {
		for _, s := range m.FileHashes {
			l = len(s)
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *PassportElementErrorUnspecified) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.ElementHash)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *Game) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.Photo) > 0 {
		for _, e := range m.Photo {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if len(m.TextEntities) > 0 {
		for _, e := range m.TextEntities {
			l = e.Size()
			n += 1 + l + sovTgbotapi(uint64(l))
		}
	}
	if m.Animation != nil {
		l = m.Animation.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func (m *CallbackGame) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GameHighScore) Size() (n int) {
	var l int
	_ = l
	if m.Position != 0 {
		n += 1 + sovTgbotapi(uint64(m.Position))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovTgbotapi(uint64(m.Score))
	}
	return n
}

func (m *ReplyMarkup) Size() (n int) {
	var l int
	_ = l
	if m.ReplyMarkup != nil {
		n += m.ReplyMarkup.Size()
	}
	return n
}

func (m *ReplyMarkup_InlineKeyboardMarkup) Size() (n int) {
	var l int
	_ = l
	if m.InlineKeyboardMarkup != nil {
		l = m.InlineKeyboardMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *ReplyMarkup_ReplyKeyboardMarkup) Size() (n int) {
	var l int
	_ = l
	if m.ReplyKeyboardMarkup != nil {
		l = m.ReplyKeyboardMarkup.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *ReplyMarkup_ReplyKeyboardRemove) Size() (n int) {
	var l int
	_ = l
	if m.ReplyKeyboardRemove != nil {
		l = m.ReplyKeyboardRemove.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *ReplyMarkup_ForceReply) Size() (n int) {
	var l int
	_ = l
	if m.ForceReply != nil {
		l = m.ForceReply.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *InputMedia) Size() (n int) {
	var l int
	_ = l
	if m.InputMedia != nil {
		n += m.InputMedia.Size()
	}
	return n
}

func (m *InputMedia_InputMediaAnimation) Size() (n int) {
	var l int
	_ = l
	if m.InputMediaAnimation != nil {
		l = m.InputMediaAnimation.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *InputMedia_InputMediaDocument) Size() (n int) {
	var l int
	_ = l
	if m.InputMediaDocument != nil {
		l = m.InputMediaDocument.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *InputMedia_InputMediaAudio) Size() (n int) {
	var l int
	_ = l
	if m.InputMediaAudio != nil {
		l = m.InputMediaAudio.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *InputMedia_InputMediaPhoto) Size() (n int) {
	var l int
	_ = l
	if m.InputMediaPhoto != nil {
		l = m.InputMediaPhoto.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}
func (m *InputMedia_InputMediaVideo) Size() (n int) {
	var l int
	_ = l
	if m.InputMediaVideo != nil {
		l = m.InputMediaVideo.Size()
		n += 1 + l + sovTgbotapi(uint64(l))
	}
	return n
}

func sovTgbotapi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTgbotapi(x uint64) (n int) {
	return sovTgbotapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Update) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateId", wireType)
			}
			m.UpdateId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EditedMessage == nil {
				m.EditedMessage = &Message{}
			}
			if err := m.EditedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelPost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChannelPost == nil {
				m.ChannelPost = &Message{}
			}
			if err := m.ChannelPost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedChannelPost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EditedChannelPost == nil {
				m.EditedChannelPost = &Message{}
			}
			if err := m.EditedChannelPost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InlineQuery == nil {
				m.InlineQuery = &InlineQuery{}
			}
			if err := m.InlineQuery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChosenInlineResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChosenInlineResult == nil {
				m.ChosenInlineResult = &ChosenInlineResult{}
			}
			if err := m.ChosenInlineResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallbackQuery == nil {
				m.CallbackQuery = &CallbackQuery{}
			}
			if err := m.CallbackQuery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShippingQuery == nil {
				m.ShippingQuery = &ShippingQuery{}
			}
			if err := m.ShippingQuery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreCheckoutQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreCheckoutQuery == nil {
				m.PreCheckoutQuery = &PreCheckoutQuery{}
			}
			if err := m.PreCheckoutQuery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Poll == nil {
				m.Poll = &Poll{}
			}
			if err := m.Poll.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebhookInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebhookInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebhookInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasCustomCertificate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasCustomCertificate = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingUpdateCount", wireType)
			}
			m.PendingUpdateCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingUpdateCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorDate", wireType)
			}
			m.LastErrorDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastErrorDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnections", wireType)
			}
			m.MaxConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConnections |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedUpdates", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedUpdates = append(m.AllowedUpdates, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBot = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LanguageCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LanguageCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &ChatPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InviteLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PinnedMessage == nil {
				m.PinnedMessage = &Message{}
			}
			if err := m.PinnedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &ChatPermissions{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerSetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StickerSetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSetStickerSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSetStickerSet = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &User{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &Chat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForwardFrom == nil {
				m.ForwardFrom = &User{}
			}
			if err := m.ForwardFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardFromChat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForwardFromChat == nil {
				m.ForwardFromChat = &Chat{}
			}
			if err := m.ForwardFromChat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardFromMessageId", wireType)
			}
			m.ForwardFromMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardFromMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardSenderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardSenderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardDate", wireType)
			}
			m.ForwardDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwardDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyToMessage == nil {
				m.ReplyToMessage = &Message{}
			}
			if err := m.ReplyToMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDate", wireType)
			}
			m.EditDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaGroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaGroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptionEntities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptionEntities = append(m.CaptionEntities, &MessageEntity{})
			if err := m.CaptionEntities[len(m.CaptionEntities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Audio == nil {
				m.Audio = &Audio{}
			}
			if err := m.Audio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Document == nil {
				m.Document = &Document{}
			}
			if err := m.Document.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Animation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Animation == nil {
				m.Animation = &Animation{}
			}
			if err := m.Animation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Game", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Game == nil {
				m.Game = &Game{}
			}
			if err := m.Game.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = append(m.Photo, &PhotoSize{})
			if err := m.Photo[len(m.Photo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sticker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sticker == nil {
				m.Sticker = &Sticker{}
			}
			if err := m.Sticker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &Video{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Voice == nil {
				m.Voice = &Voice{}
			}
			if err := m.Voice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoNote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VideoNote == nil {
				m.VideoNote = &VideoNote{}
			}
			if err := m.VideoNote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contact == nil {
				m.Contact = &Contact{}
			}
			if err := m.Contact.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Venue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Venue == nil {
				m.Venue = &Venue{}
			}
			if err := m.Venue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Poll == nil {
				m.Poll = &Poll{}
			}
			if err := m.Poll.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewChatMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewChatMembers = append(m.NewChatMembers, &User{})
			if err := m.NewChatMembers[len(m.NewChatMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftChatMember", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftChatMember == nil {
				m.LeftChatMember = &User{}
			}
			if err := m.LeftChatMember.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewChatTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewChatTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewChatPhoto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewChatPhoto = append(m.NewChatPhoto, &PhotoSize{})
			if err := m.NewChatPhoto[len(m.NewChatPhoto)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteChatPhoto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteChatPhoto = bool(v != 0)
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupChatCreated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GroupChatCreated = bool(v != 0)
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupergroupChatCreated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupergroupChatCreated = bool(v != 0)
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelChatCreated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChannelChatCreated = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrateToChatId", wireType)
			}
			m.MigrateToChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrateToChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrateFromChatId", wireType)
			}
			m.MigrateFromChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrateFromChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PinnedMessage == nil {
				m.PinnedMessage = &Message{}
			}
			if err := m.PinnedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invoice == nil {
				m.Invoice = &Invoice{}
			}
			if err := m.Invoice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessfulPayment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuccessfulPayment == nil {
				m.SuccessfulPayment = &SuccessfulPayment{}
			}
			if err := m.SuccessfulPayment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedWebsite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedWebsite = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassportData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PassportData == nil {
				m.PassportData = &PassportData{}
			}
			if err := m.PassportData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageEntity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageEntity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageEntity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhotoSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Audio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Audio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Audio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Performer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Performer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Document) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Video) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Animation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Animation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Animation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Voice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Voice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Voice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoNote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoNote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoNote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vcard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			m.Longitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Venue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Venue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Venue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoursquareId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoursquareId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoursquareType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoursquareType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PollOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PollOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PollOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoterCount", wireType)
			}
			m.VoterCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoterCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Poll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Poll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Poll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Question", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Question = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &PollOption{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClosed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClosed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserProfilePhotos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserProfilePhotos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserProfilePhotos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photos = append(m.Photos, &PhotoSize{})
			if err := m.Photos[len(m.Photos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyKeyboardMarkup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyKeyboardMarkup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyKeyboardMarkup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyboard = append(m.Keyboard, &KeyboardButton{})
			if err := m.Keyboard[len(m.Keyboard)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResizeKeyboard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResizeKeyboard = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimeKeyboard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneTimeKeyboard = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selective", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Selective = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyboardButton) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyboardButton: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyboardButton: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestContact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestContact = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestLocation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyKeyboardRemove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyKeyboardRemove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyKeyboardRemove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveKeyboard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveKeyboard = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selective", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Selective = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineKeyboardMarkup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineKeyboardMarkup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineKeyboardMarkup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineKeyboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineKeyboard = append(m.InlineKeyboard, &InlineKeyboardButton{})
			if err := m.InlineKeyboard[len(m.InlineKeyboard)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineKeyboardButton) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineKeyboardButton: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineKeyboardButton: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoginUrl == nil {
				m.LoginUrl = &LoginUrl{}
			}
			if err := m.LoginUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallbackData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInlineQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchInlineQuery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInlineQueryCurrentChat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchInlineQueryCurrentChat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackGame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallbackGame == nil {
				m.CallbackGame = &CallbackGame{}
			}
			if err := m.CallbackGame.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BotUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestWriteAccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestWriteAccess = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallbackQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallbackQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallbackQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &User{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatInstance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameShortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameShortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForceReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForceReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForceReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceReply", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceReply = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selective", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Selective = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmallFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UntilDate", wireType)
			}
			m.UntilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UntilDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanBeEdited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanBeEdited = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPostMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPostMessages = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanEditMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanEditMessages = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeleteMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanDeleteMessages = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanRestrictMembers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanRestrictMembers = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPromoteMembers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPromoteMembers = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanChangeInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanChangeInfo = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanInviteUsers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanInviteUsers = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPinMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPinMessages = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMember", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMember = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendMessages = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendMediaMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendMediaMessages = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendPolls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendPolls = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendOtherMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendOtherMessages = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAddWebPagePreviews", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanAddWebPagePreviews = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendMessages = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendMediaMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendMediaMessages = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendPolls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendPolls = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanSendOtherMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanSendOtherMessages = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAddWebPagePreviews", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanAddWebPagePreviews = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanChangeInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanChangeInfo = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanInviteUsers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanInviteUsers = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPinMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPinMessages = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigrateToChatId", wireType)
			}
			m.MigrateToChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigrateToChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryAfter", wireType)
			}
			m.RetryAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryAfter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsStreaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsStreaming = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaAnimation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaAnimation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaAnimation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaAudio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaAudio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaAudio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Performer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Performer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMediaDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMediaDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMediaDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnswerCallbackQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: answerCallbackQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: answerCallbackQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackQueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallbackQueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowAlert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowAlert = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTime", wireType)
			}
			m.CacheTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sticker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sticker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sticker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAnimated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAnimated = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &PhotoSize{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emoji", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emoji = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaskPosition == nil {
				m.MaskPosition = &MaskPosition{}
			}
			if err := m.MaskPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StickerSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickerSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickerSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAnimated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAnimated = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsMasks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainsMasks = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stickers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stickers = append(m.Stickers, &Sticker{})
			if err := m.Stickers[len(m.Stickers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaskPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaskPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaskPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Point = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XShift", wireType)
			}
			m.XShift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XShift |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YShift", wireType)
			}
			m.YShift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YShift |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddStickerToSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: addStickerToSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: addStickerToSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PngSticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PngSticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emojis", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emojis = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaskPosition == nil {
				m.MaskPosition = &MaskPosition{}
			}
			if err := m.MaskPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &User{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnswerInlineQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: answerInlineQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: answerInlineQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineQueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineQueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &InlineQueryResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTime", wireType)
			}
			m.CacheTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPersonal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPersonal = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextOffset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextOffset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchPmText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchPmText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchPmParameter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchPmParameter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultArticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultArticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultArticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideUrl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HideUrl = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbWidth", wireType)
			}
			m.ThumbWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbWidth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbHeight", wireType)
			}
			m.ThumbHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbHeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhotoUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoWidth", wireType)
			}
			m.PhotoWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoWidth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoHeight", wireType)
			}
			m.PhotoHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoHeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultGif) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultGif: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultGif: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GifUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GifUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GifWidth", wireType)
			}
			m.GifWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GifWidth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GifHeight", wireType)
			}
			m.GifHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GifHeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GifDuration", wireType)
			}
			m.GifDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GifDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultMpeg4Gif) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultMpeg4Gif: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultMpeg4Gif: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mpeg4Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mpeg4Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mpeg4Width", wireType)
			}
			m.Mpeg4Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mpeg4Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mpeg4Height", wireType)
			}
			m.Mpeg4Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mpeg4Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mpeg4Duration", wireType)
			}
			m.Mpeg4Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mpeg4Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoWidth", wireType)
			}
			m.VideoWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoWidth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoHeight", wireType)
			}
			m.VideoHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoHeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoDuration", wireType)
			}
			m.VideoDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultAudio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultAudio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultAudio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AudioUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Performer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Performer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioDuration", wireType)
			}
			m.AudioDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AudioDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultVoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultVoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultVoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoiceUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceDuration", wireType)
			}
			m.VoiceDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoiceDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbWidth", wireType)
			}
			m.ThumbWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbWidth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbHeight", wireType)
			}
			m.ThumbHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbHeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			m.Longitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivePeriod", wireType)
			}
			m.LivePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LivePeriod |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbWidth", wireType)
			}
			m.ThumbWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbWidth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbHeight", wireType)
			}
			m.ThumbHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbHeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultVenue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultVenue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultVenue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			m.Longitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoursquareId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoursquareId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoursquareType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoursquareType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbWidth", wireType)
			}
			m.ThumbWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbWidth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbHeight", wireType)
			}
			m.ThumbHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbHeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultContact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vcard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbWidth", wireType)
			}
			m.ThumbWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbWidth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbHeight", wireType)
			}
			m.ThumbHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbHeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultGame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultGame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultGame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameShortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameShortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultCachedPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultCachedPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultCachedPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhotoFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultCachedGif) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultCachedGif: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultCachedGif: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GifFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GifFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultCachedMpeg4Gif) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultCachedMpeg4Gif: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultCachedMpeg4Gif: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mpeg4FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mpeg4FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultCachedSticker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultCachedSticker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultCachedSticker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StickerFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultCachedDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultCachedDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultCachedDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultCachedVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultCachedVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultCachedVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultCachedVoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultCachedVoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultCachedVoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoiceFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineQueryResultCachedAudio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineQueryResultCachedAudio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineQueryResultCachedAudio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AudioFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMessageContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMessageContent == nil {
				m.InputMessageContent = &InputMessageContent{}
			}
			if err := m.InputMessageContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMessageContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMessageContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMessageContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputTextMessageContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputTextMessageContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputTextMessageContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableWebPagePreview", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableWebPagePreview = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputLocationMessageContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputLocationMessageContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputLocationMessageContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			m.Longitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivePeriod", wireType)
			}
			m.LivePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LivePeriod |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputVenueMessageContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputVenueMessageContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputVenueMessageContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			m.Longitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoursquareId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoursquareId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoursquareType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoursquareType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputContactMessageContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputContactMessageContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputContactMessageContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vcard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChosenInlineResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChosenInlineResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChosenInlineResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &User{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnswerShippingQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: answerShippingQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: answerShippingQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingQueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingQueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingOptions = append(m.ShippingOptions, &ShippingOption{})
			if err := m.ShippingOptions[len(m.ShippingOptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnswerPreCheckoutQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: answerPreCheckoutQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: answerPreCheckoutQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreCheckoutQueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreCheckoutQueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabeledPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabeledPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabeledPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Invoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Invoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Invoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartParameter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartParameter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			m.TotalAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShippingAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShippingAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShippingAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreetLine1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreetLine1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreetLine2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreetLine2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShippingAddress == nil {
				m.ShippingAddress = &ShippingAddress{}
			}
			if err := m.ShippingAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShippingOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShippingOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShippingOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prices = append(m.Prices, &LabeledPrice{})
			if err := m.Prices[len(m.Prices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuccessfulPayment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuccessfulPayment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuccessfulPayment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			m.TotalAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoicePayload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoicePayload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingOptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingOptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderInfo == nil {
				m.OrderInfo = &OrderInfo{}
			}
			if err := m.OrderInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelegramPaymentChargeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TelegramPaymentChargeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderPaymentChargeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderPaymentChargeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShippingQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShippingQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShippingQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &User{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoicePayload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoicePayload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShippingAddress == nil {
				m.ShippingAddress = &ShippingAddress{}
			}
			if err := m.ShippingAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreCheckoutQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreCheckoutQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreCheckoutQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &User{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			m.TotalAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoicePayload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoicePayload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShippingOptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShippingOptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderInfo == nil {
				m.OrderInfo = &OrderInfo{}
			}
			if err := m.OrderInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &EncryptedPassportElement{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &EncryptedCredentials{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDate", wireType)
			}
			m.FileDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptedPassportElement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedPassportElement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedPassportElement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &PassportFile{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontSide", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FrontSide == nil {
				m.FrontSide = &PassportFile{}
			}
			if err := m.FrontSide.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseSide", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReverseSide == nil {
				m.ReverseSide = &PassportFile{}
			}
			if err := m.ReverseSide.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selfie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selfie == nil {
				m.Selfie = &PassportFile{}
			}
			if err := m.Selfie.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Translation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Translation = append(m.Translation, &PassportFile{})
			if err := m.Translation[len(m.Translation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptedCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorDataField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorDataField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorDataField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorFrontSide) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorFrontSide: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorFrontSide: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorReverseSide) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorReverseSide: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorReverseSide: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorSelfie) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorSelfie: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorSelfie: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorFiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorFiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorFiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHashes = append(m.FileHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorTranslationFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorTranslationFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorTranslationFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorTranslationFiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorTranslationFiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorTranslationFiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHashes = append(m.FileHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassportElementErrorUnspecified) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassportElementErrorUnspecified: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassportElementErrorUnspecified: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElementHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Game) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Game: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Game: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = append(m.Photo, &PhotoSize{})
			if err := m.Photo[len(m.Photo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextEntities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TextEntities = append(m.TextEntities, &MessageEntity{})
			if err := m.TextEntities[len(m.TextEntities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Animation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Animation == nil {
				m.Animation = &Animation{}
			}
			if err := m.Animation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallbackGame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallbackGame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallbackGame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameHighScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameHighScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameHighScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyMarkup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyMarkup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyMarkup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineKeyboardMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InlineKeyboardMarkup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ReplyMarkup = &ReplyMarkup_InlineKeyboardMarkup{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyKeyboardMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplyKeyboardMarkup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ReplyMarkup = &ReplyMarkup_ReplyKeyboardMarkup{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyKeyboardRemove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplyKeyboardRemove{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ReplyMarkup = &ReplyMarkup_ReplyKeyboardRemove{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceReply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ForceReply{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ReplyMarkup = &ReplyMarkup_ForceReply{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMediaAnimation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InputMediaAnimation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InputMedia = &InputMedia_InputMediaAnimation{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMediaDocument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InputMediaDocument{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InputMedia = &InputMedia_InputMediaDocument{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMediaAudio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InputMediaAudio{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InputMedia = &InputMedia_InputMediaAudio{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMediaPhoto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InputMediaPhoto{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InputMedia = &InputMedia_InputMediaPhoto{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMediaVideo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTgbotapi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InputMediaVideo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InputMedia = &InputMedia_InputMediaVideo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTgbotapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTgbotapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTgbotapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTgbotapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTgbotapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTgbotapi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTgbotapi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTgbotapi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTgbotapi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTgbotapi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("tgbotapi.proto", fileDescriptorTgbotapi) }

var fileDescriptorTgbotapi = []byte{
	// 6011 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7c, 0x5d, 0x88, 0x24, 0xc9,
	0x71, 0xf0, 0x55, 0xff, 0x57, 0xf4, 0xcf, 0xcc, 0xd4, 0xce, 0xee, 0xf6, 0xfe, 0xef, 0xd6, 0xfd,
	0xed, 0x69, 0xef, 0x56, 0x77, 0xa7, 0x3b, 0x7d, 0xa7, 0xef, 0x84, 0xf1, 0xec, 0xec, 0xee, 0xed,
	0x58, 0xb7, 0x77, 0x73, 0x35, 0xbb, 0x3a, 0x0c, 0x86, 0xa2, 0xa6, 0x2a, 0xbb, 0xbb, 0xbc, 0xd5,
	0x55, 0xa5, 0xaa, 0xec, 0xdd, 0x1d, 0x81, 0x91, 0x91, 0x6c, 0x2c, 0x1b, 0x04, 0xb6, 0x11, 0x18,
	0xfb, 0xc1, 0x3f, 0x0f, 0xb2, 0x90, 0xc0, 0x18, 0x8c, 0xf4, 0x64, 0x30, 0xe8, 0xc1, 0xd8, 0xc6,
	0x60, 0x0b, 0x83, 0x7f, 0x9f, 0x8c, 0xc0, 0xf8, 0xc1, 0xd8, 0xf8, 0xc9, 0x6f, 0x02, 0x93, 0x91,
	0x99, 0x55, 0x59, 0xd5, 0xd5, 0x3d, 0x3d, 0xe3, 0xbd, 0xd3, 0xd9, 0xa7, 0xa7, 0xee, 0x8c, 0x8c,
	0xcc, 0x8a, 0x8c, 0x88, 0x8c, 0x8c, 0x8c, 0x8c, 0x4c, 0x18, 0xd0, 0xf1, 0x7e, 0x44, 0x9d, 0xd8,
	0xbf, 0x1e, 0x27, 0x11, 0x8d, 0x8c, 0xce, 0x7e, 0x44, 0xf1, 0x9f, 0xf9, 0xc3, 0x06, 0xb4, 0xee,
	0xc7, 0x9e, 0x43, 0x89, 0x71, 0x0e, 0xf4, 0x19, 0xfe, 0xb3, 0x7d, 0x6f, 0xa8, 0x5d, 0xd6, 0xae,
	0x36, 0xad, 0x0e, 0x07, 0xec, 0x78, 0xc6, 0x35, 0x68, 0x4f, 0x49, 0x9a, 0x3a, 0x63, 0x32, 0xac,
	0x5d, 0xd6, 0xae, 0x76, 0x5f, 0xdd, 0xb8, 0x2e, 0xfb, 0xb8, 0x7e, 0x97, 0x57, 0x58, 0x12, 0xc3,
	0x78, 0x03, 0x06, 0xc4, 0xf3, 0x29, 0xf1, 0x6c, 0xd9, 0xa6, 0xbe, 0xa8, 0x4d, 0x9f, 0x23, 0x8a,
	0xa2, 0xf1, 0x1a, 0xf4, 0xdc, 0x89, 0x13, 0x86, 0x24, 0xb0, 0xe3, 0x28, 0xa5, 0xc3, 0xc6, 0xa2,
	0x76, 0x5d, 0x81, 0xb6, 0x1b, 0xa5, 0xd4, 0xd8, 0x82, 0x13, 0xe2, 0x7b, 0x85, 0xc6, 0xcd, 0x45,
	0x8d, 0x37, 0x38, 0xf6, 0xb6, 0xd2, 0xc5, 0x1b, 0xd0, 0xf3, 0xc3, 0xc0, 0x0f, 0x89, 0xfd, 0x85,
	0x19, 0x49, 0x0e, 0x86, 0x2d, 0x6c, 0x7b, 0x32, 0x6f, 0xbb, 0x83, 0xb5, 0xef, 0xb1, 0x4a, 0xab,
	0xeb, 0xe7, 0x05, 0xe3, 0x1d, 0xd8, 0x74, 0x27, 0x51, 0x4a, 0x42, 0x5b, 0x74, 0x90, 0x90, 0x74,
	0x16, 0xd0, 0x61, 0x1b, 0x7b, 0x38, 0x9f, 0xf7, 0xb0, 0x8d, 0x58, 0xbc, 0x1f, 0x0b, 0x71, 0x2c,
	0xc3, 0x9d, 0x83, 0x19, 0x3f, 0x01, 0x03, 0xd7, 0x09, 0x82, 0x7d, 0xc7, 0x7d, 0x20, 0x68, 0xe9,
	0x60, 0x4f, 0xa7, 0x95, 0x9e, 0x44, 0x3d, 0xa7, 0xa6, 0xef, 0xaa, 0x45, 0xd6, 0x3e, 0x9d, 0xf8,
	0x71, 0xec, 0x87, 0x63, 0xd1, 0x5e, 0x2f, 0xb7, 0xdf, 0x13, 0xf5, 0xa2, 0x7d, 0xaa, 0x16, 0x8d,
	0x3b, 0x60, 0xc4, 0x09, 0xb1, 0xdd, 0x09, 0x71, 0x1f, 0x44, 0x33, 0x2a, 0xfa, 0x00, 0xec, 0xe3,
	0x6c, 0xde, 0xc7, 0x6e, 0x42, 0xb6, 0x05, 0x0a, 0xef, 0x66, 0x3d, 0x2e, 0x41, 0x0c, 0x13, 0x1a,
	0x71, 0x14, 0x04, 0xc3, 0x2e, 0xb6, 0x1d, 0x28, 0x6d, 0xa3, 0x20, 0xb0, 0xb0, 0xce, 0xfc, 0xc3,
	0x1a, 0x74, 0xdf, 0x27, 0xfb, 0x93, 0x28, 0x7a, 0xb0, 0x13, 0x8e, 0x22, 0x63, 0x1d, 0xea, 0xb3,
	0x24, 0x40, 0xf5, 0xd3, 0x2d, 0xf6, 0xd7, 0x78, 0x0d, 0x4e, 0x4d, 0x9c, 0xd4, 0x76, 0x67, 0x29,
	0x8d, 0xa6, 0xb6, 0x4b, 0x12, 0xea, 0x8f, 0x7c, 0xd7, 0xa1, 0x5c, 0x11, 0x3b, 0xd6, 0xe6, 0xc4,
	0x49, 0xb7, 0xb1, 0x72, 0x3b, 0xaf, 0x33, 0x5e, 0x86, 0xcd, 0x98, 0x84, 0x1e, 0x63, 0x82, 0x50,
	0x6a, 0x37, 0x9a, 0x85, 0x14, 0x15, 0xb1, 0x69, 0x19, 0xa2, 0x8e, 0x6b, 0xfe, 0x36, 0xab, 0x31,
	0x9e, 0x83, 0xb5, 0xc0, 0x49, 0xa9, 0x4d, 0x92, 0x24, 0x4a, 0x6c, 0x06, 0x47, 0xed, 0x6b, 0x5a,
	0x7d, 0x06, 0xbe, 0xc5, 0xa0, 0x37, 0x59, 0xcf, 0x2f, 0x82, 0xa1, 0xe0, 0x49, 0x05, 0x6f, 0x22,
	0xc1, 0xeb, 0x19, 0xaa, 0x54, 0xe8, 0xe7, 0x61, 0x6d, 0xea, 0x3c, 0xb6, 0xdd, 0x28, 0x0c, 0x89,
	0x4b, 0xfd, 0x28, 0x4c, 0x51, 0xb5, 0x9a, 0xd6, 0x60, 0xea, 0x3c, 0xde, 0xce, 0xa1, 0x0c, 0xd1,
	0x09, 0x82, 0xe8, 0x11, 0xf1, 0x04, 0xc1, 0xe9, 0xb0, 0x7d, 0xb9, 0x7e, 0x55, 0xb7, 0x06, 0x02,
	0xcc, 0x69, 0x4d, 0xcd, 0x6f, 0x6b, 0xd0, 0xb8, 0x9f, 0x92, 0xc4, 0x18, 0x40, 0x2d, 0x9b, 0xa8,
	0x35, 0xdf, 0x33, 0x4e, 0x42, 0xcb, 0x4f, 0xed, 0xfd, 0x88, 0x0a, 0xc6, 0x34, 0xfd, 0xf4, 0x46,
	0x44, 0x8d, 0x0b, 0x00, 0x23, 0x3f, 0x49, 0xa9, 0x1d, 0x3a, 0x53, 0x3e, 0x11, 0x75, 0x4b, 0x47,
	0xc8, 0x3b, 0xce, 0x14, 0x67, 0x3d, 0x0e, 0x07, 0x6b, 0x1b, 0x58, 0xdb, 0x61, 0x00, 0xac, 0x3c,
	0x0b, 0x9d, 0x59, 0x4a, 0x12, 0xac, 0xe3, 0x23, 0xcc, 0xca, 0xc6, 0xd3, 0xd0, 0x0f, 0x9c, 0x70,
	0x3c, 0x73, 0xc6, 0x8c, 0xb7, 0x1e, 0xc1, 0x71, 0xe9, 0x56, 0x4f, 0x02, 0xb7, 0x23, 0x8f, 0x98,
	0x7f, 0x57, 0x87, 0xc6, 0xf6, 0xc4, 0xa1, 0x73, 0xc4, 0x1a, 0xd0, 0xa0, 0x07, 0x31, 0x97, 0xa1,
	0x6e, 0xe1, 0x7f, 0x63, 0x13, 0x9a, 0xd4, 0xa7, 0x81, 0x24, 0x92, 0x17, 0x0a, 0x34, 0x34, 0x4a,
	0x34, 0x14, 0xc7, 0xd6, 0x5c, 0x3a, 0xb6, 0x56, 0x69, 0x6c, 0x2f, 0x40, 0x33, 0x9e, 0x44, 0x34,
	0x12, 0x13, 0xf5, 0x84, 0x3a, 0x51, 0x1d, 0xba, 0xcb, 0xaa, 0x2c, 0x8e, 0x61, 0x5c, 0x86, 0xae,
	0x47, 0x52, 0x37, 0xf1, 0x63, 0x26, 0x2b, 0x9c, 0x8f, 0xba, 0xa5, 0x82, 0x8c, 0x4b, 0xd0, 0xf5,
	0xc3, 0x87, 0x3e, 0x25, 0x76, 0xe0, 0x87, 0x0f, 0x70, 0xc6, 0xe9, 0x16, 0x70, 0xd0, 0xdb, 0x7e,
	0xf8, 0x80, 0x99, 0xc4, 0xd8, 0x0f, 0x43, 0xc5, 0x24, 0xc2, 0x42, 0x93, 0xc8, 0x11, 0xa5, 0x06,
	0xbd, 0x09, 0xdd, 0x98, 0x24, 0x53, 0x3f, 0x4d, 0x51, 0x7b, 0xf8, 0x64, 0x3a, 0x53, 0xa2, 0x36,
	0x47, 0xb0, 0x54, 0x6c, 0xe3, 0x2a, 0xac, 0xa7, 0xd4, 0x77, 0x1f, 0x90, 0xc4, 0x4e, 0x89, 0x60,
	0x44, 0x0f, 0x89, 0x1b, 0x08, 0xf8, 0x1e, 0xe1, 0xec, 0x78, 0x09, 0x4e, 0xb8, 0x4e, 0x88, 0x58,
	0x4a, 0x8b, 0x61, 0x1f, 0x55, 0x69, 0xdd, 0x75, 0xc2, 0x3d, 0x42, 0xf7, 0xb2, 0x26, 0xe6, 0x57,
	0x36, 0xa0, 0x2d, 0x29, 0xbc, 0x00, 0x20, 0x06, 0x95, 0xaf, 0x1c, 0xba, 0x80, 0xec, 0x78, 0xcc,
	0x0c, 0x8c, 0x92, 0x68, 0x2a, 0xd6, 0x0d, 0xc5, 0x0c, 0x30, 0x2d, 0xb6, 0xb0, 0x8e, 0xa9, 0x03,
	0xce, 0x38, 0x3e, 0x3d, 0xf1, 0x3f, 0x6b, 0xe7, 0x4e, 0x1c, 0xb9, 0x06, 0x0c, 0x8a, 0x23, 0xb6,
	0xb0, 0xce, 0x78, 0x05, 0x7a, 0xa3, 0x28, 0x79, 0xe4, 0x24, 0x9e, 0x8d, 0xdf, 0x68, 0x56, 0x7e,
	0xa3, 0x2b, 0x70, 0x6e, 0xb3, 0x4f, 0xfd, 0x7f, 0xd8, 0x50, 0x9b, 0xd8, 0xf8, 0x8d, 0x56, 0xe5,
	0x37, 0xd6, 0x94, 0x76, 0xa8, 0xc5, 0xaf, 0xc3, 0xe9, 0x42, 0x5b, 0x65, 0xd8, 0x6d, 0xa4, 0x7c,
	0x53, 0x69, 0x71, 0x37, 0xe3, 0xc0, 0xb5, 0xfc, 0x93, 0xa9, 0x3f, 0x0e, 0x1d, 0x3a, 0x4b, 0x88,
	0xd0, 0xa2, 0x75, 0x51, 0xb1, 0x27, 0xe1, 0xc6, 0x75, 0x38, 0x91, 0x21, 0x93, 0xd0, 0x23, 0x09,
	0x97, 0x1a, 0x57, 0x29, 0xd9, 0xcf, 0x1e, 0xd6, 0xa0, 0xe0, 0xae, 0xe4, 0x2c, 0x40, 0x16, 0x02,
	0x12, 0x22, 0x87, 0x8c, 0x26, 0xeb, 0x4d, 0x58, 0x4f, 0x48, 0x1c, 0x1c, 0xd8, 0x34, 0xca, 0xd4,
	0xaf, 0xbb, 0x48, 0xfd, 0x06, 0x88, 0x7a, 0x2f, 0x92, 0xd2, 0x3d, 0x07, 0x3a, 0x5b, 0x2e, 0x79,
	0xe7, 0x3d, 0xee, 0x16, 0x30, 0x00, 0xf6, 0xfc, 0x0c, 0x0c, 0xa6, 0xc4, 0xf3, 0x1d, 0x7b, 0x9c,
	0x44, 0xb3, 0x98, 0xf1, 0xa1, 0xcf, 0xad, 0x00, 0x42, 0xdf, 0x62, 0xc0, 0x1d, 0xcf, 0x78, 0x01,
	0xd6, 0x9d, 0x19, 0x9d, 0x44, 0x89, 0x32, 0xfc, 0x01, 0xe2, 0xad, 0x71, 0x78, 0x3e, 0x7a, 0x66,
	0x17, 0xc8, 0x63, 0x3a, 0x5c, 0x13, 0x76, 0x81, 0x3c, 0xa6, 0xc6, 0xa7, 0xa0, 0x43, 0x42, 0xea,
	0x53, 0x9f, 0xa4, 0xc3, 0xf5, 0xcb, 0xf5, 0xe2, 0x5a, 0x26, 0xc8, 0xbc, 0xc5, 0x10, 0x0e, 0xac,
	0x0c, 0xd1, 0xb8, 0x01, 0xeb, 0xae, 0x83, 0x93, 0xd3, 0xce, 0x1a, 0x6f, 0x2c, 0x6f, 0xbc, 0x26,
	0x1a, 0xdc, 0x92, 0x7d, 0x3c, 0x0b, 0x4d, 0x67, 0xe6, 0xf9, 0xd1, 0xd0, 0x40, 0x66, 0xad, 0xe5,
	0x0d, 0xb7, 0x18, 0xd8, 0xe2, 0xb5, 0xc6, 0x75, 0xe8, 0x78, 0x91, 0x3b, 0x9b, 0x92, 0x90, 0x0e,
	0x4f, 0x20, 0xa6, 0x91, 0x63, 0xde, 0x14, 0x35, 0x56, 0x86, 0x63, 0xbc, 0x02, 0xba, 0x13, 0xfa,
	0x53, 0x07, 0x8d, 0xc9, 0x66, 0xd9, 0xfa, 0x6c, 0xc9, 0x2a, 0x2b, 0xc7, 0x62, 0x73, 0x61, 0xcc,
	0xb4, 0xe0, 0x64, 0x59, 0x4f, 0xdf, 0x72, 0xa6, 0xc4, 0xc2, 0xba, 0xdc, 0xa0, 0x9d, 0xc2, 0x61,
	0x2a, 0x5d, 0xa2, 0x31, 0xdb, 0xf3, 0xbf, 0x48, 0xa4, 0x41, 0xbb, 0x06, 0x6d, 0x31, 0xc9, 0x87,
	0xa7, 0xcb, 0x7a, 0x20, 0x26, 0xb9, 0x25, 0x31, 0x18, 0x17, 0x1e, 0xfa, 0x1e, 0x89, 0x86, 0xc3,
	0x32, 0x17, 0x3e, 0xcf, 0xc0, 0x16, 0xaf, 0x45, 0xb4, 0xc8, 0x77, 0xc9, 0xf0, 0xcc, 0x1c, 0x1a,
	0x03, 0x5b, 0xbc, 0xd6, 0x78, 0x15, 0x00, 0xf1, 0xed, 0x30, 0xa2, 0x64, 0x78, 0xb6, 0x3c, 0x7a,
	0xec, 0xf2, 0x9d, 0x88, 0x12, 0x4b, 0x7f, 0x28, 0xff, 0x1a, 0x43, 0x68, 0x0b, 0xd1, 0x0c, 0xcf,
	0xa1, 0x5e, 0xc8, 0x22, 0x1b, 0x88, 0x1b, 0x85, 0xd4, 0x71, 0xe9, 0xf0, 0x7c, 0x79, 0x20, 0xdb,
	0xbc, 0xc2, 0x92, 0x18, 0x4c, 0x4e, 0x41, 0xe4, 0x72, 0xb6, 0x5f, 0x28, 0xcb, 0xe9, 0x6d, 0x51,
	0x63, 0x65, 0x38, 0x38, 0x22, 0x12, 0xce, 0xc8, 0xf0, 0xe2, 0xdc, 0x88, 0x18, 0xd8, 0xe2, 0xb5,
	0x99, 0x9b, 0x73, 0x69, 0xb1, 0x9b, 0x63, 0xbc, 0x01, 0xeb, 0x21, 0x79, 0x84, 0xb6, 0xc6, 0x9e,
	0x92, 0xe9, 0x3e, 0x49, 0xd2, 0xe1, 0x65, 0x14, 0x53, 0xd9, 0x56, 0x0d, 0x42, 0xf2, 0x88, 0xd9,
	0x9a, 0xbb, 0x1c, 0x8b, 0xb5, 0x0c, 0xc8, 0x88, 0xaa, 0x4d, 0x87, 0x57, 0x2a, 0xad, 0xdc, 0x80,
	0xe1, 0xe5, 0x4d, 0xd9, 0xdc, 0xcc, 0xbe, 0xc9, 0xd7, 0x55, 0x93, 0xcf, 0x4d, 0xf1, 0x85, 0x7b,
	0xb8, 0xbc, 0x7e, 0x46, 0xc1, 0xe2, 0xea, 0xf3, 0xf4, 0x62, 0xf5, 0x91, 0x4d, 0x11, 0x62, 0x7c,
	0x02, 0x36, 0x3c, 0x12, 0x10, 0xe6, 0x5b, 0xe5, 0xad, 0x9f, 0xc1, 0x05, 0x63, 0x8d, 0x57, 0xe4,
	0xb8, 0x2f, 0x82, 0xc1, 0x4d, 0x04, 0xa2, 0xba, 0x09, 0x71, 0x28, 0xf1, 0x86, 0xcf, 0xf2, 0xd5,
	0x05, 0x6b, 0x18, 0xee, 0x36, 0x87, 0x1b, 0x9f, 0x86, 0xd3, 0xe9, 0x2c, 0x26, 0x49, 0x45, 0x93,
	0xe7, 0xb0, 0xc9, 0xc9, 0xbc, 0x5a, 0x6d, 0xf7, 0x32, 0xf3, 0xc5, 0xf9, 0x0e, 0xa0, 0xd0, 0xe8,
	0x79, 0x6c, 0x64, 0x88, 0x3a, 0xb5, 0xc5, 0x35, 0x30, 0xa6, 0xfe, 0x38, 0x61, 0x0e, 0x22, 0x8d,
	0x78, 0x23, 0xdf, 0x1b, 0x5e, 0x45, 0x33, 0xb7, 0x26, 0x6a, 0xee, 0x45, 0xac, 0xc5, 0x8e, 0x67,
	0x7c, 0x12, 0x36, 0x25, 0x72, 0xb6, 0x74, 0x30, 0xf4, 0x17, 0x10, 0x7d, 0x43, 0xd4, 0xc9, 0xd5,
	0x62, 0xc7, 0xab, 0x58, 0xf5, 0x3f, 0xb1, 0xe2, 0xaa, 0x7f, 0x0d, 0xda, 0x7e, 0xc8, 0xe7, 0xd3,
	0xb5, 0x72, 0x93, 0x1d, 0x5e, 0x61, 0x49, 0x0c, 0xe3, 0xa7, 0xc0, 0x48, 0x67, 0xae, 0x4b, 0xd2,
	0x74, 0x34, 0x0b, 0xec, 0xd8, 0x39, 0x40, 0x53, 0xf4, 0x22, 0xb6, 0x3b, 0xa7, 0xcc, 0xec, 0x0c,
	0x67, 0x97, 0xa3, 0x58, 0x1b, 0x69, 0x19, 0xc4, 0xd6, 0x2a, 0xe1, 0xac, 0x12, 0xcf, 0x7e, 0x44,
	0xf6, 0x53, 0x9f, 0x92, 0xe1, 0x4b, 0x7c, 0xad, 0xca, 0x2a, 0xde, 0xe7, 0x70, 0xe3, 0x4d, 0xe8,
	0xc7, 0x4e, 0x9a, 0xc6, 0x51, 0x82, 0xeb, 0x83, 0x33, 0xbc, 0x8e, 0xdf, 0x3c, 0xa5, 0xe8, 0x8e,
	0xa8, 0xbe, 0xe9, 0x50, 0xc7, 0xea, 0xc5, 0x4a, 0xc9, 0xd8, 0x82, 0x1e, 0x5f, 0x95, 0xa6, 0x4e,
	0xf2, 0x60, 0x16, 0x0f, 0x3f, 0x89, 0x6d, 0x2f, 0x96, 0xb7, 0x5c, 0x9f, 0x23, 0x07, 0xfb, 0x91,
	0x93, 0x78, 0x77, 0x11, 0xcb, 0xea, 0x62, 0x1b, 0x5e, 0x30, 0x7f, 0x59, 0x83, 0x7e, 0xc1, 0x86,
	0x67, 0x7e, 0xa5, 0xa6, 0xf8, 0x95, 0xa7, 0xa0, 0x15, 0x8d, 0x46, 0xcc, 0x9b, 0xa9, 0xa1, 0xa0,
	0x44, 0x89, 0xc1, 0x03, 0x12, 0x8e, 0xe9, 0x44, 0xb8, 0x1d, 0xa2, 0x24, 0xf7, 0x20, 0x8d, 0x7c,
	0x0f, 0x62, 0x42, 0x83, 0xf9, 0x9c, 0x0b, 0xdc, 0x0b, 0xac, 0x33, 0x23, 0xd0, 0xb3, 0x89, 0x62,
	0x9c, 0x86, 0xf6, 0xc8, 0x0f, 0x32, 0x7f, 0x48, 0xb7, 0x5a, 0xac, 0xb8, 0xe3, 0x31, 0x1f, 0xf7,
	0x91, 0xef, 0xd1, 0x89, 0x20, 0x85, 0x17, 0x18, 0x25, 0x13, 0xe2, 0x8f, 0x27, 0x72, 0x7f, 0x22,
	0x4a, 0x6c, 0xed, 0xc5, 0x6e, 0x52, 0xff, 0x8b, 0x72, 0x37, 0xd2, 0x61, 0x00, 0xf6, 0x0d, 0xf3,
	0x6f, 0x35, 0x68, 0xe2, 0x3a, 0xb4, 0xf8, 0x6b, 0x67, 0xa1, 0xe3, 0xcd, 0x12, 0x6e, 0xf1, 0xf8,
	0x07, 0xb3, 0xb2, 0x71, 0x1e, 0xf4, 0x98, 0x24, 0xa3, 0x28, 0x99, 0x92, 0x44, 0x6e, 0x0b, 0x32,
	0x40, 0xee, 0x8b, 0x37, 0x54, 0x5f, 0xfc, 0x1c, 0xe8, 0x53, 0x7f, 0x4a, 0x6c, 0x64, 0xb1, 0xd8,
	0x10, 0x30, 0xc0, 0x3d, 0xc6, 0xe6, 0x02, 0xb1, 0xad, 0x22, 0xb1, 0x6c, 0x71, 0xa2, 0x93, 0xd9,
	0x74, 0x7f, 0xde, 0xdb, 0x56, 0x16, 0x27, 0xc4, 0x30, 0xbf, 0xa1, 0x41, 0x47, 0xae, 0x9a, 0x8b,
	0x87, 0x96, 0x75, 0x58, 0x3b, 0xac, 0xc3, 0x8c, 0x30, 0x65, 0x03, 0x84, 0x84, 0xc9, 0x3d, 0x42,
	0x3e, 0xa4, 0xc6, 0xb2, 0x21, 0x35, 0x4b, 0xfc, 0xff, 0x6b, 0x0d, 0x9a, 0xb8, 0x5c, 0x3d, 0x29,
	0x69, 0xab, 0xd2, 0x6a, 0x94, 0xa4, 0x95, 0x0d, 0xb7, 0xb9, 0xca, 0x70, 0xf3, 0x11, 0xb5, 0x96,
	0x8d, 0xa8, 0x5d, 0x1a, 0xd1, 0x7f, 0x6a, 0xa0, 0x67, 0xee, 0xc7, 0x47, 0x6f, 0x54, 0xb9, 0x10,
	0x5b, 0xcb, 0x84, 0xd8, 0x5e, 0x36, 0xe4, 0x4e, 0x69, 0xc8, 0x0f, 0xa1, 0x89, 0xee, 0xc9, 0xf1,
	0xe6, 0x50, 0xe1, 0xbb, 0xf5, 0x65, 0xdf, 0x2d, 0x4f, 0xde, 0xdf, 0xd5, 0x40, 0xcf, 0x7c, 0x9d,
	0xc5, 0x1f, 0xcf, 0x4d, 0x54, 0xad, 0x60, 0xa2, 0x54, 0xa2, 0xea, 0x8b, 0x98, 0xda, 0x58, 0x99,
	0xa9, 0x95, 0xfa, 0xfd, 0x1b, 0x1a, 0xb4, 0x85, 0x0f, 0xc5, 0x36, 0x19, 0xf1, 0x24, 0x0a, 0x89,
	0x1d, 0xce, 0xd0, 0x03, 0xe1, 0x54, 0x76, 0x11, 0xf6, 0x0e, 0x82, 0x4a, 0x7b, 0xf1, 0xda, 0xd2,
	0xbd, 0x78, 0xbd, 0xb4, 0x17, 0x3f, 0x0d, 0x6d, 0x66, 0x43, 0xd9, 0xf8, 0x39, 0xa3, 0x5a, 0xac,
	0xc8, 0x55, 0xed, 0xa1, 0xeb, 0x24, 0x9e, 0x30, 0x36, 0xbc, 0x60, 0xde, 0x84, 0x8e, 0x74, 0xd7,
	0x98, 0x19, 0x0b, 0xa2, 0x70, 0xec, 0xd3, 0x99, 0xc7, 0xad, 0x7e, 0xdd, 0xca, 0x01, 0x8c, 0x4f,
	0x81, 0x43, 0x79, 0x65, 0x0d, 0x2b, 0xb3, 0xb2, 0xf9, 0x5d, 0x36, 0x7f, 0xd1, 0x83, 0x53, 0x1d,
	0x43, 0x6d, 0x05, 0xc7, 0x30, 0x33, 0x8e, 0x35, 0xd5, 0x38, 0x0e, 0xa1, 0xed, 0x78, 0x5e, 0x42,
	0xd2, 0x54, 0x8c, 0x4f, 0x16, 0x8d, 0xa7, 0xa1, 0x3f, 0x8a, 0x66, 0x49, 0xfa, 0x85, 0x99, 0x93,
	0x10, 0x39, 0x48, 0xdd, 0xea, 0xe5, 0xc0, 0x1d, 0xcf, 0x78, 0x1e, 0xd6, 0x14, 0x24, 0xc5, 0xc2,
	0x0e, 0x72, 0x30, 0xd3, 0x2b, 0x73, 0x0b, 0x80, 0x79, 0x96, 0xef, 0x72, 0x0f, 0x58, 0x6e, 0x98,
	0x34, 0x65, 0xc3, 0x74, 0x09, 0xba, 0x0f, 0x23, 0x4a, 0x12, 0x11, 0xf3, 0xe2, 0xaa, 0x03, 0x08,
	0xc2, 0x58, 0x97, 0xf9, 0x25, 0x68, 0xb0, 0x2e, 0x94, 0xa8, 0x8c, 0x8e, 0x51, 0x99, 0xb3, 0xd0,
	0xf9, 0xc2, 0x8c, 0xa4, 0x99, 0xae, 0xeb, 0x56, 0x56, 0x36, 0xae, 0x43, 0x3b, 0x8a, 0x79, 0x04,
	0xab, 0x8e, 0x1e, 0xe2, 0x66, 0xd1, 0xd3, 0xe5, 0xf4, 0x58, 0x12, 0x89, 0x09, 0xdc, 0x4f, 0x6d,
	0x37, 0x88, 0x52, 0xc2, 0x07, 0xdc, 0xb1, 0x3a, 0x7e, 0xba, 0x8d, 0x65, 0xd3, 0x81, 0x0d, 0xb6,
	0x74, 0xee, 0x26, 0x11, 0x53, 0x37, 0xd4, 0xcb, 0x94, 0x91, 0x4d, 0x23, 0xea, 0x04, 0x82, 0x6c,
	0x1e, 0x48, 0x00, 0x04, 0xf1, 0x10, 0xdd, 0x35, 0x68, 0xa1, 0x93, 0x99, 0x0e, 0x6b, 0x8b, 0x7d,
	0x54, 0x81, 0x62, 0xfe, 0x34, 0x34, 0x6e, 0xfb, 0xc1, 0x92, 0xb9, 0x55, 0x50, 0xfe, 0x5a, 0x69,
	0xbd, 0x92, 0x95, 0xb1, 0x23, 0xdc, 0x03, 0x61, 0x6e, 0x76, 0x1d, 0x3a, 0x31, 0xff, 0x44, 0x83,
	0x13, 0x16, 0x73, 0x43, 0x8a, 0xbe, 0x89, 0xf1, 0x1a, 0x74, 0x1e, 0x08, 0xc8, 0x50, 0x43, 0x0a,
	0x87, 0x39, 0x85, 0x12, 0xf7, 0xc6, 0x8c, 0x52, 0xa6, 0x4d, 0x12, 0x93, 0x09, 0x3e, 0x21, 0x8c,
	0x08, 0x3b, 0x6b, 0xcc, 0x03, 0x78, 0x03, 0x0e, 0x96, 0x0d, 0x99, 0xbf, 0xcd, 0xa6, 0x20, 0x65,
	0x16, 0x27, 0x43, 0xad, 0x73, 0x7f, 0x3b, 0x0a, 0xc9, 0x3d, 0x7f, 0x9a, 0xe3, 0x9e, 0x07, 0x3d,
	0x25, 0x01, 0x71, 0xa9, 0xff, 0x90, 0x08, 0xee, 0xe7, 0x00, 0xf3, 0x31, 0x0c, 0x8a, 0xe4, 0x54,
	0xaa, 0x11, 0x12, 0x86, 0xf2, 0xb7, 0xe5, 0x26, 0x2b, 0x23, 0x0c, 0xc1, 0xd2, 0x3a, 0xbc, 0x00,
	0xeb, 0x12, 0x31, 0x9b, 0x47, 0x82, 0x2e, 0x01, 0x97, 0x93, 0xc8, 0xfc, 0x99, 0x12, 0xe7, 0x2c,
	0x32, 0x8d, 0x1e, 0x12, 0xfe, 0x29, 0xf6, 0xcf, 0x56, 0x18, 0x28, 0x3e, 0xc5, 0xc0, 0xd5, 0xe3,
	0xaa, 0x95, 0xc7, 0x65, 0xc3, 0x66, 0x95, 0xd3, 0x68, 0xbc, 0x05, 0x6b, 0x22, 0x38, 0x5f, 0x92,
	0xcf, 0x42, 0x6f, 0x53, 0x48, 0x69, 0xe0, 0x17, 0xa0, 0xe6, 0x3f, 0xd6, 0xca, 0x5f, 0x58, 0xc2,
	0x3f, 0xe1, 0x47, 0xd6, 0x72, 0x3f, 0xf2, 0x93, 0xcc, 0x58, 0x8d, 0xfd, 0xd0, 0x66, 0xf0, 0xfa,
	0xbc, 0xa5, 0x19, 0xfb, 0xe1, 0xfd, 0x24, 0x60, 0x96, 0x86, 0xff, 0x63, 0x96, 0x23, 0x3b, 0x0c,
	0x40, 0x07, 0x5b, 0x58, 0x0e, 0x09, 0x44, 0x47, 0xfa, 0x3a, 0x9c, 0x48, 0x1f, 0xf9, 0xd4, 0x9d,
	0xd8, 0x85, 0x23, 0x0c, 0x6e, 0x3d, 0x36, 0x78, 0x95, 0x72, 0x7c, 0x61, 0xdc, 0x86, 0xcb, 0x15,
	0xf8, 0xb6, 0x3b, 0x4b, 0x12, 0x12, 0xd2, 0x3c, 0x20, 0xa6, 0x5b, 0xe7, 0xe7, 0x1a, 0x6f, 0x73,
	0x24, 0x8c, 0x86, 0xbd, 0xa9, 0x10, 0x87, 0xd1, 0x89, 0x76, 0xd9, 0xfb, 0x97, 0x07, 0x15, 0x18,
	0xa5, 0xc8, 0x88, 0x66, 0x25, 0xc6, 0x9c, 0xd8, 0xe1, 0x67, 0x1b, 0x1d, 0x8b, 0xfd, 0x35, 0xbf,
	0xae, 0x31, 0xb3, 0x2e, 0x06, 0x3e, 0x7f, 0x0e, 0xa0, 0xc4, 0xb9, 0x90, 0xd3, 0x9c, 0xad, 0x32,
	0xce, 0x75, 0x8f, 0x31, 0xfc, 0x0a, 0xf4, 0xf6, 0x23, 0x6a, 0x67, 0xe1, 0x62, 0x3e, 0x6f, 0xbb,
	0xfb, 0x11, 0xbd, 0x2f, 0x23, 0xc6, 0x2f, 0xc3, 0xa6, 0x54, 0xd5, 0x47, 0x89, 0x4f, 0x89, 0xed,
	0xe0, 0x06, 0x48, 0x4c, 0x11, 0x43, 0xd4, 0xbd, 0xcf, 0xaa, 0xb6, 0xb0, 0xc6, 0xfc, 0xa1, 0x06,
	0xfd, 0xc2, 0x81, 0xcb, 0x9c, 0xd5, 0x5c, 0x25, 0xc0, 0xa9, 0x9c, 0x9f, 0xd5, 0x0f, 0x3d, 0x3f,
	0xfb, 0x04, 0x6c, 0x08, 0xc9, 0x28, 0x01, 0x46, 0x2e, 0x79, 0xa1, 0xc7, 0x79, 0x6c, 0x91, 0x69,
	0x08, 0x6e, 0x43, 0xc3, 0x94, 0x3a, 0xa1, 0x2b, 0x17, 0x8d, 0x1e, 0x03, 0xee, 0x08, 0x98, 0x08,
	0xaf, 0x3a, 0x42, 0xaa, 0xf8, 0xdf, 0x78, 0x0e, 0xd6, 0x98, 0xd0, 0xec, 0x74, 0xc2, 0x76, 0x6f,
	0xa1, 0x94, 0x9f, 0x6e, 0xf5, 0x19, 0x78, 0x8f, 0x41, 0xd9, 0xda, 0x6c, 0x7e, 0x0e, 0xe0, 0x76,
	0x94, 0xb8, 0x04, 0xa7, 0x2d, 0xb3, 0xd1, 0x23, 0x56, 0xb2, 0x71, 0x1b, 0x26, 0x26, 0x29, 0x8c,
	0x72, 0x84, 0xe5, 0x13, 0xf4, 0x5d, 0xd0, 0xf3, 0x98, 0x80, 0x09, 0xfd, 0x74, 0xea, 0x04, 0x81,
	0x5d, 0xb4, 0xcf, 0x5d, 0x04, 0xde, 0xe6, 0x46, 0xfa, 0x22, 0x74, 0xf7, 0xfd, 0x71, 0x86, 0x21,
	0xdc, 0x8a, 0x7d, 0x7f, 0xcc, 0xeb, 0xcd, 0xaf, 0xb6, 0x00, 0x94, 0x98, 0x87, 0xdc, 0xa8, 0x69,
	0x8b, 0x37, 0x6a, 0xcc, 0xa7, 0x4a, 0xa9, 0x43, 0x67, 0xa9, 0xe8, 0x4d, 0x94, 0x98, 0x03, 0x33,
	0x0b, 0xa9, 0x1f, 0xd8, 0x4a, 0x24, 0x5a, 0x47, 0xc8, 0x4d, 0x1e, 0x8e, 0xee, 0xbb, 0x4e, 0x68,
	0xef, 0x13, 0x9b, 0x9f, 0x1e, 0x0a, 0x95, 0xe9, 0xba, 0x4e, 0x78, 0x83, 0xdc, 0x42, 0x10, 0x13,
	0x1c, 0xc3, 0x89, 0xa3, 0x94, 0x4a, 0xd1, 0xa5, 0x28, 0x90, 0x8e, 0xb5, 0xe6, 0x3a, 0xe1, 0x6e,
	0x94, 0x52, 0x21, 0xb9, 0x54, 0xe2, 0x62, 0x6c, 0x35, 0xc3, 0x6d, 0x65, 0xb8, 0xac, 0xc7, 0x0c,
	0xf7, 0x3a, 0x0f, 0xce, 0x8b, 0x68, 0x4b, 0x86, 0xdd, 0x46, 0x6c, 0xd6, 0xcd, 0x4d, 0xac, 0xc9,
	0xf0, 0x5f, 0x86, 0x4d, 0x86, 0x9f, 0x90, 0x94, 0x26, 0xbe, 0x9b, 0x87, 0x9c, 0x3a, 0x22, 0x0e,
	0xe2, 0x84, 0x96, 0xa8, 0x92, 0x61, 0x26, 0xf1, 0x85, 0x38, 0x89, 0xa6, 0x11, 0x7e, 0x82, 0x37,
	0xd0, 0xb3, 0x2f, 0xec, 0xf2, 0x1a, 0x89, 0xff, 0x1c, 0x30, 0x22, 0xf1, 0xbc, 0x95, 0xa9, 0x67,
	0x38, 0x8a, 0x30, 0xf0, 0xdc, 0xb1, 0x18, 0x93, 0xb6, 0x11, 0x8a, 0xe7, 0x79, 0x57, 0x61, 0x9d,
	0xe1, 0x89, 0xc3, 0x11, 0xc6, 0x7f, 0x7e, 0x84, 0xd1, 0xb1, 0x06, 0xae, 0x13, 0xee, 0x20, 0x98,
	0xc9, 0x26, 0x95, 0x98, 0xb1, 0x1f, 0xe6, 0x03, 0xec, 0x65, 0x98, 0xbb, 0x7e, 0x98, 0x8d, 0x8e,
	0x7b, 0x16, 0x22, 0x16, 0xd6, 0x97, 0x9e, 0x85, 0xd0, 0x00, 0xc1, 0xd6, 0x94, 0x84, 0x5e, 0xde,
	0xcf, 0x20, 0x63, 0xeb, 0x1e, 0x09, 0xbd, 0xac, 0xa3, 0xd7, 0xe1, 0xb4, 0x82, 0xeb, 0xf9, 0x4e,
	0xde, 0x62, 0x8d, 0x9f, 0x2d, 0x66, 0x2d, 0x3c, 0xdf, 0xc9, 0x9a, 0x3d, 0x03, 0x83, 0xac, 0x59,
	0x1c, 0x05, 0x41, 0x3a, 0x5c, 0x47, 0xec, 0x9e, 0xc0, 0x66, 0xde, 0x50, 0xb1, 0xf3, 0x88, 0x4e,
	0x48, 0x92, 0x77, 0xbe, 0x51, 0xe8, 0xfc, 0x5d, 0x56, 0x99, 0x75, 0xfe, 0x06, 0x9c, 0x61, 0xcd,
	0x1c, 0x0f, 0xa3, 0x2f, 0x76, 0xcc, 0x66, 0x7f, 0x9c, 0x90, 0x87, 0x3e, 0x79, 0x94, 0x62, 0x1c,
	0xba, 0x63, 0x9d, 0x74, 0x9d, 0x70, 0xcb, 0xf3, 0xde, 0x27, 0xfb, 0xbb, 0xce, 0x98, 0xec, 0x8a,
	0x4a, 0xf3, 0x97, 0xea, 0xb0, 0x56, 0x3a, 0x0c, 0xaa, 0xe6, 0x86, 0x76, 0x64, 0x6e, 0xd4, 0x8e,
	0xc4, 0x8d, 0xfa, 0xd1, 0xb8, 0xd1, 0x38, 0x2e, 0x37, 0x9a, 0x4b, 0xb8, 0x51, 0xa5, 0xa0, 0xad,
	0x55, 0x15, 0xb4, 0xbd, 0xb2, 0x82, 0x76, 0xaa, 0x14, 0xd4, 0xdc, 0x07, 0xc3, 0x22, 0x69, 0x1c,
	0x85, 0x29, 0xd9, 0x75, 0x12, 0x67, 0x4a, 0x28, 0x6b, 0x5f, 0x1d, 0x6a, 0xd4, 0xaa, 0x43, 0x8d,
	0x97, 0xa0, 0x9b, 0x10, 0x9a, 0x1c, 0xd8, 0xce, 0x88, 0x92, 0x44, 0xba, 0xf0, 0x08, 0xda, 0x62,
	0x10, 0x93, 0xc2, 0xda, 0x4e, 0x18, 0xcf, 0x28, 0x0a, 0x83, 0xdb, 0xd3, 0xaa, 0xd8, 0xd7, 0x26,
	0x34, 0x51, 0x96, 0x72, 0xab, 0x82, 0x05, 0x35, 0xa0, 0x5e, 0x2f, 0x06, 0xd4, 0x2f, 0x00, 0xc4,
	0x4e, 0x92, 0x12, 0x7b, 0x1a, 0x79, 0x32, 0x1e, 0xa2, 0x23, 0xe4, 0x6e, 0xe4, 0x11, 0xf3, 0x2b,
	0x35, 0xf5, 0xb3, 0x3c, 0xfa, 0xb1, 0xfa, 0x67, 0x37, 0xe5, 0xce, 0x54, 0x1e, 0xf0, 0xe2, 0x26,
	0x54, 0x21, 0xa6, 0xb1, 0x8c, 0x98, 0x66, 0x89, 0x98, 0x3c, 0x0e, 0xd1, 0xaa, 0x8e, 0x43, 0xb4,
	0x17, 0xc6, 0x21, 0x3a, 0xa5, 0x2d, 0xf3, 0x4b, 0x60, 0xa4, 0xb3, 0x38, 0x8e, 0x12, 0x9a, 0xda,
	0x29, 0x4d, 0x88, 0x33, 0xf5, 0xc3, 0xb1, 0x34, 0x7e, 0xb2, 0x66, 0x4f, 0x56, 0x98, 0xff, 0xa0,
	0xc1, 0x89, 0x9c, 0x0b, 0x79, 0xc4, 0xe4, 0x7f, 0x3f, 0x27, 0xcc, 0x7f, 0xd2, 0x54, 0x01, 0xf3,
	0xf0, 0xe2, 0x8f, 0x6c, 0x58, 0x2a, 0xa1, 0xad, 0x65, 0xe1, 0xcb, 0xf6, 0xc2, 0xf0, 0x65, 0x47,
	0xd9, 0xa1, 0x9b, 0x5f, 0xd3, 0xc0, 0xc8, 0x07, 0x97, 0xc5, 0x18, 0x7f, 0x54, 0xe3, 0x33, 0xbb,
	0xa0, 0x23, 0x39, 0xcc, 0x97, 0x31, 0xbf, 0xa1, 0xc1, 0x09, 0x27, 0x4c, 0x1f, 0x91, 0xa4, 0xe8,
	0x6d, 0xa2, 0x09, 0x57, 0xf3, 0x81, 0x72, 0x4f, 0x69, 0xad, 0x90, 0xf9, 0xb3, 0xe3, 0x65, 0xbb,
	0x90, 0x9a, 0xb2, 0x0b, 0xb9, 0x00, 0x90, 0x4e, 0xa2, 0x47, 0xb6, 0x13, 0x90, 0x84, 0x0a, 0xdb,
	0xac, 0x33, 0xc8, 0x16, 0x03, 0x54, 0x04, 0xbb, 0x2f, 0x00, 0xb8, 0x8e, 0x3b, 0xe1, 0x1b, 0x4d,
	0x11, 0x15, 0xd2, 0x11, 0xc2, 0x76, 0x98, 0xe6, 0x37, 0x6b, 0xd0, 0x16, 0x67, 0x84, 0x4f, 0x2a,
	0x44, 0x78, 0x09, 0xba, 0x7e, 0x6a, 0xf3, 0xd3, 0xce, 0xcc, 0xb1, 0x02, 0x3f, 0xdd, 0x12, 0x90,
	0xa3, 0xc4, 0x09, 0x37, 0xa1, 0x49, 0xa6, 0xd1, 0xcf, 0xfa, 0xc2, 0xd7, 0xe5, 0x05, 0xe3, 0x0c,
	0x74, 0xb2, 0xfc, 0x07, 0xae, 0x2c, 0xed, 0x54, 0x24, 0x3e, 0xbc, 0x09, 0xfd, 0xa9, 0x93, 0x3e,
	0x60, 0x4e, 0x9b, 0x9f, 0x4d, 0x89, 0xc2, 0x2e, 0xe6, 0xae, 0x93, 0x3e, 0xd8, 0x15, 0xb5, 0x56,
	0x6f, 0xaa, 0x94, 0x8a, 0x31, 0x04, 0xbd, 0x14, 0x40, 0xfb, 0x03, 0x0d, 0x20, 0x4f, 0x99, 0x60,
	0xc2, 0xc1, 0xef, 0x0b, 0x35, 0xc3, 0xed, 0x48, 0x75, 0x24, 0xa9, 0xc4, 0x8f, 0xfa, 0x1c, 0x3f,
	0x9e, 0x85, 0x01, 0xee, 0xc8, 0xfd, 0x30, 0xb5, 0x19, 0x3d, 0x72, 0x11, 0xed, 0x4b, 0x28, 0x23,
	0x39, 0x35, 0x5e, 0x82, 0x8e, 0x38, 0xc4, 0x65, 0x8b, 0x65, 0xbd, 0xfa, 0x9c, 0x37, 0x43, 0x31,
	0x03, 0xe8, 0xa9, 0x43, 0x65, 0xc4, 0xc5, 0x91, 0x1f, 0xca, 0x4d, 0x2d, 0x2f, 0x30, 0x99, 0x3f,
	0xb6, 0xd3, 0x89, 0x3f, 0xa2, 0x22, 0xa2, 0xd6, 0x7a, 0xbc, 0xc7, 0x4a, 0xac, 0xe2, 0x40, 0x54,
	0xd4, 0x79, 0xc5, 0x01, 0xaf, 0xd8, 0x84, 0x66, 0xea, 0x3a, 0xe2, 0x2c, 0xa1, 0x6e, 0xf1, 0x82,
	0xf9, 0x1d, 0x0d, 0xd6, 0x1c, 0xcf, 0x13, 0x64, 0xdc, 0x8b, 0x18, 0x8b, 0x94, 0x38, 0xa0, 0x56,
	0x88, 0x03, 0x4a, 0xde, 0xd5, 0x14, 0xde, 0x5d, 0x82, 0x6e, 0x1c, 0x8e, 0x65, 0xb6, 0x8a, 0x98,
	0x92, 0x10, 0x87, 0x63, 0xa9, 0x9d, 0xa7, 0xa0, 0x85, 0xd2, 0x4f, 0x85, 0x76, 0x8b, 0xd2, 0xbc,
	0xc4, 0x9b, 0xab, 0x4b, 0xdc, 0xfc, 0x1d, 0x0d, 0xba, 0xea, 0x66, 0xfa, 0x38, 0x9b, 0x41, 0x35,
	0xde, 0x58, 0x5f, 0x2d, 0xde, 0xc8, 0xb7, 0xf4, 0xe2, 0x30, 0x06, 0x0b, 0xca, 0xb1, 0x16, 0x37,
	0x2c, 0xa2, 0x64, 0x7e, 0xab, 0x06, 0x1b, 0xdc, 0x90, 0xa8, 0x74, 0x3e, 0x97, 0x85, 0x40, 0x4a,
	0x46, 0xa4, 0xaf, 0x24, 0x33, 0xee, 0x78, 0xc6, 0xeb, 0xd0, 0xe6, 0x09, 0x8c, 0x32, 0xc8, 0x76,
	0xae, 0x3a, 0x07, 0x92, 0x27, 0x30, 0x4a, 0xdc, 0x92, 0xd1, 0xa8, 0x97, 0x8c, 0x86, 0xd0, 0xe8,
	0x98, 0x24, 0x69, 0x14, 0x3a, 0x41, 0x3e, 0xc3, 0x77, 0x05, 0x84, 0x21, 0x84, 0xe4, 0x31, 0xb5,
	0x0b, 0x23, 0x02, 0x06, 0x7a, 0x97, 0x1f, 0xd6, 0x3d, 0x03, 0x03, 0x11, 0xb4, 0x88, 0xa7, 0x3c,
	0x00, 0x20, 0xf2, 0xcd, 0x38, 0x74, 0x77, 0x8a, 0x11, 0x80, 0x3c, 0x14, 0x12, 0x4f, 0xed, 0x58,
	0xfa, 0x5e, 0x62, 0xca, 0x6f, 0x48, 0xd4, 0xcc, 0x29, 0x33, 0x4f, 0xc0, 0xc6, 0xdc, 0xa0, 0xcc,
	0xdf, 0xaa, 0xc3, 0x70, 0x0e, 0xba, 0x95, 0x50, 0xdf, 0x0d, 0x48, 0xe5, 0x62, 0xc1, 0x75, 0xa0,
	0x96, 0xe9, 0x40, 0x75, 0x22, 0xdb, 0x7b, 0x70, 0xd2, 0x67, 0xd6, 0x3e, 0xdb, 0xd4, 0xb3, 0xc9,
	0x4a, 0x42, 0x99, 0xe0, 0x74, 0x41, 0xe5, 0x33, 0xae, 0x51, 0x88, 0xb5, 0xcd, 0x91, 0xac, 0x13,
	0xfe, 0x3c, 0x70, 0xee, 0x08, 0xb5, 0x79, 0xe4, 0x23, 0x54, 0x69, 0xff, 0x5b, 0xb9, 0xfd, 0x3f,
	0x03, 0x9d, 0x89, 0xef, 0x11, 0x8c, 0x51, 0x71, 0x4f, 0xb8, 0xcd, 0xca, 0xf7, 0x93, 0x60, 0x85,
	0x44, 0xb8, 0x73, 0xa0, 0xa3, 0x1d, 0xc6, 0xd6, 0x3c, 0x67, 0xa9, 0x83, 0x00, 0xd6, 0xfc, 0x12,
	0x74, 0x79, 0x25, 0x5f, 0x1b, 0x40, 0x04, 0x78, 0x19, 0xe8, 0x7d, 0x5c, 0x20, 0xae, 0x40, 0x8f,
	0x23, 0x88, 0x65, 0xa2, 0xcb, 0x73, 0x99, 0x10, 0x76, 0x07, 0x41, 0xe6, 0xf7, 0xea, 0x70, 0x6a,
	0x4e, 0x38, 0x8b, 0xfd, 0xdf, 0xb2, 0x68, 0xce, 0x81, 0x8e, 0xf1, 0xe1, 0x2c, 0x02, 0xa7, 0x5b,
	0x1d, 0x04, 0x30, 0xfa, 0x0a, 0xc4, 0x37, 0xe6, 0x89, 0xe7, 0x2d, 0x39, 0xf1, 0x7c, 0x5d, 0x04,
	0x04, 0x65, 0xc4, 0x73, 0x04, 0x41, 0x3c, 0xf7, 0x58, 0x78, 0x23, 0x4e, 0x7c, 0xae, 0x18, 0x6d,
	0x55, 0x31, 0x0e, 0xe7, 0xaa, 0xe2, 0x61, 0xe8, 0xcb, 0x3c, 0x0c, 0x28, 0x7b, 0x50, 0x65, 0x05,
	0xe9, 0x1e, 0x5d, 0x41, 0x16, 0xaa, 0x6d, 0xef, 0xb8, 0x6a, 0x6b, 0x7e, 0xa7, 0x2e, 0xa3, 0xa8,
	0x8a, 0x0c, 0xdf, 0xf2, 0x47, 0x2b, 0x49, 0xf0, 0x34, 0xb4, 0xc7, 0xfe, 0x48, 0x91, 0x5f, 0x6b,
	0xec, 0x8f, 0x84, 0xf4, 0x58, 0x05, 0x17, 0x8f, 0x38, 0x6f, 0x1b, 0xfb, 0x23, 0x2e, 0x9c, 0x0b,
	0x00, 0xac, 0x52, 0x88, 0x46, 0x38, 0x35, 0x63, 0x7f, 0x24, 0x04, 0x73, 0x05, 0x7a, 0xac, 0xba,
	0xe4, 0x6d, 0x76, 0xc7, 0xfe, 0xe8, 0xa6, 0x72, 0xd6, 0x97, 0x2b, 0x47, 0xbb, 0xa4, 0x1c, 0x95,
	0xfe, 0xe6, 0xff, 0x35, 0xb1, 0xfd, 0x45, 0x1d, 0xce, 0xcc, 0x89, 0xed, 0x6e, 0x4c, 0xc6, 0xaf,
	0xad, 0x2a, 0xbb, 0x73, 0xa0, 0x4f, 0x19, 0xbe, 0x3a, 0xfb, 0x10, 0x20, 0x26, 0x18, 0xaf, 0x54,
	0x25, 0x08, 0x08, 0xca, 0x26, 0x18, 0x47, 0x28, 0x48, 0x91, 0x37, 0x12, 0x72, 0x7c, 0x16, 0x06,
	0x1c, 0xa5, 0x24, 0xc9, 0x3e, 0x42, 0x7f, 0x2c, 0xcb, 0x4c, 0x96, 0xbf, 0xd8, 0xa8, 0x30, 0xa3,
	0x8b, 0xf7, 0xf3, 0x15, 0x82, 0xe4, 0x59, 0x7c, 0x8a, 0x20, 0x11, 0x20, 0x26, 0xe2, 0xd2, 0x94,
	0x8a, 0x9c, 0xf5, 0xcd, 0x45, 0xac, 0x6f, 0x2d, 0x60, 0x7d, 0x7b, 0x19, 0xeb, 0x3b, 0x65, 0xd6,
	0x5f, 0x82, 0x2e, 0xa7, 0x92, 0x6b, 0x94, 0x2e, 0xce, 0x41, 0x19, 0x28, 0xd3, 0x28, 0x8e, 0x20,
	0x34, 0x4a, 0xe4, 0xce, 0x22, 0x2c, 0xd7, 0x28, 0x8e, 0x92, 0x69, 0x14, 0x5f, 0x94, 0xfa, 0x08,
	0xcd, 0x34, 0xaa, 0x64, 0xc3, 0x7b, 0xf3, 0x36, 0xbc, 0xac, 0x07, 0xfd, 0x27, 0xa8, 0x07, 0x83,
	0x63, 0xeb, 0xc1, 0x57, 0xaa, 0x96, 0xd3, 0xc5, 0xdb, 0xfe, 0x0a, 0x3d, 0xc0, 0x1c, 0x58, 0x55,
	0x0f, 0x10, 0x50, 0x90, 0x66, 0x63, 0x81, 0x34, 0x9b, 0xcb, 0xa4, 0xd9, 0x2a, 0x4b, 0x73, 0xf9,
	0x8e, 0xff, 0x59, 0x18, 0x70, 0x4a, 0x4a, 0xa1, 0x8d, 0x3e, 0x42, 0x33, 0x39, 0x95, 0xa5, 0xa0,
	0x3f, 0x41, 0x29, 0xc0, 0xb1, 0xa5, 0xf0, 0x2f, 0xb5, 0xaa, 0xd9, 0x88, 0x79, 0x29, 0xab, 0xce,
	0x46, 0x86, 0x5c, 0x98, 0x8d, 0x0c, 0xf0, 0x01, 0x48, 0x81, 0xcd, 0x07, 0xfc, 0x56, 0xc6, 0xe7,
	0xb6, 0x98, 0x0f, 0x0c, 0xba, 0x90, 0xcf, 0x9d, 0x27, 0xc8, 0x67, 0xfd, 0xd8, 0x7c, 0xfe, 0xd7,
	0xaa, 0x15, 0x6c, 0x69, 0x1c, 0x68, 0x35, 0xd7, 0xfe, 0xd8, 0x11, 0xae, 0x2b, 0xd0, 0x93, 0x69,
	0xe1, 0x76, 0xee, 0x86, 0x77, 0x25, 0x6c, 0xce, 0x9a, 0x96, 0x73, 0x9b, 0x0e, 0x77, 0x1d, 0x3f,
	0x92, 0x0a, 0x5f, 0x5c, 0x05, 0xba, 0xcb, 0xb7, 0x09, 0xbd, 0x43, 0xb7, 0x09, 0xfd, 0xf9, 0x6d,
	0xc2, 0x37, 0xab, 0x24, 0x9d, 0x25, 0x0d, 0xad, 0x22, 0x69, 0x35, 0x75, 0xa8, 0x5e, 0x4c, 0x1d,
	0x2a, 0x26, 0x1d, 0x35, 0xca, 0x49, 0x47, 0x99, 0x8e, 0x34, 0x4b, 0x41, 0x9d, 0xc0, 0x7f, 0x48,
	0xd8, 0x26, 0xd8, 0x8f, 0x3c, 0xe1, 0x97, 0x00, 0x03, 0xed, 0x22, 0x64, 0x4e, 0x52, 0xed, 0x27,
	0x28, 0xa9, 0xce, 0x93, 0x91, 0xd4, 0x07, 0xb1, 0xa1, 0xfb, 0xb7, 0xaa, 0x15, 0x88, 0xe7, 0x65,
	0xfd, 0x28, 0xc4, 0xa4, 0x64, 0x71, 0xb5, 0x0e, 0xc9, 0xe2, 0x6a, 0xaf, 0x96, 0xc5, 0xd5, 0xa9,
	0xca, 0xe2, 0xfa, 0xb8, 0xce, 0xcb, 0x6f, 0x57, 0xc5, 0x56, 0x64, 0x1e, 0xd1, 0x2a, 0xf2, 0x2e,
	0x67, 0x22, 0xd6, 0x0f, 0xcb, 0x44, 0x6c, 0x2c, 0xcd, 0x44, 0x6c, 0x96, 0x32, 0x11, 0xb3, 0x84,
	0xc3, 0x96, 0x92, 0x70, 0xf8, 0x71, 0x9d, 0x9a, 0xbf, 0xaf, 0xc1, 0xc9, 0xf9, 0x7d, 0x3a, 0x63,
	0xd3, 0x2a, 0x92, 0xaa, 0x48, 0x30, 0xa9, 0x57, 0x24, 0x98, 0xcc, 0x31, 0xb7, 0x71, 0xf4, 0x7b,
	0x00, 0xff, 0x5e, 0x83, 0xf3, 0xf3, 0x5a, 0xe5, 0xb8, 0x13, 0xe2, 0xad, 0x1e, 0x1a, 0x32, 0xa1,
	0xcf, 0xe3, 0x37, 0xf2, 0x48, 0x23, 0x57, 0x2d, 0x1a, 0xdd, 0xce, 0xce, 0x35, 0x2a, 0x9c, 0xa9,
	0xd2, 0x2a, 0xdc, 0x5c, 0x1a, 0xc0, 0x69, 0x2d, 0x73, 0x10, 0xda, 0x87, 0xed, 0x1e, 0x3f, 0x1a,
	0x7e, 0xd4, 0x9f, 0xd6, 0xe0, 0xec, 0x02, 0x7e, 0xaf, 0x1a, 0x0a, 0xb8, 0x08, 0xdd, 0xb1, 0x3f,
	0x2a, 0xf1, 0x5a, 0x1f, 0xfb, 0xa3, 0xa5, 0x9c, 0x3e, 0xb6, 0xdb, 0xfa, 0x91, 0x9c, 0xc1, 0xe6,
	0x5f, 0xd5, 0xe0, 0xd2, 0x02, 0x3e, 0x1e, 0x29, 0xae, 0x62, 0x02, 0x0f, 0x70, 0x94, 0x55, 0x17,
	0x81, 0x1f, 0x27, 0x86, 0x7e, 0xb9, 0x06, 0x17, 0x17, 0x30, 0x54, 0x9e, 0x0a, 0xad, 0x68, 0xba,
	0xe4, 0x25, 0xe8, 0x22, 0x47, 0xfb, 0x02, 0x2c, 0x78, 0xfa, 0x3f, 0x37, 0x5d, 0x8b, 0x99, 0xd0,
	0x3c, 0x36, 0x13, 0xfe, 0x6b, 0xb1, 0x56, 0x3d, 0x81, 0xbd, 0xce, 0x55, 0x58, 0xcf, 0xb6, 0x2c,
	0x92, 0x39, 0x5c, 0xa5, 0x06, 0x12, 0x2e, 0xb8, 0xf3, 0xb1, 0x33, 0x8b, 0x4b, 0x96, 0xa1, 0xd5,
	0x43, 0x6b, 0x26, 0xf0, 0xd0, 0x52, 0x79, 0x2e, 0x23, 0xf0, 0xc7, 0xcb, 0x90, 0xca, 0xef, 0xbf,
	0x5c, 0xc2, 0xef, 0x95, 0x83, 0x27, 0x8c, 0xdf, 0x18, 0xd0, 0x28, 0xf3, 0x9b, 0x01, 0x3f, 0x4e,
	0xb6, 0xf3, 0xbb, 0x8b, 0xb9, 0xb9, 0x7a, 0x40, 0xd0, 0x04, 0x1e, 0x70, 0x2b, 0x73, 0x13, 0x81,
	0x82, 0x9b, 0xc7, 0x8e, 0x96, 0x94, 0xf9, 0xd6, 0x7a, 0x82, 0x7c, 0x6b, 0x1f, 0x9b, 0x6f, 0x27,
	0xb3, 0x64, 0xb0, 0x02, 0xf8, 0xeb, 0x1a, 0x9c, 0x46, 0xf8, 0x3d, 0xf2, 0xb8, 0xec, 0xb9, 0x5f,
	0x81, 0x9e, 0xfc, 0xbe, 0x72, 0x6b, 0xa0, 0x2b, 0x60, 0xf7, 0x44, 0xda, 0x8e, 0xc2, 0x8a, 0x5a,
	0x99, 0x15, 0xff, 0x0f, 0x86, 0x9e, 0x9f, 0x3a, 0xfb, 0x01, 0x99, 0x4b, 0x8c, 0x14, 0xf9, 0x22,
	0x27, 0x45, 0x7d, 0x31, 0x31, 0xd2, 0x7c, 0x0c, 0xe7, 0x90, 0x2a, 0x19, 0x0b, 0x29, 0x51, 0xa6,
	0x6e, 0xa7, 0xb5, 0x65, 0xdb, 0xe9, 0x5a, 0x79, 0x3b, 0x5d, 0x8a, 0x6f, 0xd4, 0xcb, 0xf1, 0x0d,
	0xf3, 0x6f, 0x34, 0xb6, 0xf5, 0x8b, 0x67, 0x7c, 0x73, 0xff, 0xc4, 0xbe, 0xbb, 0x30, 0x22, 0x27,
	0xb7, 0xf1, 0x8d, 0x43, 0xb6, 0xf1, 0xcd, 0xd5, 0xb6, 0xf1, 0xad, 0xca, 0xcb, 0x58, 0xbf, 0xa6,
	0x31, 0x4f, 0x38, 0x9e, 0xc9, 0x3d, 0xec, 0xbc, 0xa0, 0x3f, 0xc8, 0x7b, 0x73, 0xd9, 0x6e, 0xb5,
	0xa1, 0x5e, 0x8f, 0xfb, 0x33, 0x0d, 0x8c, 0xf9, 0xc7, 0xa6, 0x58, 0x4f, 0x3c, 0x5b, 0x23, 0xcf,
	0xfd, 0xe8, 0x70, 0xc0, 0xce, 0x07, 0x93, 0xb6, 0x72, 0x94, 0x6b, 0x0c, 0x59, 0x8a, 0x4b, 0x53,
	0x49, 0x71, 0x31, 0xff, 0x38, 0xcb, 0x89, 0x2b, 0x3c, 0x59, 0xc5, 0x7a, 0x2e, 0xbe, 0x71, 0xa5,
	0xe4, 0xc4, 0x15, 0x5e, 0xb3, 0xda, 0xf1, 0x98, 0x85, 0x8a, 0x1e, 0x88, 0x0c, 0xe6, 0x5a, 0xf4,
	0xc0, 0xd8, 0x86, 0xf5, 0xac, 0x6d, 0xf1, 0x42, 0xdb, 0x70, 0xfe, 0x85, 0x2c, 0x71, 0xa9, 0x2d,
	0xeb, 0xf4, 0x5d, 0x71, 0xb9, 0xed, 0x69, 0xe8, 0x17, 0xdf, 0x7f, 0x12, 0xf7, 0x72, 0x88, 0xf2,
	0xf6, 0x93, 0xf9, 0xf3, 0x1a, 0x9c, 0xe2, 0xd4, 0x97, 0x1f, 0xcb, 0x32, 0x5e, 0x81, 0x93, 0xf3,
	0x8f, 0x6c, 0xe5, 0x83, 0x30, 0xca, 0x6f, 0x69, 0x55, 0x8c, 0x63, 0x8e, 0x84, 0x7a, 0x05, 0x09,
	0x9f, 0x85, 0xde, 0xdb, 0xce, 0x3e, 0x09, 0x88, 0xb7, 0x9b, 0xb0, 0x05, 0x71, 0x13, 0x9a, 0x01,
	0x2b, 0xcb, 0x94, 0x2e, 0x2c, 0x18, 0xa7, 0xa0, 0xe5, 0x4c, 0x95, 0xab, 0x82, 0xa2, 0x64, 0x7e,
	0x4b, 0x83, 0xb6, 0x78, 0x6c, 0x20, 0x9f, 0x66, 0xda, 0x12, 0x97, 0xa3, 0x36, 0xef, 0x72, 0x3c,
	0xcf, 0x5c, 0x69, 0x27, 0xa1, 0x4a, 0x36, 0x4e, 0x5d, 0x3e, 0x40, 0xe4, 0x24, 0x34, 0x4b, 0xc5,
	0x61, 0x16, 0x80, 0xdf, 0x40, 0x72, 0x65, 0x9e, 0x53, 0x56, 0xc6, 0x58, 0x05, 0xde, 0x0c, 0x14,
	0x64, 0x8a, 0x93, 0x5f, 0x84, 0x6d, 0x71, 0x5a, 0xbf, 0xa7, 0xc1, 0x9a, 0x94, 0xda, 0x96, 0x98,
	0xea, 0x57, 0xa0, 0x87, 0x57, 0x09, 0x93, 0x03, 0xfe, 0x42, 0x95, 0x98, 0x7d, 0x02, 0xb6, 0x2d,
	0x32, 0x67, 0x53, 0x2a, 0x1f, 0x13, 0xd3, 0x2d, 0x5e, 0x60, 0x2b, 0x9d, 0xeb, 0xd3, 0x03, 0x41,
	0x29, 0xfe, 0x67, 0x9d, 0xa5, 0x34, 0x21, 0x84, 0xda, 0x4c, 0x73, 0x5f, 0x11, 0x34, 0x76, 0x39,
	0xec, 0x6d, 0x06, 0x2a, 0xa1, 0xbc, 0x2a, 0x3d, 0xb0, 0x1c, 0xe5, 0x55, 0xcc, 0x3f, 0x89, 0xf0,
	0x42, 0x5d, 0xe6, 0x18, 0x74, 0x18, 0x00, 0x5f, 0xcb, 0xfa, 0x6d, 0x0d, 0xf4, 0x77, 0x13, 0x8f,
	0x24, 0x98, 0x99, 0x5e, 0x95, 0x2f, 0x58, 0xb6, 0x27, 0xb5, 0x79, 0x7b, 0x82, 0x09, 0x90, 0x8e,
	0x2f, 0x0f, 0x82, 0x78, 0xc1, 0xb8, 0xa9, 0x68, 0xbd, 0x6a, 0x18, 0x0b, 0x4f, 0x49, 0x95, 0xf8,
	0x97, 0xab, 0xbd, 0x00, 0x98, 0x23, 0x18, 0x14, 0x67, 0xc6, 0x5c, 0xfa, 0x5b, 0x75, 0x42, 0xe3,
	0x75, 0x68, 0xc5, 0x4c, 0xff, 0xe4, 0x4c, 0x53, 0x52, 0xed, 0x54, 0xf5, 0xb4, 0x04, 0x96, 0xf9,
	0xf7, 0x35, 0xd8, 0x98, 0x7b, 0xad, 0xa2, 0xa0, 0x21, 0xda, 0x21, 0x1a, 0x52, 0x9b, 0xd3, 0x10,
	0xa6, 0x89, 0xe2, 0xc1, 0x0c, 0x3b, 0x76, 0x0e, 0x82, 0xc8, 0x91, 0xce, 0xc9, 0x40, 0x80, 0x77,
	0x39, 0xd4, 0x78, 0x11, 0x8c, 0x92, 0x85, 0xc8, 0x0d, 0xd7, 0x7a, 0xd1, 0x12, 0xec, 0x78, 0xc6,
	0xab, 0x00, 0x11, 0x93, 0x19, 0xbf, 0x63, 0x30, 0x97, 0xa0, 0x9a, 0xc9, 0xd3, 0xd2, 0xa3, 0x4c,
	0xb4, 0x6f, 0xc2, 0x59, 0x4a, 0x02, 0x32, 0x4e, 0x9c, 0xa9, 0x7c, 0xae, 0xc3, 0x76, 0x27, 0x4e,
	0xc2, 0x4d, 0x24, 0x57, 0x8b, 0xd3, 0x12, 0x43, 0x0c, 0x7f, 0x1b, 0xeb, 0x77, 0x3c, 0xd6, 0x38,
	0x4e, 0x22, 0xb6, 0x1d, 0x48, 0x2a, 0x1a, 0x73, 0xd7, 0xfd, 0xb4, 0xc4, 0x28, 0x35, 0x36, 0xff,
	0x48, 0x83, 0x7e, 0xd1, 0x96, 0x1e, 0x27, 0x81, 0x71, 0x65, 0x56, 0x3e, 0x19, 0xb5, 0xfb, 0xd5,
	0x1a, 0xac, 0xcf, 0x99, 0xd0, 0xe3, 0xd0, 0xad, 0x6a, 0x50, 0xfd, 0x10, 0x0d, 0x6a, 0xac, 0xa4,
	0x41, 0xcd, 0x23, 0x68, 0x50, 0x6b, 0x25, 0x0d, 0x6a, 0xaf, 0xa2, 0x41, 0xe6, 0x57, 0x35, 0xe8,
	0xa9, 0x6f, 0xab, 0x18, 0x9f, 0x16, 0x57, 0xfc, 0xf8, 0xbd, 0x56, 0x33, 0x6f, 0x7e, 0x2b, 0x74,
	0x93, 0x83, 0x98, 0x12, 0x4f, 0xa2, 0xdf, 0x0a, 0x08, 0x3e, 0xfe, 0xc2, 0xaf, 0x01, 0xfe, 0x24,
	0x74, 0xdd, 0x84, 0x78, 0x24, 0xa4, 0xbe, 0x13, 0xa4, 0x82, 0x7b, 0x17, 0x2b, 0x9a, 0x6f, 0xe7,
	0x58, 0x96, 0xda, 0xc4, 0x74, 0x72, 0x4a, 0x9e, 0xc0, 0x85, 0x6b, 0xe5, 0xf2, 0x1d, 0x56, 0xde,
	0x74, 0x28, 0x31, 0x7f, 0xb3, 0x0e, 0xc3, 0x45, 0xe3, 0xa8, 0xdc, 0x96, 0xc8, 0x0b, 0x8f, 0x35,
	0xe5, 0xc2, 0xe3, 0x0a, 0x27, 0x07, 0x99, 0xed, 0x6c, 0xa8, 0xb6, 0xf3, 0x45, 0x68, 0x32, 0x4a,
	0x64, 0x0e, 0x75, 0xc5, 0xeb, 0x36, 0x6c, 0xdc, 0x16, 0x47, 0x32, 0x5e, 0x07, 0x18, 0x25, 0x51,
	0x48, 0xed, 0xd4, 0x17, 0x26, 0x7e, 0x71, 0x13, 0x1d, 0x31, 0xf7, 0x7c, 0x8f, 0x18, 0x9f, 0x61,
	0x7b, 0x9b, 0x87, 0x84, 0x79, 0xfc, 0xd8, 0xb0, 0xbd, 0xb4, 0x61, 0x57, 0xe0, 0x62, 0xd3, 0xeb,
	0xd0, 0x4a, 0x49, 0x30, 0xf2, 0xc9, 0x7c, 0xea, 0x7a, 0xa1, 0x91, 0xc0, 0x32, 0xde, 0x80, 0x2e,
	0x4d, 0x9c, 0x30, 0x0d, 0x1c, 0x91, 0xce, 0xb4, 0x6c, 0x54, 0x2a, 0x2a, 0x63, 0xeb, 0xc4, 0x49,
	0x27, 0x22, 0xc9, 0x09, 0xff, 0x9b, 0x9f, 0x87, 0xcd, 0x2a, 0x1d, 0xc9, 0x44, 0xa0, 0x29, 0x22,
	0x90, 0xed, 0x6b, 0x79, 0x7b, 0xbc, 0x8e, 0x49, 0xdc, 0x84, 0x50, 0x99, 0xce, 0xc7, 0x4b, 0xe6,
	0x29, 0xd8, 0x2c, 0x49, 0x1a, 0x1f, 0xd6, 0x34, 0x7f, 0x4f, 0x83, 0x0b, 0x55, 0x15, 0x6c, 0x16,
	0xdc, 0xf6, 0x49, 0x80, 0x8f, 0x66, 0xa4, 0xd1, 0x2c, 0x71, 0xa5, 0x4a, 0x88, 0x52, 0xe5, 0x9b,
	0x93, 0xe8, 0x7d, 0x93, 0xc0, 0x2b, 0xbd, 0x8e, 0x49, 0x02, 0x4f, 0x7a, 0xdf, 0x8c, 0x70, 0x1b,
	0xa9, 0x16, 0x5e, 0x09, 0x03, 0xdc, 0x61, 0x94, 0x0f, 0xf3, 0x3b, 0xbd, 0x62, 0xff, 0x2f, 0x8a,
	0xe6, 0x97, 0x17, 0xd0, 0x78, 0x3b, 0x13, 0xf7, 0x51, 0x68, 0x94, 0x53, 0x03, 0x89, 0x50, 0xde,
	0x22, 0x28, 0x13, 0xd1, 0x28, 0x12, 0xf1, 0x0b, 0x1a, 0x5c, 0xaa, 0x22, 0xc2, 0x52, 0x54, 0xe7,
	0x43, 0x20, 0xe3, 0x4b, 0x70, 0xb6, 0x8a, 0x8a, 0x3d, 0xae, 0x8b, 0x1f, 0x02, 0x01, 0x3f, 0x07,
	0xc3, 0x4a, 0x59, 0x30, 0x5b, 0xf5, 0x21, 0x7c, 0xfe, 0xcb, 0x1a, 0x9c, 0x59, 0xf4, 0xfd, 0xf4,
	0x48, 0x04, 0x5c, 0x82, 0x6e, 0x46, 0x80, 0x70, 0xa5, 0x74, 0x0b, 0x24, 0x09, 0x24, 0x5d, 0x42,
	0xc4, 0x57, 0x35, 0x78, 0xba, 0x8a, 0x88, 0x7b, 0xf9, 0xe4, 0xfe, 0xb0, 0xf8, 0xf1, 0x35, 0x0d,
	0x9e, 0x59, 0x81, 0x94, 0x0f, 0x8d, 0x35, 0xbf, 0xb2, 0x60, 0x9a, 0xdc, 0x0f, 0xd3, 0x98, 0xb8,
	0xfe, 0xc8, 0x27, 0x47, 0xb3, 0x28, 0x57, 0xa0, 0x47, 0x78, 0x37, 0x2a, 0x67, 0xba, 0x02, 0x76,
	0x08, 0x73, 0xfe, 0x43, 0x83, 0xc6, 0x5b, 0x85, 0x8b, 0x41, 0x47, 0xdc, 0x6e, 0x65, 0x8f, 0x40,
	0xd6, 0x0f, 0x7d, 0x04, 0x52, 0x5e, 0x16, 0x6b, 0x28, 0x97, 0xc5, 0x3e, 0x0b, 0x7d, 0xf6, 0x9b,
	0x3f, 0x99, 0xd9, 0x5c, 0xfe, 0x64, 0x66, 0x8f, 0x61, 0x67, 0xef, 0x65, 0x16, 0x1e, 0xb6, 0x6c,
	0xad, 0xf2, 0xb0, 0xa5, 0x39, 0x80, 0x9e, 0xfa, 0x48, 0x84, 0x49, 0xa0, 0xcf, 0x7e, 0xef, 0xf8,
	0xe3, 0xc9, 0x9e, 0x1b, 0x25, 0x78, 0x07, 0x30, 0xbb, 0xa7, 0x23, 0x1e, 0x25, 0x97, 0xe5, 0xec,
	0xb6, 0x7f, 0x6d, 0xc9, 0x6d, 0x7f, 0xbc, 0x7c, 0x14, 0x25, 0xd2, 0xa7, 0xe0, 0x05, 0xf3, 0xfb,
	0x35, 0xe8, 0x5a, 0x4a, 0x58, 0xf0, 0x5e, 0xf5, 0xc3, 0x21, 0xe2, 0x1d, 0x81, 0x43, 0x22, 0x8c,
	0x77, 0x9e, 0xb2, 0xaa, 0x9f, 0x1d, 0x79, 0xaf, 0xf2, 0x99, 0x18, 0x41, 0xae, 0x12, 0x6a, 0xac,
	0x40, 0xba, 0xf3, 0x94, 0x55, 0xf9, 0xc4, 0xcc, 0x7b, 0x95, 0xef, 0xa7, 0x88, 0x70, 0xcc, 0xa2,
	0x2e, 0x39, 0xd2, 0x5c, 0x97, 0xe2, 0xed, 0x95, 0x4f, 0xab, 0x0f, 0x3c, 0x08, 0xef, 0x5c, 0x79,
	0xdb, 0x27, 0xaf, 0xbb, 0xf3, 0x94, 0xa5, 0x60, 0xde, 0xe8, 0x17, 0x58, 0x68, 0xfe, 0x7a, 0x1d,
	0x20, 0xbf, 0x5c, 0xc9, 0x08, 0xad, 0xb8, 0x22, 0x2b, 0x18, 0x3a, 0x1f, 0x66, 0x55, 0x91, 0x18,
	0xa1, 0x55, 0xd7, 0x6b, 0xdf, 0xa9, 0xba, 0xbd, 0x29, 0xb8, 0x79, 0xbe, 0xaa, 0x47, 0x89, 0x73,
	0xe7, 0x29, 0xab, 0xea, 0xde, 0xe7, 0xad, 0xb9, 0xab, 0xae, 0x82, 0x8f, 0x67, 0x2a, 0xc9, 0x63,
	0x08, 0x77, 0x9e, 0xb2, 0xe6, 0xae, 0xc7, 0xde, 0x9a, 0xbb, 0x89, 0x3d, 0xbf, 0xc5, 0x29, 0x21,
	0x14, 0xbb, 0xe1, 0x29, 0x0a, 0xb7, 0xe6, 0x6e, 0x56, 0x8b, 0xcd, 0x64, 0x65, 0x37, 0x88, 0x50,
	0xec, 0x06, 0x41, 0x37, 0x7a, 0xaa, 0x14, 0x6e, 0xf4, 0xfe, 0xfc, 0x07, 0x17, 0xb5, 0xef, 0xff,
	0xe0, 0xa2, 0xf6, 0xcf, 0x3f, 0xb8, 0xa8, 0xed, 0xb7, 0xb0, 0x97, 0x4f, 0xfd, 0x77, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xf2, 0xd7, 0x11, 0x3a, 0x0f, 0x60, 0x00, 0x00,
}
