// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: available_methods.method.proto

/*
	Package botproto is a generated protocol buffer package.

	It is generated from these files:
		available_methods.method.proto
		games.method.proto
		getting_updates.method.proto
		payments.method.proto
		stickers.method.proto
		telegram_passport.method.proto
		tgbotapi.proto
		updating_messages.method.proto

	It has these top-level messages:
		GetMe
		SendMessage
		ForwardMessage
		SendPhoto
		SendAudio
		SendDocument
		SendVideo
		SendAnimation
		SendVoice
		SendVideoNote
		SendMediaGroup
		SendLocation
		EditMessageLiveLocation
		StopMessageLiveLocation
		SendVenue
		SendContact
		SendPoll
		SendChatAction
		GetUserProfilePhotos
		GetFile
		KickChatMember
		UnbanChatMember
		RestrictChatMember
		PromoteChatMember
		SetChatPermissions
		ExportChatInviteLink
		SetChatPhoto
		DeleteChatPhoto
		SetChatTitle
		SetChatDescription
		PinChatMessage
		UnpinChatMessage
		LeaveChat
		GetChat
		GetChatAdministrators
		GetChatMembersCount
		GetChatMember
		SetChatStickerSet
		DeleteChatStickerSet
		SendGame
		SetGameScore
		GetGameHighScores
		GetUpdates
		SetWebhook
		DeleteWebhook
		GetWebhookInfo
		SendInvoice
		SendSticker
		GetStickerSet
		UploadStickerFile
		CreateNewStickerSet
		SetStickerPositionInSet
		DeleteStickerFromSet
		SetPassportDataErrors
		Update
		WebhookInfo
		User
		Chat
		Message
		MessageEntity
		PhotoSize
		Audio
		Document
		Video
		Animation
		Voice
		VideoNote
		Contact
		Location
		Venue
		PollOption
		Poll
		UserProfilePhotos
		File
		ReplyKeyboardMarkup
		KeyboardButton
		ReplyKeyboardRemove
		InlineKeyboardMarkup
		InlineKeyboardButton
		LoginUrl
		CallbackQuery
		ForceReply
		ChatPhoto
		ChatMember
		ChatPermissions
		ResponseParameters
		InputMediaPhoto
		InputMediaVideo
		InputMediaAnimation
		InputMediaAudio
		InputMediaDocument
		InputFile
		AnswerCallbackQuery
		Sticker
		StickerSet
		MaskPosition
		AddStickerToSet
		InlineQuery
		AnswerInlineQuery
		InlineQueryResult
		InlineQueryResultArticle
		InlineQueryResultPhoto
		InlineQueryResultGif
		InlineQueryResultMpeg4Gif
		InlineQueryResultVideo
		InlineQueryResultAudio
		InlineQueryResultVoice
		InlineQueryResultDocument
		InlineQueryResultLocation
		InlineQueryResultVenue
		InlineQueryResultContact
		InlineQueryResultGame
		InlineQueryResultCachedPhoto
		InlineQueryResultCachedGif
		InlineQueryResultCachedMpeg4Gif
		InlineQueryResultCachedSticker
		InlineQueryResultCachedDocument
		InlineQueryResultCachedVideo
		InlineQueryResultCachedVoice
		InlineQueryResultCachedAudio
		InputMessageContent
		InputTextMessageContent
		InputLocationMessageContent
		InputVenueMessageContent
		InputContactMessageContent
		ChosenInlineResult
		AnswerShippingQuery
		AnswerPreCheckoutQuery
		LabeledPrice
		Invoice
		ShippingAddress
		OrderInfo
		ShippingOption
		SuccessfulPayment
		ShippingQuery
		PreCheckoutQuery
		PassportData
		PassportFile
		EncryptedPassportElement
		EncryptedCredentials
		PassportElementError
		PassportElementErrorDataField
		PassportElementErrorFrontSide
		PassportElementErrorReverseSide
		PassportElementErrorSelfie
		PassportElementErrorFile
		PassportElementErrorFiles
		PassportElementErrorTranslationFile
		PassportElementErrorTranslationFiles
		PassportElementErrorUnspecified
		Game
		CallbackGame
		GameHighScore
		ReplyMarkup
		InputMedia
		EditMessageText
		EditMessageCaption
		EditMessageMedia
		EditMessageReplyMarkup
		StopPoll
		DeleteMessage
*/
package botproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// return User
// A simple method for testing your bot's auth token. Requires no parameters. Returns basic information about the bot in form of a User object.
type GetMe struct {
}

func (m *GetMe) Reset()                    { *m = GetMe{} }
func (m *GetMe) String() string            { return proto.CompactTextString(m) }
func (*GetMe) ProtoMessage()               {}
func (*GetMe) Descriptor() ([]byte, []int) { return fileDescriptorAvailableMethodsMethod, []int{0} }

// return Message
// Use this method to send text messages. On success, the sent Message is returned.
// The Bot API supports basic formatting for messages. You can use bold and italic text, as well as inline links and pre-formatted code in your bots' messages. Telegram clients will render them accordingly. You can use either markdown-style or HTML-style formatting.
// Note that Telegram clients will display an alert to the user before opening an inline link (‘Open this link?’ together with the full URL).
// Links tg://user?id=<user_id> can be used to mention a user by their id without using a username. Please note:
// To use this mode, pass Markdown in the parse_mode field when using sendMessage. Use the following syntax in your message:
// To use this mode, pass HTML in the parse_mode field when using sendMessage. The following tags are currently supported:
// Please note:
type SendMessage struct {
	ChatId                string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Text                  string       `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	ParseMode             string       `protobuf:"bytes,3,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	DisableWebPagePreview bool         `protobuf:"varint,4,opt,name=disable_web_page_preview,json=disableWebPagePreview,proto3" json:"disable_web_page_preview,omitempty"`
	DisableNotification   bool         `protobuf:"varint,5,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId      int32        `protobuf:"varint,6,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup           *ReplyMarkup `protobuf:"bytes,7,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendMessage) Reset()         { *m = SendMessage{} }
func (m *SendMessage) String() string { return proto.CompactTextString(m) }
func (*SendMessage) ProtoMessage()    {}
func (*SendMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{1}
}

func (m *SendMessage) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendMessage) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *SendMessage) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *SendMessage) GetDisableWebPagePreview() bool {
	if m != nil {
		return m.DisableWebPagePreview
	}
	return false
}

func (m *SendMessage) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendMessage) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendMessage) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return Message
// Use this method to forward messages of any kind. On success, the sent Message is returned.
type ForwardMessage struct {
	ChatId              string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	FromChatId          string `protobuf:"bytes,2,opt,name=from_chat_id,json=fromChatId,proto3" json:"from_chat_id,omitempty"`
	DisableNotification bool   `protobuf:"varint,3,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	MessageId           int32  `protobuf:"varint,4,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *ForwardMessage) Reset()         { *m = ForwardMessage{} }
func (m *ForwardMessage) String() string { return proto.CompactTextString(m) }
func (*ForwardMessage) ProtoMessage()    {}
func (*ForwardMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{2}
}

func (m *ForwardMessage) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *ForwardMessage) GetFromChatId() string {
	if m != nil {
		return m.FromChatId
	}
	return ""
}

func (m *ForwardMessage) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *ForwardMessage) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// return Message
// Use this method to send photos. On success, the sent Message is returned.
type SendPhoto struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Photo               string       `protobuf:"bytes,2,opt,name=photo,proto3" json:"photo,omitempty"`
	Caption             string       `protobuf:"bytes,3,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string       `protobuf:"bytes,4,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	DisableNotification bool         `protobuf:"varint,5,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,6,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,7,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendPhoto) Reset()                    { *m = SendPhoto{} }
func (m *SendPhoto) String() string            { return proto.CompactTextString(m) }
func (*SendPhoto) ProtoMessage()               {}
func (*SendPhoto) Descriptor() ([]byte, []int) { return fileDescriptorAvailableMethodsMethod, []int{3} }

func (m *SendPhoto) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendPhoto) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

func (m *SendPhoto) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *SendPhoto) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *SendPhoto) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendPhoto) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendPhoto) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return Message
// Use this method to send audio files, if you want Telegram clients to display them in the music player. Your audio must be in the .mp3 format. On success, the sent Message is returned. Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the future.
// For sending voice messages, use the sendVoice method instead.
type SendAudio struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Audio               string       `protobuf:"bytes,2,opt,name=audio,proto3" json:"audio,omitempty"`
	Caption             string       `protobuf:"bytes,3,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string       `protobuf:"bytes,4,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	Duration            int32        `protobuf:"varint,5,opt,name=duration,proto3" json:"duration,omitempty"`
	Performer           string       `protobuf:"bytes,6,opt,name=performer,proto3" json:"performer,omitempty"`
	Title               string       `protobuf:"bytes,7,opt,name=title,proto3" json:"title,omitempty"`
	Thumb               string       `protobuf:"bytes,8,opt,name=thumb,proto3" json:"thumb,omitempty"`
	DisableNotification bool         `protobuf:"varint,9,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,10,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,11,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendAudio) Reset()                    { *m = SendAudio{} }
func (m *SendAudio) String() string            { return proto.CompactTextString(m) }
func (*SendAudio) ProtoMessage()               {}
func (*SendAudio) Descriptor() ([]byte, []int) { return fileDescriptorAvailableMethodsMethod, []int{4} }

func (m *SendAudio) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendAudio) GetAudio() string {
	if m != nil {
		return m.Audio
	}
	return ""
}

func (m *SendAudio) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *SendAudio) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *SendAudio) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *SendAudio) GetPerformer() string {
	if m != nil {
		return m.Performer
	}
	return ""
}

func (m *SendAudio) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SendAudio) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *SendAudio) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendAudio) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendAudio) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return Message
// Use this method to send general files. On success, the sent Message is returned. Bots can currently send files of any type of up to 50 MB in size, this limit may be changed in the future.
type SendDocument struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Document            string       `protobuf:"bytes,2,opt,name=document,proto3" json:"document,omitempty"`
	Thumb               string       `protobuf:"bytes,3,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption             string       `protobuf:"bytes,4,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string       `protobuf:"bytes,5,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	DisableNotification bool         `protobuf:"varint,6,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,7,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,8,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendDocument) Reset()         { *m = SendDocument{} }
func (m *SendDocument) String() string { return proto.CompactTextString(m) }
func (*SendDocument) ProtoMessage()    {}
func (*SendDocument) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{5}
}

func (m *SendDocument) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendDocument) GetDocument() string {
	if m != nil {
		return m.Document
	}
	return ""
}

func (m *SendDocument) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *SendDocument) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *SendDocument) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *SendDocument) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendDocument) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendDocument) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return Message
// Use this method to send video files, Telegram clients support mp4 videos (other formats may be sent as Document). On success, the sent Message is returned. Bots can currently send video files of up to 50 MB in size, this limit may be changed in the future.
type SendVideo struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Video               string       `protobuf:"bytes,2,opt,name=video,proto3" json:"video,omitempty"`
	Duration            int32        `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
	Width               int32        `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Height              int32        `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
	Thumb               string       `protobuf:"bytes,6,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption             string       `protobuf:"bytes,7,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string       `protobuf:"bytes,8,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	SupportsStreaming   bool         `protobuf:"varint,9,opt,name=supports_streaming,json=supportsStreaming,proto3" json:"supports_streaming,omitempty"`
	DisableNotification bool         `protobuf:"varint,10,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,11,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,12,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendVideo) Reset()                    { *m = SendVideo{} }
func (m *SendVideo) String() string            { return proto.CompactTextString(m) }
func (*SendVideo) ProtoMessage()               {}
func (*SendVideo) Descriptor() ([]byte, []int) { return fileDescriptorAvailableMethodsMethod, []int{6} }

func (m *SendVideo) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendVideo) GetVideo() string {
	if m != nil {
		return m.Video
	}
	return ""
}

func (m *SendVideo) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *SendVideo) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *SendVideo) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SendVideo) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *SendVideo) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *SendVideo) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *SendVideo) GetSupportsStreaming() bool {
	if m != nil {
		return m.SupportsStreaming
	}
	return false
}

func (m *SendVideo) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendVideo) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendVideo) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return Message
// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success, the sent Message is returned. Bots can currently send animation files of up to 50 MB in size, this limit may be changed in the future.
type SendAnimation struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Animation           string       `protobuf:"bytes,2,opt,name=animation,proto3" json:"animation,omitempty"`
	Duration            int32        `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
	Width               int32        `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Height              int32        `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
	Thumb               string       `protobuf:"bytes,6,opt,name=thumb,proto3" json:"thumb,omitempty"`
	Caption             string       `protobuf:"bytes,7,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string       `protobuf:"bytes,8,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	DisableNotification bool         `protobuf:"varint,9,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,10,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,11,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendAnimation) Reset()         { *m = SendAnimation{} }
func (m *SendAnimation) String() string { return proto.CompactTextString(m) }
func (*SendAnimation) ProtoMessage()    {}
func (*SendAnimation) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{7}
}

func (m *SendAnimation) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendAnimation) GetAnimation() string {
	if m != nil {
		return m.Animation
	}
	return ""
}

func (m *SendAnimation) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *SendAnimation) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *SendAnimation) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SendAnimation) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *SendAnimation) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *SendAnimation) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *SendAnimation) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendAnimation) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendAnimation) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return Message
// Use this method to send audio files, if you want Telegram clients to display the file as a playable voice message. For this to work, your audio must be in an .ogg file encoded with OPUS (other formats may be sent as Audio or Document). On success, the sent Message is returned. Bots can currently send voice messages of up to 50 MB in size, this limit may be changed in the future.
type SendVoice struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Voice               string       `protobuf:"bytes,2,opt,name=voice,proto3" json:"voice,omitempty"`
	Caption             string       `protobuf:"bytes,3,opt,name=caption,proto3" json:"caption,omitempty"`
	ParseMode           string       `protobuf:"bytes,4,opt,name=parse_mode,json=parseMode,proto3" json:"parse_mode,omitempty"`
	Duration            int32        `protobuf:"varint,5,opt,name=duration,proto3" json:"duration,omitempty"`
	DisableNotification bool         `protobuf:"varint,6,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,7,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,8,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendVoice) Reset()                    { *m = SendVoice{} }
func (m *SendVoice) String() string            { return proto.CompactTextString(m) }
func (*SendVoice) ProtoMessage()               {}
func (*SendVoice) Descriptor() ([]byte, []int) { return fileDescriptorAvailableMethodsMethod, []int{8} }

func (m *SendVoice) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendVoice) GetVoice() string {
	if m != nil {
		return m.Voice
	}
	return ""
}

func (m *SendVoice) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *SendVoice) GetParseMode() string {
	if m != nil {
		return m.ParseMode
	}
	return ""
}

func (m *SendVoice) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *SendVoice) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendVoice) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendVoice) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return Message
// As of v.4.0, Telegram clients support rounded square mp4 videos of up to 1 minute long. Use this method to send video messages. On success, the sent Message is returned.
type SendVideoNote struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	VideoNote           string       `protobuf:"bytes,2,opt,name=video_note,json=videoNote,proto3" json:"video_note,omitempty"`
	Duration            int32        `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
	Length              int32        `protobuf:"varint,4,opt,name=length,proto3" json:"length,omitempty"`
	Thumb               string       `protobuf:"bytes,5,opt,name=thumb,proto3" json:"thumb,omitempty"`
	DisableNotification bool         `protobuf:"varint,6,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,7,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,8,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendVideoNote) Reset()         { *m = SendVideoNote{} }
func (m *SendVideoNote) String() string { return proto.CompactTextString(m) }
func (*SendVideoNote) ProtoMessage()    {}
func (*SendVideoNote) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{9}
}

func (m *SendVideoNote) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendVideoNote) GetVideoNote() string {
	if m != nil {
		return m.VideoNote
	}
	return ""
}

func (m *SendVideoNote) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *SendVideoNote) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *SendVideoNote) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *SendVideoNote) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendVideoNote) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendVideoNote) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return array of the sent Messages
// Use this method to send a group of photos or videos as an album. On success, an array of the sent Messages is returned.
type SendMediaGroup struct {
	ChatId              string        `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Media               []*InputMedia `protobuf:"bytes,2,rep,name=media" json:"media,omitempty"`
	DisableNotification bool          `protobuf:"varint,3,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32         `protobuf:"varint,4,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
}

func (m *SendMediaGroup) Reset()         { *m = SendMediaGroup{} }
func (m *SendMediaGroup) String() string { return proto.CompactTextString(m) }
func (*SendMediaGroup) ProtoMessage()    {}
func (*SendMediaGroup) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{10}
}

func (m *SendMediaGroup) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendMediaGroup) GetMedia() []*InputMedia {
	if m != nil {
		return m.Media
	}
	return nil
}

func (m *SendMediaGroup) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendMediaGroup) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

// return Message
// Use this method to send point on the map. On success, the sent Message is returned.
type SendLocation struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Latitude            int64        `protobuf:"varint,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude           int64        `protobuf:"varint,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	LivePeriod          int32        `protobuf:"varint,4,opt,name=live_period,json=livePeriod,proto3" json:"live_period,omitempty"`
	DisableNotification bool         `protobuf:"varint,5,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,6,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,7,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendLocation) Reset()         { *m = SendLocation{} }
func (m *SendLocation) String() string { return proto.CompactTextString(m) }
func (*SendLocation) ProtoMessage()    {}
func (*SendLocation) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{11}
}

func (m *SendLocation) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendLocation) GetLatitude() int64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *SendLocation) GetLongitude() int64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *SendLocation) GetLivePeriod() int32 {
	if m != nil {
		return m.LivePeriod
	}
	return 0
}

func (m *SendLocation) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendLocation) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendLocation) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return
// Use this method to edit live location messages. A location can be edited until its live_period expires or editing is explicitly disabled by a call to stopMessageLiveLocation. On success, if the edited message was sent by the bot, the edited Message is returned, otherwise True is returned.
type EditMessageLiveLocation struct {
	ChatId          string                `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId       int32                 `protobuf:"varint,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	InlineMessageId string                `protobuf:"bytes,3,opt,name=inline_message_id,json=inlineMessageId,proto3" json:"inline_message_id,omitempty"`
	Latitude        int64                 `protobuf:"varint,4,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude       int64                 `protobuf:"varint,5,opt,name=longitude,proto3" json:"longitude,omitempty"`
	ReplyMarkup     *InlineKeyboardMarkup `protobuf:"bytes,6,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *EditMessageLiveLocation) Reset()         { *m = EditMessageLiveLocation{} }
func (m *EditMessageLiveLocation) String() string { return proto.CompactTextString(m) }
func (*EditMessageLiveLocation) ProtoMessage()    {}
func (*EditMessageLiveLocation) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{12}
}

func (m *EditMessageLiveLocation) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *EditMessageLiveLocation) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *EditMessageLiveLocation) GetInlineMessageId() string {
	if m != nil {
		return m.InlineMessageId
	}
	return ""
}

func (m *EditMessageLiveLocation) GetLatitude() int64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *EditMessageLiveLocation) GetLongitude() int64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *EditMessageLiveLocation) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return
// Use this method to stop updating a live location message before live_period expires. On success, if the message was sent by the bot, the sent Message is returned, otherwise True is returned.
type StopMessageLiveLocation struct {
	ChatId          string                `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId       int32                 `protobuf:"varint,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	InlineMessageId string                `protobuf:"bytes,3,opt,name=inline_message_id,json=inlineMessageId,proto3" json:"inline_message_id,omitempty"`
	ReplyMarkup     *InlineKeyboardMarkup `protobuf:"bytes,4,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *StopMessageLiveLocation) Reset()         { *m = StopMessageLiveLocation{} }
func (m *StopMessageLiveLocation) String() string { return proto.CompactTextString(m) }
func (*StopMessageLiveLocation) ProtoMessage()    {}
func (*StopMessageLiveLocation) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{13}
}

func (m *StopMessageLiveLocation) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *StopMessageLiveLocation) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *StopMessageLiveLocation) GetInlineMessageId() string {
	if m != nil {
		return m.InlineMessageId
	}
	return ""
}

func (m *StopMessageLiveLocation) GetReplyMarkup() *InlineKeyboardMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return Message
// Use this method to send information about a venue. On success, the sent Message is returned.
type SendVenue struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Latitude            int64        `protobuf:"varint,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude           int64        `protobuf:"varint,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Title               string       `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	Address             string       `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
	FoursquareId        string       `protobuf:"bytes,6,opt,name=foursquare_id,json=foursquareId,proto3" json:"foursquare_id,omitempty"`
	FoursquareType      string       `protobuf:"bytes,7,opt,name=foursquare_type,json=foursquareType,proto3" json:"foursquare_type,omitempty"`
	DisableNotification bool         `protobuf:"varint,8,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,9,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,10,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendVenue) Reset()                    { *m = SendVenue{} }
func (m *SendVenue) String() string            { return proto.CompactTextString(m) }
func (*SendVenue) ProtoMessage()               {}
func (*SendVenue) Descriptor() ([]byte, []int) { return fileDescriptorAvailableMethodsMethod, []int{14} }

func (m *SendVenue) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendVenue) GetLatitude() int64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *SendVenue) GetLongitude() int64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *SendVenue) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SendVenue) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *SendVenue) GetFoursquareId() string {
	if m != nil {
		return m.FoursquareId
	}
	return ""
}

func (m *SendVenue) GetFoursquareType() string {
	if m != nil {
		return m.FoursquareType
	}
	return ""
}

func (m *SendVenue) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendVenue) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendVenue) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return Message
// Use this method to send phone contacts. On success, the sent Message is returned.
type SendContact struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	PhoneNumber         string       `protobuf:"bytes,2,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	FirstName           string       `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName            string       `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	Vcard               string       `protobuf:"bytes,5,opt,name=vcard,proto3" json:"vcard,omitempty"`
	DisableNotification bool         `protobuf:"varint,6,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,7,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,8,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendContact) Reset()         { *m = SendContact{} }
func (m *SendContact) String() string { return proto.CompactTextString(m) }
func (*SendContact) ProtoMessage()    {}
func (*SendContact) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{15}
}

func (m *SendContact) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendContact) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SendContact) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *SendContact) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *SendContact) GetVcard() string {
	if m != nil {
		return m.Vcard
	}
	return ""
}

func (m *SendContact) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendContact) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendContact) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return Message
// Use this method to send a native poll. A native poll can't be sent to a private chat. On success, the sent Message is returned.
type SendPoll struct {
	ChatId              string       `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Question            string       `protobuf:"bytes,2,opt,name=question,proto3" json:"question,omitempty"`
	Options             []string     `protobuf:"bytes,3,rep,name=options" json:"options,omitempty"`
	DisableNotification bool         `protobuf:"varint,4,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
	ReplyToMessageId    int32        `protobuf:"varint,5,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
	ReplyMarkup         *ReplyMarkup `protobuf:"bytes,6,opt,name=reply_markup,json=replyMarkup" json:"reply_markup,omitempty"`
}

func (m *SendPoll) Reset()                    { *m = SendPoll{} }
func (m *SendPoll) String() string            { return proto.CompactTextString(m) }
func (*SendPoll) ProtoMessage()               {}
func (*SendPoll) Descriptor() ([]byte, []int) { return fileDescriptorAvailableMethodsMethod, []int{16} }

func (m *SendPoll) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendPoll) GetQuestion() string {
	if m != nil {
		return m.Question
	}
	return ""
}

func (m *SendPoll) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *SendPoll) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

func (m *SendPoll) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

func (m *SendPoll) GetReplyMarkup() *ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

// return True
// Use this method when you need to tell the user that something is happening on the bot's side. The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients clear its typing status). Returns True on success.
// Example: The ImageBot needs some time to process a request and upload the image. Instead of sending a text message along the lines of “Retrieving image, please wait…”, the bot may use sendChatAction with action = upload_photo. The user will see a “sending photo” status for the bot.
//
// We only recommend using this method when a response from the bot will take a noticeable amount of time to arrive.
type SendChatAction struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Action string `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
}

func (m *SendChatAction) Reset()         { *m = SendChatAction{} }
func (m *SendChatAction) String() string { return proto.CompactTextString(m) }
func (*SendChatAction) ProtoMessage()    {}
func (*SendChatAction) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{17}
}

func (m *SendChatAction) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SendChatAction) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

// return
// Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos object.
type GetUserProfilePhotos struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Offset int32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit  int32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *GetUserProfilePhotos) Reset()         { *m = GetUserProfilePhotos{} }
func (m *GetUserProfilePhotos) String() string { return proto.CompactTextString(m) }
func (*GetUserProfilePhotos) ProtoMessage()    {}
func (*GetUserProfilePhotos) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{18}
}

func (m *GetUserProfilePhotos) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetUserProfilePhotos) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *GetUserProfilePhotos) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// return
// Use this method to get basic info about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>, where <file_path> is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile again.
// Note: This function may not preserve the original file name and MIME type. You should save the file's MIME type and name (if available) when the File object is received.
type GetFile struct {
	FileId string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
}

func (m *GetFile) Reset()                    { *m = GetFile{} }
func (m *GetFile) String() string            { return proto.CompactTextString(m) }
func (*GetFile) ProtoMessage()               {}
func (*GetFile) Descriptor() ([]byte, []int) { return fileDescriptorAvailableMethodsMethod, []int{19} }

func (m *GetFile) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

// return True
// Use this method to kick a user from a group, a supergroup or a channel. In the case of supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Returns True on success.
// Note: In regular groups (non-supergroups), this method will only work if the ‘All Members Are Admins’ setting is off in the target group. Otherwise members may only be removed by the group's creator or by the member that added them.
//
type KickChatMember struct {
	ChatId    string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId    int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	UntilDate int32  `protobuf:"varint,3,opt,name=until_date,json=untilDate,proto3" json:"until_date,omitempty"`
}

func (m *KickChatMember) Reset()         { *m = KickChatMember{} }
func (m *KickChatMember) String() string { return proto.CompactTextString(m) }
func (*KickChatMember) ProtoMessage()    {}
func (*KickChatMember) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{20}
}

func (m *KickChatMember) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *KickChatMember) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *KickChatMember) GetUntilDate() int32 {
	if m != nil {
		return m.UntilDate
	}
	return 0
}

// return True
// Use this method to unban a previously kicked user in a supergroup or channel. The user will not return to the group or channel automatically, but will be able to join via link, etc. The bot must be an administrator for this to work. Returns True on success.
type UnbanChatMember struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *UnbanChatMember) Reset()         { *m = UnbanChatMember{} }
func (m *UnbanChatMember) String() string { return proto.CompactTextString(m) }
func (*UnbanChatMember) ProtoMessage()    {}
func (*UnbanChatMember) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{21}
}

func (m *UnbanChatMember) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *UnbanChatMember) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// return True
// Use this method to restrict a user in a supergroup. The bot must be an administrator in the supergroup for this to work and must have the appropriate admin rights. Pass True for all permissions to lift restrictions from a user. Returns True on success.
type RestrictChatMember struct {
	ChatId      string           `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId      int32            `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Permissions *ChatPermissions `protobuf:"bytes,3,opt,name=permissions" json:"permissions,omitempty"`
	UntilDate   int32            `protobuf:"varint,4,opt,name=until_date,json=untilDate,proto3" json:"until_date,omitempty"`
}

func (m *RestrictChatMember) Reset()         { *m = RestrictChatMember{} }
func (m *RestrictChatMember) String() string { return proto.CompactTextString(m) }
func (*RestrictChatMember) ProtoMessage()    {}
func (*RestrictChatMember) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{22}
}

func (m *RestrictChatMember) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *RestrictChatMember) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *RestrictChatMember) GetPermissions() *ChatPermissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *RestrictChatMember) GetUntilDate() int32 {
	if m != nil {
		return m.UntilDate
	}
	return 0
}

// return True
// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Pass False for all boolean parameters to demote a user. Returns True on success.
type PromoteChatMember struct {
	ChatId             string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId             int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	CanChangeInfo      bool   `protobuf:"varint,3,opt,name=can_change_info,json=canChangeInfo,proto3" json:"can_change_info,omitempty"`
	CanPostMessages    bool   `protobuf:"varint,4,opt,name=can_post_messages,json=canPostMessages,proto3" json:"can_post_messages,omitempty"`
	CanEditMessages    bool   `protobuf:"varint,5,opt,name=can_edit_messages,json=canEditMessages,proto3" json:"can_edit_messages,omitempty"`
	CanDeleteMessages  bool   `protobuf:"varint,6,opt,name=can_delete_messages,json=canDeleteMessages,proto3" json:"can_delete_messages,omitempty"`
	CanInviteUsers     bool   `protobuf:"varint,7,opt,name=can_invite_users,json=canInviteUsers,proto3" json:"can_invite_users,omitempty"`
	CanRestrictMembers bool   `protobuf:"varint,8,opt,name=can_restrict_members,json=canRestrictMembers,proto3" json:"can_restrict_members,omitempty"`
	CanPinMessages     bool   `protobuf:"varint,9,opt,name=can_pin_messages,json=canPinMessages,proto3" json:"can_pin_messages,omitempty"`
	CanPromoteMembers  bool   `protobuf:"varint,10,opt,name=can_promote_members,json=canPromoteMembers,proto3" json:"can_promote_members,omitempty"`
}

func (m *PromoteChatMember) Reset()         { *m = PromoteChatMember{} }
func (m *PromoteChatMember) String() string { return proto.CompactTextString(m) }
func (*PromoteChatMember) ProtoMessage()    {}
func (*PromoteChatMember) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{23}
}

func (m *PromoteChatMember) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *PromoteChatMember) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *PromoteChatMember) GetCanChangeInfo() bool {
	if m != nil {
		return m.CanChangeInfo
	}
	return false
}

func (m *PromoteChatMember) GetCanPostMessages() bool {
	if m != nil {
		return m.CanPostMessages
	}
	return false
}

func (m *PromoteChatMember) GetCanEditMessages() bool {
	if m != nil {
		return m.CanEditMessages
	}
	return false
}

func (m *PromoteChatMember) GetCanDeleteMessages() bool {
	if m != nil {
		return m.CanDeleteMessages
	}
	return false
}

func (m *PromoteChatMember) GetCanInviteUsers() bool {
	if m != nil {
		return m.CanInviteUsers
	}
	return false
}

func (m *PromoteChatMember) GetCanRestrictMembers() bool {
	if m != nil {
		return m.CanRestrictMembers
	}
	return false
}

func (m *PromoteChatMember) GetCanPinMessages() bool {
	if m != nil {
		return m.CanPinMessages
	}
	return false
}

func (m *PromoteChatMember) GetCanPromoteMembers() bool {
	if m != nil {
		return m.CanPromoteMembers
	}
	return false
}

// return True
// Use this method to set default chat permissions for all members. The bot must be an administrator in the group or a supergroup for this to work and must have the can_restrict_members admin rights. Returns True on success.
type SetChatPermissions struct {
	ChatId      string           `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Permissions *ChatPermissions `protobuf:"bytes,2,opt,name=permissions" json:"permissions,omitempty"`
}

func (m *SetChatPermissions) Reset()         { *m = SetChatPermissions{} }
func (m *SetChatPermissions) String() string { return proto.CompactTextString(m) }
func (*SetChatPermissions) ProtoMessage()    {}
func (*SetChatPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{24}
}

func (m *SetChatPermissions) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SetChatPermissions) GetPermissions() *ChatPermissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

// return String
// Use this method to generate a new invite link for a chat; any previously generated link is revoked. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Returns the new invite link as String on success.
// Note: Each administrator in a chat generates their own invite links. Bots can't use invite links generated by other administrators. If you want your bot to work with invite links, it will need to generate its own link using exportChatInviteLink – after this the link will become available to the bot via the getChat method. If your bot needs to generate a new invite link replacing its previous one, use exportChatInviteLink again.
//
type ExportChatInviteLink struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *ExportChatInviteLink) Reset()         { *m = ExportChatInviteLink{} }
func (m *ExportChatInviteLink) String() string { return proto.CompactTextString(m) }
func (*ExportChatInviteLink) ProtoMessage()    {}
func (*ExportChatInviteLink) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{25}
}

func (m *ExportChatInviteLink) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

// return True
// Use this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Returns True on success.
// Note: In regular groups (non-supergroups), this method will only work if the ‘All Members Are Admins’ setting is off in the target group.
//
type SetChatPhoto struct {
	ChatId string     `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Photo  *InputFile `protobuf:"bytes,2,opt,name=photo" json:"photo,omitempty"`
}

func (m *SetChatPhoto) Reset()         { *m = SetChatPhoto{} }
func (m *SetChatPhoto) String() string { return proto.CompactTextString(m) }
func (*SetChatPhoto) ProtoMessage()    {}
func (*SetChatPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{26}
}

func (m *SetChatPhoto) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SetChatPhoto) GetPhoto() *InputFile {
	if m != nil {
		return m.Photo
	}
	return nil
}

// return True
// Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Returns True on success.
// Note: In regular groups (non-supergroups), this method will only work if the ‘All Members Are Admins’ setting is off in the target group.
//
type DeleteChatPhoto struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *DeleteChatPhoto) Reset()         { *m = DeleteChatPhoto{} }
func (m *DeleteChatPhoto) String() string { return proto.CompactTextString(m) }
func (*DeleteChatPhoto) ProtoMessage()    {}
func (*DeleteChatPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{27}
}

func (m *DeleteChatPhoto) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

// return True
// Use this method to change the title of a chat. Titles can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Returns True on success.
// Note: In regular groups (non-supergroups), this method will only work if the ‘All Members Are Admins’ setting is off in the target group.
//
type SetChatTitle struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Title  string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
}

func (m *SetChatTitle) Reset()         { *m = SetChatTitle{} }
func (m *SetChatTitle) String() string { return proto.CompactTextString(m) }
func (*SetChatTitle) ProtoMessage()    {}
func (*SetChatTitle) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{28}
}

func (m *SetChatTitle) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SetChatTitle) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

// return True
// Use this method to change the description of a group, a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Returns True on success.
type SetChatDescription struct {
	ChatId      string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *SetChatDescription) Reset()         { *m = SetChatDescription{} }
func (m *SetChatDescription) String() string { return proto.CompactTextString(m) }
func (*SetChatDescription) ProtoMessage()    {}
func (*SetChatDescription) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{29}
}

func (m *SetChatDescription) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SetChatDescription) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// return True
// Use this method to pin a message in a group, a supergroup, or a channel. The bot must be an administrator in the chat for this to work and must have the ‘can_pin_messages’ admin right in the supergroup or ‘can_edit_messages’ admin right in the channel. Returns True on success.
type PinChatMessage struct {
	ChatId              string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MessageId           int32  `protobuf:"varint,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	DisableNotification bool   `protobuf:"varint,3,opt,name=disable_notification,json=disableNotification,proto3" json:"disable_notification,omitempty"`
}

func (m *PinChatMessage) Reset()         { *m = PinChatMessage{} }
func (m *PinChatMessage) String() string { return proto.CompactTextString(m) }
func (*PinChatMessage) ProtoMessage()    {}
func (*PinChatMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{30}
}

func (m *PinChatMessage) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *PinChatMessage) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *PinChatMessage) GetDisableNotification() bool {
	if m != nil {
		return m.DisableNotification
	}
	return false
}

// return True
// Use this method to unpin a message in a group, a supergroup, or a channel. The bot must be an administrator in the chat for this to work and must have the ‘can_pin_messages’ admin right in the supergroup or ‘can_edit_messages’ admin right in the channel. Returns True on success.
type UnpinChatMessage struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *UnpinChatMessage) Reset()         { *m = UnpinChatMessage{} }
func (m *UnpinChatMessage) String() string { return proto.CompactTextString(m) }
func (*UnpinChatMessage) ProtoMessage()    {}
func (*UnpinChatMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{31}
}

func (m *UnpinChatMessage) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

// return True
// Use this method for your bot to leave a group, supergroup or channel. Returns True on success.
type LeaveChat struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *LeaveChat) Reset()                    { *m = LeaveChat{} }
func (m *LeaveChat) String() string            { return proto.CompactTextString(m) }
func (*LeaveChat) ProtoMessage()               {}
func (*LeaveChat) Descriptor() ([]byte, []int) { return fileDescriptorAvailableMethodsMethod, []int{32} }

func (m *LeaveChat) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

// return Chat
// Use this method to get up to date information about the chat (current name of the user for one-on-one conversations, current username of a user, group or channel, etc.). Returns a Chat object on success.
type GetChat struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *GetChat) Reset()                    { *m = GetChat{} }
func (m *GetChat) String() string            { return proto.CompactTextString(m) }
func (*GetChat) ProtoMessage()               {}
func (*GetChat) Descriptor() ([]byte, []int) { return fileDescriptorAvailableMethodsMethod, []int{33} }

func (m *GetChat) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

// return Array of ChatMember
// Use this method to get a list of administrators in a chat. On success, returns an Array of ChatMember objects that contains information about all chat administrators except other bots. If the chat is a group or a supergroup and no administrators were appointed, only the creator will be returned.
type GetChatAdministrators struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *GetChatAdministrators) Reset()         { *m = GetChatAdministrators{} }
func (m *GetChatAdministrators) String() string { return proto.CompactTextString(m) }
func (*GetChatAdministrators) ProtoMessage()    {}
func (*GetChatAdministrators) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{34}
}

func (m *GetChatAdministrators) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

// return Int
// Use this method to get the number of members in a chat. Returns Int on success.
type GetChatMembersCount struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *GetChatMembersCount) Reset()         { *m = GetChatMembersCount{} }
func (m *GetChatMembersCount) String() string { return proto.CompactTextString(m) }
func (*GetChatMembersCount) ProtoMessage()    {}
func (*GetChatMembersCount) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{35}
}

func (m *GetChatMembersCount) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

// return ChatMember
// Use this method to get information about a member of a chat. Returns a ChatMember object on success.
type GetChatMember struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *GetChatMember) Reset()         { *m = GetChatMember{} }
func (m *GetChatMember) String() string { return proto.CompactTextString(m) }
func (*GetChatMember) ProtoMessage()    {}
func (*GetChatMember) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{36}
}

func (m *GetChatMember) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *GetChatMember) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// return True
// Use this method to set a new group sticker set for a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Use the field can_set_sticker_set optionally returned in getChat requests to check if the bot can use this method. Returns True on success.
type SetChatStickerSet struct {
	ChatId         string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	StickerSetName string `protobuf:"bytes,2,opt,name=sticker_set_name,json=stickerSetName,proto3" json:"sticker_set_name,omitempty"`
}

func (m *SetChatStickerSet) Reset()         { *m = SetChatStickerSet{} }
func (m *SetChatStickerSet) String() string { return proto.CompactTextString(m) }
func (*SetChatStickerSet) ProtoMessage()    {}
func (*SetChatStickerSet) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{37}
}

func (m *SetChatStickerSet) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func (m *SetChatStickerSet) GetStickerSetName() string {
	if m != nil {
		return m.StickerSetName
	}
	return ""
}

// return True
// Use this method to delete a group sticker set from a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate admin rights. Use the field can_set_sticker_set optionally returned in getChat requests to check if the bot can use this method. Returns True on success.
type DeleteChatStickerSet struct {
	ChatId string `protobuf:"bytes,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *DeleteChatStickerSet) Reset()         { *m = DeleteChatStickerSet{} }
func (m *DeleteChatStickerSet) String() string { return proto.CompactTextString(m) }
func (*DeleteChatStickerSet) ProtoMessage()    {}
func (*DeleteChatStickerSet) Descriptor() ([]byte, []int) {
	return fileDescriptorAvailableMethodsMethod, []int{38}
}

func (m *DeleteChatStickerSet) GetChatId() string {
	if m != nil {
		return m.ChatId
	}
	return ""
}

func init() {
	proto.RegisterType((*GetMe)(nil), "botproto.getMe")
	proto.RegisterType((*SendMessage)(nil), "botproto.sendMessage")
	proto.RegisterType((*ForwardMessage)(nil), "botproto.forwardMessage")
	proto.RegisterType((*SendPhoto)(nil), "botproto.sendPhoto")
	proto.RegisterType((*SendAudio)(nil), "botproto.sendAudio")
	proto.RegisterType((*SendDocument)(nil), "botproto.sendDocument")
	proto.RegisterType((*SendVideo)(nil), "botproto.sendVideo")
	proto.RegisterType((*SendAnimation)(nil), "botproto.sendAnimation")
	proto.RegisterType((*SendVoice)(nil), "botproto.sendVoice")
	proto.RegisterType((*SendVideoNote)(nil), "botproto.sendVideoNote")
	proto.RegisterType((*SendMediaGroup)(nil), "botproto.sendMediaGroup")
	proto.RegisterType((*SendLocation)(nil), "botproto.sendLocation")
	proto.RegisterType((*EditMessageLiveLocation)(nil), "botproto.editMessageLiveLocation")
	proto.RegisterType((*StopMessageLiveLocation)(nil), "botproto.stopMessageLiveLocation")
	proto.RegisterType((*SendVenue)(nil), "botproto.sendVenue")
	proto.RegisterType((*SendContact)(nil), "botproto.sendContact")
	proto.RegisterType((*SendPoll)(nil), "botproto.sendPoll")
	proto.RegisterType((*SendChatAction)(nil), "botproto.sendChatAction")
	proto.RegisterType((*GetUserProfilePhotos)(nil), "botproto.getUserProfilePhotos")
	proto.RegisterType((*GetFile)(nil), "botproto.getFile")
	proto.RegisterType((*KickChatMember)(nil), "botproto.kickChatMember")
	proto.RegisterType((*UnbanChatMember)(nil), "botproto.unbanChatMember")
	proto.RegisterType((*RestrictChatMember)(nil), "botproto.restrictChatMember")
	proto.RegisterType((*PromoteChatMember)(nil), "botproto.promoteChatMember")
	proto.RegisterType((*SetChatPermissions)(nil), "botproto.setChatPermissions")
	proto.RegisterType((*ExportChatInviteLink)(nil), "botproto.exportChatInviteLink")
	proto.RegisterType((*SetChatPhoto)(nil), "botproto.setChatPhoto")
	proto.RegisterType((*DeleteChatPhoto)(nil), "botproto.deleteChatPhoto")
	proto.RegisterType((*SetChatTitle)(nil), "botproto.setChatTitle")
	proto.RegisterType((*SetChatDescription)(nil), "botproto.setChatDescription")
	proto.RegisterType((*PinChatMessage)(nil), "botproto.pinChatMessage")
	proto.RegisterType((*UnpinChatMessage)(nil), "botproto.unpinChatMessage")
	proto.RegisterType((*LeaveChat)(nil), "botproto.leaveChat")
	proto.RegisterType((*GetChat)(nil), "botproto.getChat")
	proto.RegisterType((*GetChatAdministrators)(nil), "botproto.getChatAdministrators")
	proto.RegisterType((*GetChatMembersCount)(nil), "botproto.getChatMembersCount")
	proto.RegisterType((*GetChatMember)(nil), "botproto.getChatMember")
	proto.RegisterType((*SetChatStickerSet)(nil), "botproto.setChatStickerSet")
	proto.RegisterType((*DeleteChatStickerSet)(nil), "botproto.deleteChatStickerSet")
}
func (m *GetMe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SendMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.DisableWebPagePreview {
		dAtA[i] = 0x20
		i++
		if m.DisableWebPagePreview {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableNotification {
		dAtA[i] = 0x28
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n1, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ForwardMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.FromChatId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.FromChatId)))
		i += copy(dAtA[i:], m.FromChatId)
	}
	if m.DisableNotification {
		dAtA[i] = 0x18
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *SendPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.DisableNotification {
		dAtA[i] = 0x28
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n2, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *SendAudio) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendAudio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Audio) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Audio)))
		i += copy(dAtA[i:], m.Audio)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Duration))
	}
	if len(m.Performer) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Performer)))
		i += copy(dAtA[i:], m.Performer)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if m.DisableNotification {
		dAtA[i] = 0x48
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n3, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *SendDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Document) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Document)))
		i += copy(dAtA[i:], m.Document)
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.DisableNotification {
		dAtA[i] = 0x30
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n4, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *SendVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendVideo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Video) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Video)))
		i += copy(dAtA[i:], m.Video)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Duration))
	}
	if m.Width != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Height))
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.SupportsStreaming {
		dAtA[i] = 0x48
		i++
		if m.SupportsStreaming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableNotification {
		dAtA[i] = 0x50
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n5, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *SendAnimation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendAnimation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Animation) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Animation)))
		i += copy(dAtA[i:], m.Animation)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Duration))
	}
	if m.Width != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Height))
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.DisableNotification {
		dAtA[i] = 0x48
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n6, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *SendVoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendVoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Voice) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Voice)))
		i += copy(dAtA[i:], m.Voice)
	}
	if len(m.Caption) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Caption)))
		i += copy(dAtA[i:], m.Caption)
	}
	if len(m.ParseMode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ParseMode)))
		i += copy(dAtA[i:], m.ParseMode)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Duration))
	}
	if m.DisableNotification {
		dAtA[i] = 0x30
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n7, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *SendVideoNote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendVideoNote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.VideoNote) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.VideoNote)))
		i += copy(dAtA[i:], m.VideoNote)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Duration))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Length))
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if m.DisableNotification {
		dAtA[i] = 0x30
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n8, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *SendMediaGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMediaGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Media) > 0 {
		for _, msg := range m.Media {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DisableNotification {
		dAtA[i] = 0x18
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	return i, nil
}

func (m *SendLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Longitude))
	}
	if m.LivePeriod != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.LivePeriod))
	}
	if m.DisableNotification {
		dAtA[i] = 0x28
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n9, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *EditMessageLiveLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditMessageLiveLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.MessageId))
	}
	if len(m.InlineMessageId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.InlineMessageId)))
		i += copy(dAtA[i:], m.InlineMessageId)
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Longitude))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n10, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *StopMessageLiveLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopMessageLiveLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.MessageId))
	}
	if len(m.InlineMessageId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.InlineMessageId)))
		i += copy(dAtA[i:], m.InlineMessageId)
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n11, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *SendVenue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendVenue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Longitude))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.FoursquareId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.FoursquareId)))
		i += copy(dAtA[i:], m.FoursquareId)
	}
	if len(m.FoursquareType) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.FoursquareType)))
		i += copy(dAtA[i:], m.FoursquareType)
	}
	if m.DisableNotification {
		dAtA[i] = 0x40
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n12, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *SendContact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendContact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if len(m.Vcard) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Vcard)))
		i += copy(dAtA[i:], m.Vcard)
	}
	if m.DisableNotification {
		dAtA[i] = 0x30
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n13, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *SendPoll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPoll) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Question) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Question)))
		i += copy(dAtA[i:], m.Question)
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DisableNotification {
		dAtA[i] = 0x20
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplyToMessageId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.ReplyMarkup.Size()))
		n14, err := m.ReplyMarkup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *SendChatAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendChatAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	return i, nil
}

func (m *GetUserProfilePhotos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserProfilePhotos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.UserId))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Offset))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *GetFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.FileId)))
		i += copy(dAtA[i:], m.FileId)
	}
	return i, nil
}

func (m *KickChatMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KickChatMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.UserId))
	}
	if m.UntilDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.UntilDate))
	}
	return i, nil
}

func (m *UnbanChatMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbanChatMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *RestrictChatMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestrictChatMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.UserId))
	}
	if m.Permissions != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Permissions.Size()))
		n15, err := m.Permissions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.UntilDate != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.UntilDate))
	}
	return i, nil
}

func (m *PromoteChatMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PromoteChatMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.UserId))
	}
	if m.CanChangeInfo {
		dAtA[i] = 0x18
		i++
		if m.CanChangeInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPostMessages {
		dAtA[i] = 0x20
		i++
		if m.CanPostMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanEditMessages {
		dAtA[i] = 0x28
		i++
		if m.CanEditMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanDeleteMessages {
		dAtA[i] = 0x30
		i++
		if m.CanDeleteMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanInviteUsers {
		dAtA[i] = 0x38
		i++
		if m.CanInviteUsers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanRestrictMembers {
		dAtA[i] = 0x40
		i++
		if m.CanRestrictMembers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPinMessages {
		dAtA[i] = 0x48
		i++
		if m.CanPinMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CanPromoteMembers {
		dAtA[i] = 0x50
		i++
		if m.CanPromoteMembers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SetChatPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetChatPermissions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.Permissions != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Permissions.Size()))
		n16, err := m.Permissions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *ExportChatInviteLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportChatInviteLink) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	return i, nil
}

func (m *SetChatPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetChatPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.Photo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.Photo.Size()))
		n17, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *DeleteChatPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChatPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	return i, nil
}

func (m *SetChatTitle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetChatTitle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	return i, nil
}

func (m *SetChatDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetChatDescription) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func (m *PinChatMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinChatMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.MessageId))
	}
	if m.DisableNotification {
		dAtA[i] = 0x18
		i++
		if m.DisableNotification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UnpinChatMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnpinChatMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	return i, nil
}

func (m *LeaveChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaveChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	return i, nil
}

func (m *GetChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	return i, nil
}

func (m *GetChatAdministrators) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChatAdministrators) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	return i, nil
}

func (m *GetChatMembersCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChatMembersCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	return i, nil
}

func (m *GetChatMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChatMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SetChatStickerSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetChatStickerSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	if len(m.StickerSetName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.StickerSetName)))
		i += copy(dAtA[i:], m.StickerSetName)
	}
	return i, nil
}

func (m *DeleteChatStickerSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChatStickerSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAvailableMethodsMethod(dAtA, i, uint64(len(m.ChatId)))
		i += copy(dAtA[i:], m.ChatId)
	}
	return i, nil
}

func encodeFixed64AvailableMethodsMethod(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32AvailableMethodsMethod(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAvailableMethodsMethod(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetMe) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SendMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.DisableWebPagePreview {
		n += 2
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *ForwardMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.FromChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.MessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.MessageId))
	}
	return n
}

func (m *SendPhoto) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendAudio) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Audio)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Duration))
	}
	l = len(m.Performer)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendDocument) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Document)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendVideo) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Video)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Duration))
	}
	if m.Width != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Height))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.SupportsStreaming {
		n += 2
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendAnimation) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Animation)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Duration))
	}
	if m.Width != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Height))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendVoice) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Voice)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Caption)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.ParseMode)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Duration))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendVideoNote) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.VideoNote)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Duration))
	}
	if m.Length != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Length))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendMediaGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if len(m.Media) > 0 {
		for _, e := range m.Media {
			l = e.Size()
			n += 1 + l + sovAvailableMethodsMethod(uint64(l))
		}
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	return n
}

func (m *SendLocation) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.Latitude != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Longitude))
	}
	if m.LivePeriod != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.LivePeriod))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *EditMessageLiveLocation) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.MessageId))
	}
	l = len(m.InlineMessageId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.Latitude != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Longitude))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *StopMessageLiveLocation) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.MessageId))
	}
	l = len(m.InlineMessageId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendVenue) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.Latitude != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Latitude))
	}
	if m.Longitude != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Longitude))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.FoursquareId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.FoursquareType)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendContact) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Vcard)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendPoll) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Question)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 1 + l + sovAvailableMethodsMethod(uint64(l))
		}
	}
	if m.DisableNotification {
		n += 2
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.ReplyToMessageId))
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SendChatAction) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *GetUserProfilePhotos) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.UserId))
	}
	if m.Offset != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.Limit))
	}
	return n
}

func (m *GetFile) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *KickChatMember) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.UserId))
	}
	if m.UntilDate != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.UntilDate))
	}
	return n
}

func (m *UnbanChatMember) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.UserId))
	}
	return n
}

func (m *RestrictChatMember) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.UserId))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.UntilDate != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.UntilDate))
	}
	return n
}

func (m *PromoteChatMember) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.UserId))
	}
	if m.CanChangeInfo {
		n += 2
	}
	if m.CanPostMessages {
		n += 2
	}
	if m.CanEditMessages {
		n += 2
	}
	if m.CanDeleteMessages {
		n += 2
	}
	if m.CanInviteUsers {
		n += 2
	}
	if m.CanRestrictMembers {
		n += 2
	}
	if m.CanPinMessages {
		n += 2
	}
	if m.CanPromoteMembers {
		n += 2
	}
	return n
}

func (m *SetChatPermissions) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *ExportChatInviteLink) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SetChatPhoto) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *DeleteChatPhoto) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SetChatTitle) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *SetChatDescription) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *PinChatMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.MessageId))
	}
	if m.DisableNotification {
		n += 2
	}
	return n
}

func (m *UnpinChatMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *LeaveChat) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *GetChat) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *GetChatAdministrators) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *GetChatMembersCount) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *GetChatMember) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovAvailableMethodsMethod(uint64(m.UserId))
	}
	return n
}

func (m *SetChatStickerSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	l = len(m.StickerSetName)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func (m *DeleteChatStickerSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatId)
	if l > 0 {
		n += 1 + l + sovAvailableMethodsMethod(uint64(l))
	}
	return n
}

func sovAvailableMethodsMethod(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAvailableMethodsMethod(x uint64) (n int) {
	return sovAvailableMethodsMethod(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetMe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getMe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getMe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableWebPagePreview", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableWebPagePreview = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: forwardMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: forwardMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendAudio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendAudio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendAudio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Performer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Performer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Video = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsStreaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsStreaming = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendAnimation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendAnimation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendAnimation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Animation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Animation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendVoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendVoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendVoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendVideoNote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendVideoNote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendVideoNote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoNote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoNote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMediaGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendMediaGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendMediaGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = append(m.Media, &InputMedia{})
			if err := m.Media[len(m.Media)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			m.Longitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivePeriod", wireType)
			}
			m.LivePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LivePeriod |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditMessageLiveLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: editMessageLiveLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: editMessageLiveLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			m.Longitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopMessageLiveLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: stopMessageLiveLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: stopMessageLiveLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &InlineKeyboardMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendVenue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendVenue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendVenue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			m.Longitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longitude |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoursquareId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoursquareId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoursquareType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoursquareType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendContact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendContact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendContact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vcard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPoll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendPoll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendPoll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Question", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Question = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendChatAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sendChatAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sendChatAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserProfilePhotos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getUserProfilePhotos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getUserProfilePhotos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KickChatMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: kickChatMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: kickChatMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UntilDate", wireType)
			}
			m.UntilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UntilDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbanChatMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: unbanChatMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: unbanChatMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestrictChatMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: restrictChatMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: restrictChatMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &ChatPermissions{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UntilDate", wireType)
			}
			m.UntilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UntilDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PromoteChatMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: promoteChatMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: promoteChatMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanChangeInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanChangeInfo = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPostMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPostMessages = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanEditMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanEditMessages = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeleteMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanDeleteMessages = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanInviteUsers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanInviteUsers = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanRestrictMembers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanRestrictMembers = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPinMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPinMessages = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPromoteMembers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanPromoteMembers = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChatPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: setChatPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: setChatPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &ChatPermissions{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportChatInviteLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: exportChatInviteLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: exportChatInviteLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChatPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: setChatPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: setChatPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &InputFile{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChatPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: deleteChatPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: deleteChatPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChatTitle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: setChatTitle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: setChatTitle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChatDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: setChatDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: setChatDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinChatMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: pinChatMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: pinChatMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNotification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableNotification = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnpinChatMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: unpinChatMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: unpinChatMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaveChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: leaveChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: leaveChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChatAdministrators) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getChatAdministrators: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getChatAdministrators: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChatMembersCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getChatMembersCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getChatMembersCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChatMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getChatMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getChatMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChatStickerSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: setChatStickerSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: setChatStickerSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerSetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StickerSetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChatStickerSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: deleteChatStickerSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: deleteChatStickerSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAvailableMethodsMethod(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAvailableMethodsMethod
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAvailableMethodsMethod(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAvailableMethodsMethod
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAvailableMethodsMethod
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAvailableMethodsMethod
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAvailableMethodsMethod
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAvailableMethodsMethod(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAvailableMethodsMethod = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAvailableMethodsMethod   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("available_methods.method.proto", fileDescriptorAvailableMethodsMethod)
}

var fileDescriptorAvailableMethodsMethod = []byte{
	// 1637 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4f, 0x6f, 0x1c, 0x49,
	0x15, 0xd7, 0xfc, 0xf5, 0xcc, 0x1b, 0xc7, 0x4e, 0xda, 0x4e, 0x32, 0x84, 0x8d, 0x31, 0x0d, 0x02,
	0x13, 0xb4, 0x66, 0x09, 0x07, 0x90, 0x10, 0x07, 0xe3, 0x00, 0xb2, 0x88, 0xc3, 0xa8, 0x13, 0xc2,
	0x09, 0xb5, 0x6a, 0xba, 0xdf, 0xcc, 0x14, 0xee, 0xae, 0xea, 0xad, 0xaa, 0x76, 0x36, 0xe2, 0x43,
	0xf0, 0x09, 0xd8, 0x03, 0xd7, 0x15, 0x7b, 0xe5, 0xca, 0x91, 0x23, 0x1f, 0x01, 0xe5, 0x3b, 0xac,
	0x84, 0xe0, 0x82, 0xea, 0x4f, 0xff, 0xc9, 0x68, 0xbb, 0x3d, 0x4e, 0xb4, 0xc2, 0x27, 0xfb, 0xfd,
	0xe9, 0xd7, 0xef, 0xfd, 0xde, 0xaf, 0x5f, 0xbd, 0x29, 0x38, 0x20, 0x97, 0x84, 0x26, 0x64, 0x9e,
	0x60, 0x98, 0xa2, 0x5a, 0xf1, 0x58, 0x1e, 0xdb, 0xbf, 0xc7, 0x99, 0xe0, 0x8a, 0x7b, 0xa3, 0x39,
	0x57, 0xe6, 0xbf, 0x07, 0x3b, 0x6a, 0x39, 0xe7, 0x8a, 0x64, 0xd4, 0x5a, 0xfc, 0x2d, 0x18, 0x2c,
	0x51, 0x9d, 0xa3, 0xff, 0x79, 0x17, 0x26, 0x12, 0x59, 0x7c, 0x8e, 0x52, 0x92, 0x25, 0x7a, 0xf7,
	0x61, 0x2b, 0x5a, 0x11, 0x15, 0xd2, 0x78, 0xda, 0x39, 0xec, 0x1c, 0x8d, 0x83, 0xa1, 0x16, 0xcf,
	0x62, 0xcf, 0x83, 0xbe, 0xc2, 0x4f, 0xd4, 0xb4, 0x6b, 0xb4, 0xe6, 0x7f, 0xef, 0x21, 0x40, 0x46,
	0x84, 0xc4, 0x30, 0xe5, 0x31, 0x4e, 0x7b, 0xc6, 0x32, 0x36, 0x9a, 0x73, 0x1e, 0xa3, 0xf7, 0x63,
	0x98, 0xc6, 0x54, 0x9a, 0xf4, 0x5e, 0xe1, 0x3c, 0xcc, 0xc8, 0x12, 0xc3, 0x4c, 0xe0, 0x25, 0xc5,
	0x57, 0xd3, 0xfe, 0x61, 0xe7, 0x68, 0x14, 0xdc, 0x75, 0xf6, 0xdf, 0xe1, 0x7c, 0x46, 0x96, 0x38,
	0xb3, 0x46, 0xef, 0x87, 0xb0, 0x5f, 0x3c, 0xc8, 0xb8, 0xa2, 0x0b, 0x1a, 0x11, 0x45, 0x39, 0x9b,
	0x0e, 0xcc, 0x43, 0x7b, 0xce, 0xf6, 0xac, 0x66, 0xf2, 0x3e, 0x84, 0x3d, 0x81, 0x59, 0xf2, 0x3a,
	0x54, 0x3c, 0x4c, 0x6d, 0x2d, 0xba, 0x86, 0xe1, 0x61, 0xe7, 0x68, 0x10, 0xdc, 0x36, 0xa6, 0x17,
	0xdc, 0x15, 0x79, 0x16, 0x7b, 0x3f, 0x81, 0x6d, 0xeb, 0x9e, 0x12, 0x71, 0x91, 0x67, 0xd3, 0xad,
	0xc3, 0xce, 0xd1, 0xe4, 0xf1, 0xdd, 0xe3, 0x02, 0xb0, 0xe3, 0x40, 0x5b, 0xcf, 0x8d, 0x31, 0x98,
	0x88, 0x4a, 0xf0, 0xff, 0xdc, 0x81, 0x9d, 0x05, 0x17, 0xaf, 0x88, 0xb8, 0x1a, 0xb3, 0x43, 0xd8,
	0x5e, 0x08, 0x9e, 0x86, 0x85, 0xd5, 0x62, 0x07, 0x5a, 0x77, 0x6a, 0x3d, 0x9a, 0x2a, 0xed, 0x35,
	0x57, 0xfa, 0x10, 0xa0, 0x56, 0x60, 0xdf, 0x14, 0x38, 0x4e, 0x8b, 0xca, 0xfc, 0x3f, 0x75, 0x61,
	0xac, 0x1b, 0x3a, 0x5b, 0x69, 0x06, 0x34, 0xa6, 0xb6, 0x0f, 0x83, 0x4c, 0x7b, 0xb8, 0x9c, 0xac,
	0xe0, 0x4d, 0x61, 0x2b, 0x22, 0x59, 0x99, 0xc1, 0x38, 0x28, 0xc4, 0xb5, 0x56, 0xf7, 0xd7, 0x5b,
	0x7d, 0x93, 0x3b, 0xf6, 0x85, 0x43, 0xe4, 0x24, 0x8f, 0x69, 0x3b, 0x22, 0x44, 0x7b, 0x14, 0x88,
	0x18, 0xe1, 0xdd, 0x11, 0x79, 0x00, 0xa3, 0x38, 0x17, 0x15, 0x0a, 0x83, 0xa0, 0x94, 0xbd, 0x0f,
	0x60, 0x9c, 0xa1, 0x58, 0x70, 0x91, 0xa2, 0x30, 0x05, 0xeb, 0x27, 0x0b, 0x85, 0x4e, 0x44, 0x51,
	0x95, 0xa0, 0x29, 0x71, 0x1c, 0x58, 0xc1, 0x68, 0x57, 0x79, 0x3a, 0x9f, 0x8e, 0x9c, 0x56, 0x0b,
	0x8d, 0xb8, 0x8f, 0xaf, 0x8d, 0x3b, 0x6c, 0x88, 0xfb, 0x64, 0x63, 0xdc, 0x3f, 0xef, 0xc2, 0xb6,
	0xc6, 0xfd, 0x09, 0x8f, 0xf2, 0x14, 0x99, 0x6a, 0x86, 0x5e, 0x63, 0xe5, 0x9c, 0x1c, 0xfa, 0xa5,
	0x5c, 0xd5, 0xdd, 0xab, 0xd7, 0x5d, 0x6b, 0x4b, 0xbf, 0xad, 0x2d, 0x83, 0x4d, 0x89, 0x3a, 0xbc,
	0x36, 0x60, 0x5b, 0x1b, 0x02, 0x36, 0xda, 0x18, 0xb0, 0x4f, 0x7b, 0x96, 0xa8, 0x2f, 0x69, 0x8c,
	0xed, 0x44, 0xbd, 0xd4, 0x1e, 0x05, 0x51, 0x8d, 0xf0, 0x16, 0xdf, 0x7a, 0x6b, 0x7c, 0xdb, 0x87,
	0xc1, 0x2b, 0x1a, 0xab, 0x95, 0x9b, 0x16, 0x56, 0xf0, 0xee, 0xc1, 0x70, 0x85, 0x74, 0xb9, 0x52,
	0x8e, 0x9f, 0x4e, 0xaa, 0x10, 0x1f, 0x36, 0x20, 0xbe, 0xd5, 0x86, 0xf8, 0x68, 0x1d, 0xf1, 0x0f,
	0xc1, 0x93, 0x79, 0x96, 0x71, 0xa1, 0x64, 0x28, 0x95, 0x40, 0x92, 0x52, 0xb6, 0x74, 0x04, 0xbd,
	0x53, 0x58, 0x9e, 0x17, 0x86, 0xc6, 0x06, 0xc1, 0xb5, 0x1b, 0x34, 0xd9, 0xb0, 0x41, 0xdb, 0x1b,
	0x37, 0xe8, 0xbf, 0x5d, 0xb8, 0x65, 0x26, 0x09, 0xa3, 0xa9, 0x7d, 0x75, 0x63, 0x93, 0x3e, 0x80,
	0x31, 0x29, 0xbc, 0x5c, 0xa3, 0x2a, 0xc5, 0xcd, 0x6d, 0xd6, 0x4d, 0x9e, 0x27, 0x9f, 0xb9, 0x39,
	0xfe, 0x92, 0xd3, 0x08, 0xdb, 0x3f, 0x0f, 0xed, 0x51, 0x7e, 0x1e, 0xc6, 0xfd, 0x2b, 0x99, 0xe3,
	0x37, 0x79, 0x98, 0xfc, 0xd5, 0x71, 0xd5, 0x0c, 0x93, 0x67, 0x5c, 0xb5, 0x20, 0xf6, 0x10, 0xc0,
	0xcc, 0x10, 0x5d, 0x44, 0x01, 0xdb, 0xf8, 0xb2, 0x7c, 0xae, 0x8d, 0xac, 0xf7, 0x60, 0x98, 0x20,
	0x5b, 0x96, 0x6c, 0x75, 0x52, 0x45, 0xcb, 0xc1, 0x26, 0xa7, 0xd5, 0x4d, 0xc0, 0xeb, 0x6f, 0x1d,
	0xd8, 0xb1, 0x8b, 0x70, 0x4c, 0xc9, 0xaf, 0x04, 0xcf, 0xb3, 0x66, 0xc0, 0x1e, 0xc1, 0x20, 0xd5,
	0x6e, 0xd3, 0xee, 0x61, 0xef, 0x68, 0xf2, 0x78, 0xbf, 0x0a, 0x7f, 0xc6, 0xb2, 0x5c, 0x99, 0x10,
	0x81, 0x75, 0x79, 0x97, 0x0d, 0xaf, 0xa1, 0xe6, 0xfe, 0x97, 0xd7, 0xec, 0x7f, 0xea, 0xce, 0xd9,
	0xa7, 0x3c, 0xba, 0x62, 0x28, 0x3d, 0x80, 0x51, 0x42, 0x14, 0x55, 0x79, 0x6c, 0xdb, 0xdc, 0x0b,
	0x4a, 0x59, 0x0f, 0xac, 0x84, 0xb3, 0xa5, 0x35, 0xf6, 0x8c, 0xb1, 0x52, 0x78, 0xdf, 0x80, 0x49,
	0x42, 0x2f, 0x31, 0xcc, 0x50, 0x50, 0x5e, 0xa4, 0x02, 0x5a, 0x35, 0x33, 0x9a, 0x1b, 0xbd, 0x00,
	0xfe, 0xa7, 0x03, 0xf7, 0x31, 0xa6, 0xca, 0xc5, 0x7a, 0x4a, 0x2f, 0xf1, 0x6a, 0xac, 0xde, 0x5e,
	0xb3, 0xbb, 0x6b, 0x6b, 0xb6, 0xf7, 0x08, 0xee, 0x50, 0x96, 0x50, 0x86, 0xf5, 0xd4, 0xed, 0x64,
	0xd9, 0xb5, 0x86, 0x2a, 0xf3, 0x3a, 0xec, 0xfd, 0x36, 0xd8, 0x07, 0xeb, 0xb0, 0x9f, 0xac, 0xd5,
	0x3c, 0x34, 0x35, 0x1f, 0xd4, 0xf9, 0xa6, 0x5f, 0xf5, 0x6b, 0x7c, 0x3d, 0xe7, 0xfa, 0x07, 0xc9,
	0x97, 0x14, 0xff, 0xf7, 0x0e, 0xdc, 0x97, 0x8a, 0x67, 0xff, 0xaf, 0xe2, 0xd7, 0x4b, 0xe8, 0x5f,
	0xbf, 0x84, 0x7f, 0x17, 0x83, 0x1f, 0x59, 0x8e, 0x5f, 0x05, 0xbb, 0xcb, 0x8d, 0xbb, 0x5f, 0xdf,
	0xb8, 0xa7, 0xb0, 0x45, 0xe2, 0x58, 0xa0, 0x94, 0x6e, 0x8a, 0x15, 0xa2, 0xf7, 0x2d, 0xb8, 0xb5,
	0xe0, 0xb9, 0x90, 0x1f, 0xe7, 0x44, 0x94, 0x9c, 0x1d, 0x07, 0xdb, 0x95, 0xf2, 0x2c, 0xf6, 0xbe,
	0x0b, 0xbb, 0x35, 0x27, 0xf5, 0x3a, 0x2b, 0x16, 0xfa, 0x9d, 0x4a, 0xfd, 0xe2, 0x75, 0xd6, 0x7c,
	0xe6, 0x8e, 0xae, 0xfd, 0xe9, 0x8c, 0x37, 0xfc, 0x74, 0x60, 0xf3, 0xa9, 0xe8, 0xae, 0x07, 0x4e,
	0x39, 0x53, 0x24, 0x6a, 0x59, 0xe1, 0xbf, 0x09, 0xdb, 0xd9, 0x8a, 0x33, 0x0c, 0x59, 0x9e, 0xce,
	0x51, 0xb8, 0x53, 0x64, 0x62, 0x74, 0xcf, 0x8c, 0x4a, 0x93, 0x6a, 0x41, 0x85, 0x54, 0x21, 0x23,
	0x69, 0x79, 0x5b, 0x60, 0x34, 0xcf, 0x48, 0x8a, 0xde, 0xd7, 0x61, 0x9c, 0x90, 0xc2, 0x6a, 0x1b,
	0x31, 0xd2, 0x0a, 0x63, 0xd4, 0x87, 0x7a, 0x44, 0x44, 0x5c, 0x9c, 0x27, 0x46, 0xb8, 0xd1, 0xe7,
	0xc9, 0x17, 0x1d, 0x18, 0x99, 0xdf, 0xe1, 0x3c, 0x49, 0x5a, 0x39, 0xfb, 0x71, 0x8e, 0xb2, 0xb6,
	0x25, 0x96, 0xb2, 0xe6, 0x1f, 0x37, 0x2b, 0x8a, 0x9c, 0xf6, 0x0e, 0x7b, 0x9a, 0x7f, 0x4e, 0x6c,
	0xac, 0xbb, 0x7f, 0xed, 0xba, 0x07, 0x1b, 0xd6, 0x3d, 0xdc, 0xb8, 0xee, 0x13, 0x7b, 0x8c, 0x9e,
	0xae, 0x88, 0x3a, 0x89, 0xda, 0xa7, 0xcc, 0x3d, 0x18, 0x92, 0xa8, 0x56, 0xba, 0x93, 0xfc, 0xdf,
	0xc3, 0xfe, 0x12, 0xd5, 0x6f, 0x25, 0x8a, 0x99, 0xe0, 0x0b, 0x9a, 0xa0, 0xb9, 0xcb, 0x90, 0x3a,
	0x50, 0x2e, 0x51, 0x14, 0x81, 0x06, 0xc1, 0x50, 0x8b, 0x36, 0x10, 0x5f, 0x2c, 0x24, 0x2a, 0x37,
	0xaa, 0x9c, 0xa4, 0x59, 0x93, 0xd0, 0x94, 0x2a, 0xb7, 0xb6, 0x58, 0xc1, 0xf7, 0x61, 0x6b, 0x89,
	0xea, 0x97, 0x34, 0x31, 0xb3, 0x44, 0xc7, 0xaf, 0xa5, 0xa6, 0xc5, 0xb3, 0xd8, 0x27, 0xb0, 0x73,
	0x41, 0xa3, 0x0b, 0x5d, 0xc5, 0x39, 0x1a, 0xf6, 0x36, 0x56, 0x51, 0xcb, 0xaa, 0xfb, 0x56, 0x56,
	0x0f, 0x01, 0x72, 0xa6, 0x68, 0x12, 0xc6, 0x44, 0xa1, 0x4b, 0x61, 0x6c, 0x34, 0x4f, 0x88, 0x42,
	0xff, 0x14, 0x76, 0x73, 0x36, 0x27, 0xec, 0x7d, 0xde, 0xe1, 0xff, 0xa5, 0x03, 0x9e, 0x40, 0xa9,
	0x04, 0x8d, 0xd4, 0x7b, 0x25, 0xfb, 0x53, 0x98, 0x64, 0x28, 0x52, 0x2a, 0xa5, 0x23, 0x9c, 0xee,
	0xf7, 0xd7, 0xaa, 0x7e, 0xeb, 0xe0, 0xb3, 0xca, 0x21, 0xa8, 0x7b, 0xaf, 0x55, 0xda, 0x5f, 0xaf,
	0xf4, 0xb3, 0x1e, 0xdc, 0xc9, 0x04, 0x4f, 0xb9, 0xc2, 0xf7, 0xca, 0xf1, 0x3b, 0xb0, 0x1b, 0x11,
	0x16, 0x46, 0x2b, 0xc2, 0x34, 0x7b, 0xd9, 0x82, 0xbb, 0x2d, 0xea, 0x56, 0x64, 0x60, 0x64, 0x4b,
	0x3c, 0x63, 0x0b, 0xae, 0x8f, 0x27, 0xed, 0x97, 0x71, 0xa9, 0x0a, 0xae, 0x4b, 0xf7, 0x6d, 0xe8,
	0x00, 0x33, 0x2e, 0x8b, 0x55, 0x40, 0x16, 0xbe, 0x7a, 0x3d, 0xa8, 0x7c, 0x07, 0xa5, 0xef, 0x2f,
	0xaa, 0xb5, 0x41, 0x7a, 0xc7, 0xb0, 0xa7, 0x7d, 0x63, 0x4c, 0x50, 0x61, 0xe5, 0x6d, 0xa7, 0x8d,
	0x0e, 0xf3, 0xc4, 0x58, 0x4a, 0xff, 0x23, 0xb8, 0xad, 0xfd, 0x29, 0xbb, 0xa4, 0x0a, 0x43, 0x5d,
	0x84, 0x34, 0x83, 0x66, 0x14, 0xec, 0x44, 0x84, 0x9d, 0x19, 0xb5, 0x66, 0xb9, 0xf4, 0x3e, 0x82,
	0x7d, 0xed, 0x59, 0x74, 0x32, 0x4c, 0x0d, 0x44, 0xd2, 0x1d, 0x01, 0x5e, 0x44, 0x58, 0xe0, 0x4c,
	0x16, 0xbc, 0x32, 0x76, 0x46, 0x59, 0x95, 0xc8, 0xb8, 0x8c, 0x3d, 0xa3, 0x6c, 0x3d, 0x6b, 0xd7,
	0x80, 0x32, 0x34, 0x94, 0x59, 0xcf, 0xac, 0xc5, 0x45, 0xf6, 0xff, 0x00, 0x9e, 0x44, 0xb5, 0xd6,
	0xef, 0xe6, 0x6e, 0xad, 0x11, 0xa7, 0x7b, 0x1d, 0xe2, 0xf8, 0x3f, 0x80, 0x7d, 0xfc, 0x24, 0xe3,
	0xc2, 0xbc, 0xce, 0x02, 0xf2, 0x94, 0xb2, 0x8b, 0xc6, 0xb7, 0xf9, 0x81, 0x5e, 0x75, 0x6d, 0x72,
	0xed, 0xf7, 0x9b, 0xdf, 0xab, 0xdf, 0x6f, 0x4e, 0x1e, 0xef, 0xad, 0xad, 0xe8, 0xfa, 0xeb, 0x77,
	0x97, 0x9e, 0xfe, 0x23, 0xd8, 0xb5, 0x2d, 0xbd, 0x3a, 0xac, 0xff, 0xb3, 0xf2, 0xfd, 0x2f, 0xcc,
	0x8e, 0xd0, 0xf6, 0x2b, 0xd4, 0xae, 0x14, 0xdd, 0xda, 0x4a, 0xe1, 0xff, 0xa6, 0xc4, 0xf6, 0x09,
	0xca, 0x48, 0xd0, 0xac, 0x7d, 0x40, 0x1e, 0xc2, 0x24, 0xae, 0xfc, 0x8a, 0x33, 0xb5, 0xa6, 0xf2,
	0xff, 0x08, 0x3b, 0x19, 0x75, 0x23, 0xe4, 0x8a, 0xcb, 0xe8, 0x2b, 0x76, 0xba, 0xeb, 0xff, 0x4e,
	0xf1, 0xbf, 0x0f, 0xb7, 0x73, 0xb6, 0xe1, 0xeb, 0xfd, 0x6f, 0xc3, 0x38, 0x41, 0x72, 0x69, 0x40,
	0x6e, 0xf6, 0xb2, 0xb3, 0xb9, 0xdd, 0xe7, 0x23, 0xb8, 0xeb, 0x7c, 0x4e, 0xe2, 0x94, 0x32, 0x2a,
	0x95, 0x20, 0x8a, 0x8b, 0x66, 0x8e, 0xfa, 0xc7, 0xb0, 0xe7, 0x9e, 0x70, 0x24, 0x3f, 0xe5, 0x79,
	0xcb, 0x7d, 0xa4, 0x7f, 0x02, 0xb7, 0xde, 0xf2, 0x7f, 0x87, 0xc1, 0xfc, 0x12, 0xee, 0xb8, 0x4e,
	0x3f, 0x57, 0x34, 0xba, 0x40, 0xf1, 0x1c, 0x5b, 0xb6, 0xa7, 0x23, 0xb8, 0x2d, 0xad, 0x5b, 0x28,
	0xd1, 0xad, 0x40, 0xb6, 0xdb, 0x3b, 0xb2, 0x7c, 0x5c, 0x2f, 0x42, 0xfa, 0x8b, 0xa9, 0xc8, 0xba,
	0x41, 0xe8, 0x9f, 0x6f, 0xff, 0xe3, 0xcd, 0x41, 0xe7, 0x9f, 0x6f, 0x0e, 0x3a, 0xff, 0x7a, 0x73,
	0xd0, 0x99, 0x0f, 0xcd, 0x37, 0xf0, 0xa3, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x61, 0x23, 0x69,
	0x23, 0x3a, 0x1a, 0x00, 0x00,
}
